\documentclass[parskip=full]{scrartcl}

\usepackage{pdfpages}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[german]{babel}
\usepackage{hyperref}
\hypersetup{
	pdftitle={Pflichtenheft},
	bookmarks=true,
}
\usepackage{csquotes}

\usepackage{fancyhdr}%<-------------to control headers and footers
\usepackage[a4paper,margin=1in,footskip=.25in]{geometry}
\fancyhf{}
\fancyfoot[C]{\thepage} %<----to get page number below text
\pagestyle{fancy} %<-------the page style itself

\usepackage{xcolor}
\usepackage{framed}
\definecolor{shadecolor}{RGB}{220,220,220}
\usepackage{float}


\title{Android GO! App - Pflichtenheft}
\author{Gruppe 3}
\date{11.06.17}

% define custom lists
\usepackage{enumitem}
\usepackage{lipsum}

\makeindex

\begin{document}

\begin{titlepage}
	\begin{center}
	{\scshape\LARGE \bfseries Entwurfsdokument \par}
	\vspace{1cm}
	{\scshape\Large Praktikum der Softwareentwicklung \\ Sommersemester 2017\par}
	\vspace{1.5cm}
	{\huge\bfseries Android GO! App\par}
	\vspace{2cm}
	{\Large\itshape - Gruppe 3 -\par}
	\vfill
	{\bfseries erstellt von:\par}
	Arsenii Dunaev \\
	Florian Kröger \\
	Tina Maria Strößner \\
	Volodymyr Shpylka \\	
	\vfill
	% Bottom of the page
	{\large 09.07.17 \par}	
	\end{center}
\end{titlepage}

\newpage

\begin{abstract}
Die Android App GO! ist eine mobile Applikation, die speziell zur Organisation von Treffen (z. B. gemeinsames Essen im Café oder in der Mensa) entwickelt wird. Beim erfolgreichen gemeinsamen Losgehen wird der gemittelte GPS-Standort von Mitgliedern der Gruppe angezeigt.\\

Dieses Dokument erläutert den Entwurf des Systems auf der Grundlage des Pflichtenhefts.
\end{abstract}

\newpage

\tableofcontents

\newpage

\section{Änderungen zum Pflichtenheft}

Es wurden im Entwurf folgende Änderungen gegenüber dem Pflichtenheft vorgenommen:
\begin{enumerate}
	\item \textbf{Produktdaten - Benutzer} \\
	Es werden in den Produktdaten zusätzlich eine (von Firebase automatisch generierte) InstanceID gespeichert, die es dem Server erlaubt, Daten an das Android-Gerät eines bestimmten Benutzers zu senden.
	\item \textbf{Detailansicht der GOs} \\
	Es ist jedem Mitglied einer Gruppen (unabhängig von Teilnahmestatus) möglich, die Detailansicht eines GOs aufzurufen. Um den Karten-Tab öffnen zu können, um die Standorte der anderen Teilnahmer zu verfolgen, gilt weiterhin, dass der Teilnahmestatus 'Bestätigt' oder 'Unterwegs' lauten muss.
\end{enumerate}

\newpage

\section{Architekturstil und Paketstruktur}

\subsection{Client}
Die Architektur der Client-Applikation orientiert sich am Model-View-ViewModel (MVVM) Muster. Dies wird auf Android-Systemen durch die auch hier eingesetzten Architecture Components unterstützt. \\

Die drei Komponenten der Applikation - Modell, View und ViewModell - haben dabei folgende Zuständigkeiten:\\

\textbf{Modell:}\\
Das Modell ist die Datenzugriffsschicht der Applikation, d.h. sie kapselt den Zugriff auf persistente Daten, die in einer lokalen SQLite Datenbank gehalten werden. Darüber hinaus enthält das Modell die Geschäftslogik der App.\\
Neben dem lokalen Modell-Paket muss außerdem die Datenkonsitenz mit dem Remote-Server der App gewährleistet werden. Die Kommunikation mit dem Server wird im Paket ServerCommunication implementiert. Koordiniert wird die Kommunikation der Komponenten Modell, Remote-Server und View durch Repository-Klassen, die als Vermittler auftreten (vgl. *Vermittler-Entwurfsmuster*).

\textbf{View:}\\
Die Views der App (sämtliche Activity- und Fragment-Klassen, sowie die dazugehörigen Layout .xml-Dateien) sind für die Präsentation, sowie die Implementierung der Präsentationslogik (Umsetzung der Eigenschaften der Daten und Weiterleitung von Benutzereingaben) der Daten es Viewmodells zuständig.

\textbf{ViewModell:}\\
Das ViewModell ist das Bidneglied zwischen View und Modell. Es tauscht Informationen mit dem Modell aus und stellt so der View öffentliche Eigenschaften und Befehle zur Verfügung, die an die Steuerungselemente der UI angebunden werden können. Dabei hat as ViewModell keine Referenz auf die View. Durch diese lose kopplung kann die View jederzeit ausgetauscht werden, ohne dass das ViewModell verändert werden muss.

In dieser Implementierung des MVVM Musters wurde die Applikation in folgende Pakete unterteilt:
\begin{itemize}
	\item Views
	\item Commands
	\item Model
	\item ViewModel
	\item ServerCommunication
\end{itemize}

Die folgende Abschnitte erläutern, welche Aufgaben die einzelnen Module haben und welche Abhängigkeiten zu anderen Paketen und Klassen bestehen.

\subsubsection{Views}
Das Paket Views enthält alle Klassen, die am User Interface des Benutzers beteiligt sind. Die Hauptaufgabe des Pakets ist es zum Einen, dem Benutzer ein Interface zur Verfügung zu stellen, mit dem er Interagieren kann, zum Anderen werden hier Benutzereingaben entgegengenommen und soweit ausgewertet, dass die Verarbeitung der Eingabe an die dafür zuständige Stelle im Programm weitergegeben werden kann.\\

\textbf{Abhängigkeiten zu anderen Paketen:}\\
Das Paket Views kann die Informationen, die dem Benutzer angezeigt werden, nicht selbst generieren, sondern bekommt diese bereitgestellt vom Paket Model. Welche Informationen das sind, wird bestimmt vom Paket Controller. Somit besteht eine Abhängigkeit zu den Paketen Controller und Model.\\

\textbf{Unterpakete:}\\
das Paket enthält das Unterpaket 'RecyclerView'. Da in der Applikation viele (verschiedene) RecyclerViews verwendet werden, gibt es für die Erstellung derselben ein eigenes Paket, dessen Aufgabe es ist, von den Datenobjekten die das Model liefert die gewünschten Informationen zu extrahieren und diese mit dem richtigen Layout zusammenzuführen. Innerhalb des Pakets besteht eine Abhängigkeit derjenigen View-Klassen, die einen RecyclerView verwenden zu dem Unterpaket RecyclerViews. Das Unterpaket RecyclerViews selbst ist nocht von anderen Klassen und Paketen abhängig.

\subsubsection{Model}
Das Paket Model enthält Klassen, deren Entitäten die physischen und konzeptuellen Objekte, mit denen umgegangen werden muss, abbilden und deren Funktionen und Eigenschaften modellieren.

\textbf{Abhängigkeiten zu anderen Paketen}\\
Das Paket benötigt, um seine Aufgaben erfüllen zu können, die Dienste des Pakets ServerCom. Für die Verwaltung der Daten der modellierten Entitäten ist Kommunikation mit dem Server notwenig (für das Holen und Speichern von Daten).

\textbf{Unterpakete:}\\

\subsubsection{Commands}
Das Paket Commands ist dafür verantwortlich für .....

\textbf{Abhängigkeiten zu anderen Paketen:}\\


\textbf{Unterpakete:}\\
\begin{enumerate}
	\item \textit{SinInHelper}\\
	Das Unterpaket SignInHelper ist für die Koordination des SignIn Prozesses zuständig. Die Anmeldung eines benutzers erfolgt in zwei Schritten: zunächst muss die Identität des Benutzers festgestellt werden (dies geschieht über eine Schnittstelle zu Firebase), danach müssen die Daten des identifizierten Benutzers geladen werden.
\end{enumerate}

\subsubsection{ServerCommunication}
Das Paket ServerCom übernimmt die Kommunikation der App mit dem Server, also das Speichern von Daten auf dem Server bzw. das Holden von Daten von dem Server.\\

\textbf{Abhängigkeiten zu anderen Paketen}\\
Das Paket hat keine Abhängigkeiten zu anderen Paketen.

\subsection{Server}
Das Programm des Servers ist in folgende Pakete aufgeteilt:
\begin{itemize}
	\item Communicationlayer
	\item BusinessLayer
	\item PersistenceLayer
\end{itemize}

\subsection{CommunicationLayer}
Das Paket CommunicationLayer vereint alle Klassen, die an der Kommunication mit den Clients beteiligt sind. Es besteht aus den Uunterpaketn Upstream und Downstream. Die Klassen des Pakets Upstream sind dafür zuständig, ein REST-API zur Verfügung zu stellen und auf Anfragen der Clients zu antworten, d.h. die Kommunikation wird von den LCients initiiert. Das Downstream-Paket hingegen schickt Nachrichten an Clients, ohne vorher von diesen angesprochen worden zu sein. Hierf"ur wird der Firebase Cloud Messaging Service benutzt.

\newpage


\section{verwendete Entwurfsmuster}

\subsection{Schablonenmethode für SignInHelper}
Die verschiedenen Anmelde-Aktivitäten aller Loginhelper-Klassen können über die signIn()-Methode angesto"sen werden. Der spezifische Ablauf der Anmelde-Aktivität wird in den Unterklassen durch die primitiven Methoden definiert. \\

\textbf{beteiligte Klassen:}
\begin{itemize}
	\item SignInHelper: besitzt die Methode signIn(), die als Schablonenmethode dient und bei der Ausführung die primitiven Methoden configureSignIn() und startSignInProcess() aufruft
	\item FirebaseSignInHelper: Unterklasse von SignInHelper, die die primitiven Methoden configureSignIn() und startSignInProcess() implementiert
	\item GoSignInHelper: Unterklasse von SignInHelper, die die primitiven Methoden configureSignIn() und startSignInProcess() implementiert
\end{itemize}

\subsection{Beobachter zum Aktualisieren des UI}
Durch das Ausführen von Befehlen von einem Benutzer, kann es zu Änderngen in den Daten kommen, die eine Änderung des aktuellen Views anderer Benutzer erfordern. Diese 1-zu-n Abhängigkeit wird durch ein Beobachter-muster behandelt. Die dafür benötigte Funktionalität wird von der Architecture-Components Framework Klasse LiveData<> bereitgestellt. Ein Objekt dieser Klasse kann von einem LifeCycleOwner (z.B. eine Lifecycle-Activity oder ein LifecycleFragment) beobachtet werden und löst bei Änderung den Methodenaufruf \textit{onChanged()} aus. Die Livedata-Objekte sind Lifecycle-Aware, das bedeutet eine Benachrichtigung über eine Änderung wird nur dann an einen Beobachter weitergeleitet, wenn er sich in einem aktiven Stadium seines Lifecycles befindet.\\
\textbf{beteiligte Klassen:}
\begin{itemize}
	\item \textit{LiveData<>:}\\ das beobachtete Subjekt
	\item \textit{BaseActivity (die von LifecycleActivity erbt):}\\ Der Beobachter, der bei Änderung der Daten benachrichtigt wird und daraufhin das dem Benutzer präsentierte UI aktualisiert.
\end{itemize}

\subsection{DAO-Pattern zur lokalen Persisitierung von Daten}
Damit nicht bei jeder Datenanforderung, die vom UI gestellt wird, ein Zugriff auf den Tomcat-Server unternommen werden muss, werden die Daten des Benutzers lokal in einer SQLite Datenbank persistiert. Die Implementierung des Datenbankschemas und der Datenbankzugriffe wird mithilfe des Android-Framworks Room realisiert. Dabei wird ein Data Access Object Pattern verwendet.
Die Entity-Beans definieren dabei, wie das Schema der Datenbank aufgebaut wird (jede als entity annotierte klasse wird als eine Tabelle in der Datenbank umgesetzt), die DAO-Interfaces definieren die Methoden, mit denen vom Programm aus af die Datenbank zugegriffen werden kann.\\

\textbf{beteiligte Klassen:}\\
\begin{itemize}
	\item \textit{User, Go, Group:}\\ Entity-Beans, die die Struktur der Datenbankrelationen darstellen
	\item \textit{UserDao, GoDao, GroupDao:}\\ Data-Access-Object Interfaces, die die eigentlichen Zugriffe auf die Datenbank übernehmen.
\end{itemize}

\subsection{Vermittler zur Koordination von Datenzugriffen}
Wenn der Benutzer bestimmte Daten anzigen will, muss die App diese Daten zunächst beschaffen, entweder aus den lokal persisitierten Daten oder gegebenenfalls vom Remote-Server des Systems- Ähnlich verhält es sich mit Änderungen von Daten: Die Änderungen müssen sowohl lokal in der SQLIte Datenbank und im ViewModell, als auch auch der zentralen Datenbank des Server geändert werden.\\
Um diese vielen Abhängigkeiten zu verwalten und die Konsistenz der Daten sicherzustellen, sollen Datarepository-Klasssen implementiert werden, die als Vermittler zwischen den Kollegen dienen.
So muss das ViewModell zum Erstellen/Ändern/Löschen von Daten lediglich das DataRepository ansprechen, ohne die darunterliegende Datenpersistenzlogik zu kennen. Auch der Server kommuniziert seine Daten nur mit der Datarepository. Modell und Viewmodell müssen sich so gegenseitig nicht referenzieren, sondern für alle Komponenten eyisitert ein zentraler Ansprechpartner.\\

\textbf{beteiligte Klassen:}\\
\begin{itemize}
	\item \textit{GoRepository/GroupRepository:}\\
	 Vermittler
	\item \textit{ViewModell, TomcatrestApi, Dao:}\\ Kollegen
\end{itemize}

\subsection{singleton zur Vermeidung häufiger Instanziierung von schwergewichtigen DataRepositories}

\subsection{Dependency Injection}

\subsection{DAO Pattern für Datenpersistenz auf dem Server}

\subsection{Strategiemuster zur Kapselung des Clustering-Alogithmus}
Das Clustern der Standorte der Teilnehmer eines GOs wird von der Klasse GoClusterStrategy übernommen. Diese Klasse ist mittels eines Strategy-Patterns in das Programm eingebunden. Dies entkoppelt den Algorithmus von seinem Kontext und erkann dynamisch durch andere Clustering-Alogirthmen ersetzt oder ergänzt werden. \\

\textbf{beteiligte Klassen:}
\begin{itemize}
	\item \textit{LocationService} \\
	Die Klasse ist der Kontext der Clustering-Strategie. Von hier aus wird die Ausführung des Algorithmus angestoßen.
	\item \textit{ClusterStrategy} \\
	ClusterStrategy ist ein Interface, das von jedem Cluster-Algorithmus implementiert werden muss. Es definiert eine \textit{caluculateCluster()} Methode, die eine Liste an einzelnen User-Standorten entgegen nimmt und eine Liste an User-Clustern zurückgibt.
	\item \textit{GoClusterStrategy} \\
	In dieser Klasse wird der Clustering-Algorithmus implementiert, der angewendet werden soll. Die Klasse erweitert das Interface ClusterStrategy.
\end{itemize}

\subsection{Fassade zur Vereinfachung des Server Interfaces}
Der verwendete Tomcat-Server bietet seinem Clients zur Kommunikation ein REST Interface an. Das Ansprechen der verschiedenen REST Ressourcen ist in der App hinter dem Interface \textit{TomcatRestApi}. Das Interface bietet den aufrufenden Klassen Methoden zum aufrufen der REST Ressourcen an, ohne das ein Aufrufer etwas von der eigentlichen Kommunikation mit dem Server wissen muss. \\

\textbf{beteiligte Klassen}
\begin{itemize}
	\item \textit{TomcatRestApi} \\
	Das Interface ist die Fassade, die die Schnittstelle zum Tomcat-Server hinter sich versteckt. Nach außen werden Methoden bereitgestellt, die von anderen Klassen aufgerufen werden können, um Server-Dienste in Anspruch nehmen zu können, ohne sich um die Details der Kommunikation zu kümmern.
\end{itemize}

\end{document}

