\documentclass[11pt,a4paper]{article}
\usepackage{color}
\usepackage{ifthen}
\usepackage{ifpdf}
\usepackage[headings]{fullpage}
\usepackage{listings}
\lstset{language=Java,breaklines=true}
\ifpdf \usepackage[pdftex, pdfpagemode={UseOutlines},bookmarks,colorlinks,linkcolor={blue},plainpages=false,pdfpagelabels,citecolor={red},breaklinks=true]{hyperref}
  \usepackage[pdftex]{graphicx}
  \pdfcompresslevel=9
  \DeclareGraphicsRule{*}{mps}{*}{}
\else
  \usepackage[dvips]{graphicx}
\fi

\newcommand{\entityintro}[3]{%
  \hbox to \hsize{%
    \vbox{%
      \hbox to .2in{}%
    }%
    {\bf  #1}%
    \dotfill\pageref{#2}%
  }
  \makebox[\hsize]{%
    \parbox{.4in}{}%
    \parbox[l]{5in}{%
      \vspace{1mm}%
      #3%
      \vspace{1mm}%
    }%
  }%
}
\newcommand{\refdefined}[1]{
\expandafter\ifx\csname r@#1\endcsname\relax
\relax\else
{$($in \ref{#1}, page \pageref{#1}$)$}\fi}
\date{\today}
\chardef\textbackslash=`\\
\usepackage{pdfpages}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[german]{babel}
\usepackage{hyperref}
\hypersetup{
	pdftitle={Pflichtenheft},
	bookmarks=true,
}
\usepackage{csquotes}

\usepackage{fancyhdr}%<-------------to control headers and footers
\usepackage[a4paper,margin=1in,footskip=.25in]{geometry}
\fancyhf{}
\fancyfoot[C]{\thepage} %<----to get page number below text
\pagestyle{fancy} %<-------the page style itself

\usepackage{xcolor}
\usepackage{framed}
\definecolor{shadecolor}{RGB}{220,220,220}
\usepackage{float}


\title{Android GO! App - Pflichtenheft}
\author{Gruppe 3}
\date{11.06.17}

% define custom lists
\usepackage{enumitem}
\usepackage{lipsum}

\begin{document}

\begin{titlepage}
	\begin{center}
	{\scshape\LARGE \bfseries Entwurfsdokument \par}
	\vspace{1cm}
	{\scshape\Large Praktikum der Softwareentwicklung \\ Sommersemester 2017\par}
	\vspace{1.5cm}
	{\huge\bfseries Android GO! App\par}
	\vspace{2cm}
	{\Large\itshape - Gruppe 3 -\par}
	\vfill
	{\bfseries erstellt von:\par}
	Arsenii Dunaev \\
	Florian Kröger \\
	Tina Maria Strößner \\
	Volodymyr Shpylka \\	
	\vfill
	% Bottom of the page
	{\large 09.07.17 \par}	
	\end{center}
\end{titlepage}

\begin{abstract}
Die Android App GO! ist eine mobile Applikation, die speziell zur Organisation von Treffen (z. B. gemeinsames Essen im Café oder in der Mensa) entwickelt wird. Beim erfolgreichen gemeinsamen Losgehen wird der gemittelte GPS-Standort von Mitgliedern der Gruppe angezeigt.\\

Dieses Dokument erläutert den Entwurf des Systems auf der Grundlage des Pflichtenhefts. Dazu wird zunächst die Modulstruktur und der Architekturstil erläutert. Danach werden die Klassen, Attribute und Methoden der Anwendung detailliert beschreiben. Das Zusammenspiel der einzelnen Klassen wird dargestellt im Klassendiagramm. Weitere Abschnitte erläutern die Client-Server Schnittstelle, das Datenbankschema er Applikation sowie typische Ausführungsabläufe.
\end{abstract}

\newpage

\sloppy
\addtocontents{toc}{\protect\markboth{Contents}{Contents}}
\tableofcontents

\newpage

\section{Änderungen zum Pflichtenheft}

Es wurden im Entwurf folgende Änderungen gegenüber dem Pflichtenheft vorgenommen:
\begin{enumerate}
	\item \textbf{Produktdaten - Benutzer} \\
	Es werden in den Produktdaten zusätzlich eine (von Firebase automatisch generierte) InstanceID gespeichert, die es dem Server erlaubt, Daten an das Android-Gerät eines bestimmten Benutzers zu senden.
	\item \textbf{Detailansicht der GOs} \\
	Es ist jedem Mitglied einer Gruppen (unabhängig von Teilnahmestatus) möglich, die Detailansicht eines GOs aufzurufen. Um den Karten-Tab öffnen zu können, um die Standorte der anderen Teilnehmer zu verfolgen, gilt weiterhin, dass der Teilnahmestatus 'Bestätigt' oder 'Unterwegs' lauten muss.
	\item \textbf{Profil- und Gruppenbilder} \\
	Das Wunschkriterium der Profil- und Gruppenbilder wurde im Entwurf nicht berücksichtigt. Stattdessen werden in der App definierte Standardbilder dazu angezeigt.
\end{enumerate}

\newpage

\section{Architekturstil und Paketstruktur}
Dieses Kapitel erläutert den Architekturstil und die Paketstruktur des Systems. es wird noch nicht auf einzelne Klassen eingegangen sondern lediglich die Zusammenarbeit der Module beschrieben und die Abhängigkeiten untereinander.

Aufgebaut ist das System mit einer Client-Server-Architektur, d.h. es gibt eine Client-Applikation, die auf den Android-Geräten der Benutzer läuft und Services des Servers in Anspruch nimmt und eine Server-Anwendung, die auf dem Tomcat-Server läuft, der diese Services bereitstellt und auf Anfrage eines Clients seine Dienste erfüllt.

\subsection{Client}
Die Architektur der Client-Applikation orientiert sich am Model-View-View-Model (MVVM) Muster. Dies wird auf Android-Systemen durch die, auch hier eingesetzten, Architecture Components unterstützt. Das untenstehende Paketdiagramm zeigt den groben Aufbau der Client-Applikation, welche Abhängigkeiten bestehen und welche Aufgaben jedes Paket übernimmt. Genauere Erläuterungen hierzu finden sich in den darauffolgenden Abschnitten.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{../Klassendiagramme/Client_PackageDiagram.jpg}
	\caption{Paketdiagramm der Clientanwendung}
\end{figure}

\subsubsection{Views}
Das Paket Views enthält alle Klassen, die am User Interface des Benutzers beteiligt sind. Das sind sämtliche Activities, Fragments und dazugehörige .xml-Layouts. Das Modul ist für die Präsentation der Appdaten sowie die Implementierung der Präsentationslogik (Umsetzung der Eigenschaften der Daten und Weiterleitung von Benutzereingaben) zuständig.\\

\textbf{Abhängigkeiten zu anderen Paketen:}\\
Das Paket Views kann die Informationen, die dem Benutzer angezeigt werden, nicht selbst generieren, sondern bekommt diese bereitgestellt von den entsprechenden ViewModels. Es kennt ebenfalls nicht die Funktionen, die ein User in einer bestimmten Ansicht ausführen kann. Es besteht also eine Abhängigkeit zu dem Paket ViewModels. Von anderen Paketen weiß die VIew nichts und wird auch nicht von ihnen angesprochen.\\

\textbf{Unterpakete:}\\
das Paket enthält das Unterpaket 'RecyclerView'. Da in der Applikation viele (verschiedene) RecyclerViews verwendet werden, gibt es für die Erstellung derselben ein eigenes Paket, dessen Aufgabe es ist, von den Datenobjekten die das Model liefert die gewünschten Informationen zu extrahieren und diese mit dem richtigen Layout zusammenzuführen. Innerhalb des Pakets besteht eine Abhängigkeit derjenigen View-Klassen, die einen RecyclerView verwenden zu dem Unterpaket RecyclerViews. Das Unterpaket RecyclerViews selbst ist nicht von anderen Klassen und Paketen abhängig.\\

\subsubsection{Entities}
Das Modell enthält die Entity-Klassen der App, die die reale Objekte und Konzepte als Java-Objekte abbilden. Sie bilden das Modell im Modell-View-ViewModell-Konzept. Die Entities dienen hauptsächlich zur Kapselung der Daten in der App. Darüber hinaus gibt die Struktur der Entites (die mit der Struktur der Entity-Klassen auf dem Server übereinstimmt) den Aufbau der Datenbank, sowie der JSON-Objekte, die zur Kommunikation zwischen Client und Server verwendet werden vor.\\

\textbf{Abhängigkeiten zu anderen Paketen}\\
Das Paket Entities hat keine Abhängigkeiten zu anderen Paketen. Da die Objekte allerdings an allen Use Cases beteiligt sind, gibt es viele Pakete die Abhängigkeiten zu den Entities haben.\\

\subsubsection{ViewModell}
Das ViewModell ist das Bindeglied zwischen View und Entites. Es tauscht Informationen mit dem Modell aus und stellt so der View öffentliche Eigenschaften und Befehle zur Verfügung, die an die Steuerungselemente der UI angebunden werden können. Dabei hat das ViewModell keine Referenz auf die View. Durch diese lose Kopplung kann die View jederzeit ausgetauscht werden, ohne dass das ViewModell verändert werden muss.\\

\textbf{Abhängigkeiten zu anderen Paketen}\\
Das ViewModell benötigt eine Referenz zum Modell, um die von der View empfangenen Befehle weiterleiten und die richtigen Daten von Modell anfordern zu können. Um diese Abhängigkeit zu entkoppeln und das Ansprechen der richtigen Modellkomponente zu erleichtern, wird diese Abhängigkeit über einen Vermittler ("Repository") geleitet. Dies ermöglicht das einfache Austauschen des Modells, ohne dass das ViewModell verändert werden muss.\\

\subsubsection{ServerCommunication}
Das Paket ServerCommunication übernimmt die Kommunikation der App mit dem Server, also das Speichern von Daten auf dem Server bzw. das Holen von Daten von dem Server. Darüber hinaus werden in diesem Paket auch Nachrichten, die vom Server gesendet werden empfangen und an das Modell zur Verarbeitung weitergeleitet.\\

\textbf{Abhängigkeiten zu anderen Paketen}\\
Das Paket hat keine Abhängigkeiten zu anderen Paketen der Applikation. Die Implementierung des REST-Clients erfolgt über das Framework \textit{Retrofit 2}. Hier besteht also eine Abhängigkeit zu einem externen Framework. Außerdem benötigt das Modul zur fehlerfreien Ausführung seiner Aufgaben ein funktionierendes Backend (REST-Api, das die entsprechenden Ressourcen bereitstellt) des Systems.\\

\textbf{Unterpakete:}\\
Das Modul ServerCommunication setzt sich aus zwei Untermodulen zusammen. Das Modul \textit{Downstream} implementiert die Kommunikation, die über die REST-Api des Tomcat-Servers läuft, also jegliche Kommunikation, die von einem Client initiiert wird. Das Modul \textit{Upstream} hingegen ist dafür zuständig Kommunikationsströme zu empfangen, die vom Server initiiert werden und diese den Vermittlern zur Verbreitung weiterzuleiten.\\

\subsubsection{ServerCommands}
Das Paket ServerCommands kapselt alle Server-Nachrichten, die ein CLient bekommen kann in einem Befehlsmuster. Die Aufgabe dieses Moduls ist es die ankommenden Nachrichten zu analysieren und die Änderungen an die Repositories zu geben und anschließend die ViewModells zu benachrichtigen, sich die aktuellen Daten bei den ViewModells abzuholen.\\

\textbf{Anhängigkeiten zu anderen Paketen}\\
Das Paket ServerCommands ist abhängig von dem Paket Repositories. Ohne dieses Paket können die einzelnen Commands ihre Aufgabe, aktualisierte Daten dort abzulegen, wo die ViewModels sie finden, nicht erfüllen. Die Nachrichten, die an die Commands von dem ServerCommunication Package kommen, können leicht simuliert werden, weshalb für die Implementierung keine Abhängigkeit zu diesem Modul besteht.\\

\subsubsection{Repositories}
Wie in den vorherigen Abschnitten erläutert, ist die Geschäftslogik der App aufgeteilt auf den lokalen Teil (Entities und ServerCommands) und einen Remote-Teil (ServerCommunication), die miteinander synchronisiert werden müssen. Zusätzlich müssen die ViewModells nach sämtlichen Änderungen mit den aktuellsten Daten versorgt werden. Diese Abhängigkeiten der einzelnen Komponenten werden in den Repository-Klassen zusammengefasst. Genauere Erläuterungen zur Funktionsweise finden sich in Abschnitt \ref{Vermittler}.\\

\textbf{Abhängigkeiten zu anderen Paketen:}\\
Damit die Repositories ihren Zweck erfüllen können, müssen alle Kollegen des Vermittler-Musters implementiert sein. Für die Implementierung selbst, ist es wichtig, dass das ServerCommunication Modul und die Entities implementiert werden, bevor die Repositories implementiert werden.\\

\subsection{Server}
Die Architektur des Servers orientiert sich an einer Schichten-Architektur. Dabei handelt es sich nicht um eine klassische Schichtenarchitektur, bei der nur obere Schichten Dienste der unteren Schichten aufrufen darf. Stattdessen sind die oberen Schichten in zwei Unterpakete unterteilt. In einer Hälfte jeder Schicht gehen die Methodenaufrufe von oben nach unten, in der anderen von unten nach oben. Durch diese zwei Säulen in der Anwendung ist die Implementierung, trotz Verletzung des Schichtenmodells, leicht realisierbar, da die Unterpakete immer noch topologisch sortierbar sind, sodass eine Implementierungsreihenfolge gefunden werden kann, bei der zu jeder Zeit die Abhängigkeiten des gerade entwickelten Moduls bereits implementiert sind.\\

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{../Klassendiagramme/paketdiagramm_server.png}
	\caption{Paketdiagramm der Clientanwendung}
\end{figure}

Das Programm des Servers ist in folgende Pakete aufgeteilt:
\begin{itemize}
	\item CommunicationLayer
	\item BusinessLayer
	\item PersistenceLayer
\end{itemize}

\subsubsection{CommunicationLayer}
Dieses Paket bildet die oberste Schicht der Serveranwendung und ist die einzige Schicht, die für die Clients sichtbar ist. Die CommunicationLayer vereint alle Klassen, die an der Kommunikation mit den Clients beteiligt sind. Es besteht aus den Unterpaketen Upstream und Downstream. Die Klassen des Pakets Upstream sind dafür zuständig, ein REST-API zur Verfügung zu stellen und auf Anfragen der Clients zu antworten, d.h. die Kommunikation wird von den Clients initiiert. Das Downstream-Paket hingegen schickt Nachrichten an Clients, ohne vorher von diesen angesprochen worden zu sein. Hierfür wird der Firebase Cloud Messaging Service benutzt.\\

Das Untermodul Upstream nimmt die Dienste der unteren Schichten in Anspruch. Dabei handelt es sich um eine transparente Schichtenarchitektur, das bedeutet das Modul nimmt nicht nur die Dienste der mittleren, sondern auch die Dienste der unteren Schicht in Anspruch.\\

Das Untermodul Downstream hingegen bietet Dienste an, nämlich das versenden von Nachrichten an Clients, die von den unteren Schichten der Serveranwendung verwendet wird.\\

\subsubsection{BusinessLayer}
Die BusinessLayer ist die mittlere Schicht und beinhaltet den Großteil der Anwendungslogik der Serveranwendung. Wie die anderen Schichten des Server, besteht auch die BusinessLayer aus zwei Untermodulen: LocationService und DataObserver.\\

Das Modul LocationService kümmert sich um alle Angelegenheiten, die mit der Erfassung, der kurzzeitigen Persistierung und dem Clustering von Standortdaten zusammenhängen. Dieser Dienst wird von der oberen Schicht in Anspruch genommen. Zur unteren Schicht bestehen keine Abhängigkeiten, da Standortdaten nicht in der Datenbank gespeichert werden. Dieses Untermodul hat selbst also keine Abhängigkeiten zu anderen Paketen.\\

Das zweite Untermodul der BusinessLayer ist das DataObserver-Modul. Dieses Modul wird bei Änderungen in der Datenbasis von der PersistenceLayer angesprochen und kümmert sich folgend darum, die Änderungen zu analysieren, herauszufinden welche Clients von der Änderung erfahren müssen und diese Informationen an die obere Schicht weiterzuleiten, um eine Nachricht an genau diese Clients zu schicken. Dementsprechend bietet dieses Untermodul einen Dienst, der von der PersistenceLayer in Anspruch genommen wird und nimmt einen Dienst in Anspruch der von der CommunicationLayer angeboten wird.\\

\subsubsection{PersistenceLayer}
Die PersistenceLayer kapselt das Datenmodell der Anwendung in sich. Sie ist für die Speicherung der Daten zuständig, sowie für die Weiterleitung der Daten an die CommunicationLayer und somit an die Clients. Die PersistenceLayer setzt sich zusammen aus einer MySQL-Datenbank, die mit dem ORM-Framework Hibernate verwaltet wird und DAO-Klassen, in denen die Datenbankzugriffe gekapselt werden.\\

Im Gegensatz zu den zwei anderen Schichten gibt es in dieser Schicht keine Untermodule. Der Dienst des Moduls wird von dem Upstream-Modul der CommunicationLayer in Anspruch genommen. Geschieht dies, wird aus der PersistenceLayer der Dienst der DataObserver angestoßen, um die Änderungen in dem Datenbestand wieder durch die Schichten nach oben und schließlich zu den Clients zu leiten.\\

\newpage


\section{verwendete Entwurfsmuster}

\subsection{Schablonenmethode für SignInHelper}
Die verschiedenen Anmelde-Aktivitäten aller Loginhelper-Klassen können über die signIn()-Methode angestoßenen werden. Der spezifische Ablauf der Anmelde-Aktivität wird in den Unterklassen durch die primitiven Methoden definiert. \\

\textbf{beteiligte Klassen:}
\begin{itemize}
	\item \textit{SignInHelper}\\ besitzt die Methode signIn(), die als Schablonenmethode dient und bei der Ausführung die primitiven Methoden configureSignIn() und startSignInProcess() aufruft
	\item \textit{FirebaseSignInHelper}\\ Unterklasse von SignInHelper, die die primitiven Methoden configureSignIn() und startSignInProcess() implementiert
	\item \textit{GoSignInHelper}\\ Unterklasse von SignInHelper, die die primitiven Methoden configureSignIn() und startSignInProcess() implementiert
\end{itemize}

\subsection{Beobachter zum Aktualisieren des UI}
Durch das Ausführen von Befehlen von einem Benutzer, kann es zu Änderungen in den Daten kommen, die eine Änderung des aktuellen Views anderer Benutzer erfordern. Diese 1-zu-n Abhängigkeit wird durch ein Beobachter-muster behandelt. Die dafür benötigte Funktionalität wird von der Architecture-Components Framework Klasse LiveData<> bereitgestellt. Ein Objekt dieser Klasse kann von einem LifeCycleOwner (z.B. eine Lifecycle-Activity oder ein LifecycleFragment) beobachtet werden und löst bei Änderung den Methodenaufruf \textit{onChanged()} aus. Die LiveData-Objekte sind Lifecycle-Aware, das bedeutet eine Benachrichtigung über eine Änderung wird nur dann an einen Beobachter weitergeleitet, wenn er sich in einem aktiven Stadium seines Lifecycles befindet.\\

\textbf{beteiligte Klassen:}
\begin{itemize}
	\item \textit{LiveData<>:}\\ das beobachtete Subjekt
	\item \textit{BaseActivity (die von LifecycleActivity erbt):}\\ Der Beobachter, der bei Änderung der Daten benachrichtigt wird und daraufhin das dem Benutzer präsentierte UI aktualisiert.
\end{itemize}

\subsection{Beobachter zum Weiterleiten von Änderungen der Datenbasis}
Werden von einem Client Daten der App geändert (z.B. eine GO erstellt, ein Benutzer zu einer Gruppe hinzugefügt) betrifft dies in vielen auch die Daten, die ein anderer Client bei sich gespeichert hat und benutzt. Dementsprechend müssen Clients vom Server über Änderungen in der Datenbasis informiert werden können. Es ergibt sich eine 1-zu-n-Abhängigkeit: n Clients sind von 1 Datenbasis abhängig.

Zur Auflösung dieser Abhängigkeit wird in der Anwendung eine Beobachter-Muster verwendet. Die Datenbasis wird beobachtet und bei Änderungen leiten die Beobachter die Benachrichtigung der Clients
ein. Da ein Beobachter nicht ein einzelnes Objekt, sondern eine gesamte Datenbanktabelle beobachtet, ist es schwierig, den aktuellen Zustand des Subjekts im Beobachter zu speichern. Aus diesem Grund verwenden die Beobachter eine push-Methodik, bei der die Änderungen bei der Benachrichtigung der Beobachter mit übergeben werden.

\textbf{beteiligte Klassen:}
\begin{itemize}
	\item \textit{Observable<T>}\\ Das Interface ist das abstrakte Subjekt. Jedes konkrete Subjekt muss dieses Interface und damit die Methode notify() implementieren. Diese Methode benachrichtigt die Beobachter über ein Update in der Datenbasis.
	\item \textit{DAO-Klassen}\\ Diese Klassen implementieren das Interface Observable und sind die konkreten Subjekte, die von den Beobachtern beobachtet werden.
	\item \textit{Observer}\\ Das Interface Observer ist der abstrakte Beobachter. Jeder konkrete Beobachter muss dieses Interface und damit die Methode update() implementieren.
	\item \textit{EntityObserver}\\Konkrete Beobachter, die das Interface Observer implementieren. Jede dieser Klassen übernimmt die Verantwortung für bestimmte Änderungen in der Datenbasis, analysiert, welche Änderung geschehen ist und übergibt diese Daten zum versenden an den FcmClient.
\end{itemize}

\subsection{DAO-Pattern zur Persistierung von Daten}
Die Daten der App werden in eine MySQL-Datenbank persistiert. Für den Zugriff auf diese Datenbank wird ein Data Access Object Entwurfsmuster verwendet. Dabei werden zum Einen Java Beans verwendet, die die Struktur der Datenbankrelationen festlegen. Zum Anderen gibt es spezielle DAO-Klassen die alle Datenbankzugriffe in sich kapseln. So können zusätzliche Zugriffsmethoden für die Datenbank hinzugefügt werden, ohne die Entity-Klassen verändern zu müssen. Andersherum kann der Aufbau der Datenbank verändert werden, ohne dass die DAO-Klassen ihre Schnittstelle nach außen verändern.
Die Umsetzung der Datenbank und der SQL-Queries wird mithilfe des Frameworks Hibernate realisiert.\\

\textbf{beteiligte Klassen:}
\begin{itemize}
	\item \textit{UserEntity, GoEntity, GroupEntity}\\ Entity-Beans, die die Struktur der Datenbankrelationen darstellen
	\item \textit{AbstractDAO}\\ Interface für eine DAO-Klasse, welches Zugriffsmethoden definiert, die auf jeder Datenbanktabelle durchgeführt werden müssen (CRUD)
	\item \textit{UserDao, GoDao, GroupDao}\\ Data-Access-Object Interfaces, die spezielle Zugriffsmethoden enthalten, die nur für bestimmte Datenbanktabellen gebraucht werden.
	\item \textit{UserDaoImp, GoDapImp, GroupDaoImp}\\ konkrete Implementierungen der DAO Interfaces. Hier werden die Zugriffsmethoden anhand des von den Entity-Klassen definierten Datenbankschemas
	implementiert.
\end{itemize}

\newpage

\subsection{Vermittler zur Koordination von Datenzugriffen}\label{Vermittler}
Viele Apps Nutzen eine lokale Datenbank, um eine Benutzung der App, zumindest ansatzweise, auch ohne Internetverbindung zu ermöglichen. Auch wenn in diesem Entwurf keine lokale Datenbank auf den Clients vorgesehen ist, soll dieses Feature leicht erweiterbar sein. Zu diesem Zweck ist bei der Aktualisierung/Beschaffung der Daten für die ViewModells eine zusätzliche Indirektionsstufe eingebaut: Die Repositories. Diese übernehmen im Zusammenspiel der App-Komponenten eine Vermittler-Funktion: Während die ViewModells wissen WAS gemacht werden muss (da diese die aktuellen Daten und Funktionen für den User speichern), wissen die Repositories WO dies getan werden muss - in der lokalen Datenbank, in den SharedPreferences des Android-Geräts oder auf dem Remote Server.\\

\textbf{beteiligte Klassen:}
\begin{itemize}
	\item \textit{GoRepositor, GroupRepository, UserRepository:}\\
	 Die Vermittler die die Koordination der Kollegen übernehmen
	\item \textit{ViewModell, TomcatRestApi, lokale Datenbank, SharedPreferences:}\\ Kollegen, die nichts voneinander wissen, sondern bei allen Aufrufen vom Vermittler angesprochen werden, bzw. den Vermittler ansprechen.
\end{itemize}

\subsection{Strategiemuster zur Kapselung des Clustering-Algorithmus}
Das Clustern der Standorte der Teilnehmer eines GOs wird von der Klasse GoClusterStrategy übernommen. Diese Klasse ist mittels eines Strategy-Patterns in das Programm eingebunden. Dies entkoppelt den Algorithmus von seinem Kontext und er kann dynamisch durch andere Clustering-Algorithmen ersetzt oder ergänzt werden. \\

\textbf{beteiligte Klassen:}
\begin{itemize}
	\item \textit{LocationService} \\
	Die Klasse ist der Kontext der Clustering-Strategie. Von hier aus wird die Ausführung des Algorithmus angestoßen.
	\item \textit{ClusterStrategy} \\
	ClusterStrategy ist ein Interface, das von jedem Cluster-Algorithmus implementiert werden muss. Es definiert eine \textit{calculateCluster()} Methode, die eine Liste an einzelnen User-Standorten entgegen nimmt und eine Liste an User-Clustern zurückgibt.
	\item \textit{GoClusterStrategy} \\
	In dieser Klasse wird der Clustering-Algorithmus implementiert, der angewendet werden soll. Die Klasse erweitert das Interface ClusterStrategy.
\end{itemize}

\subsection{Fassade zur Vereinfachung des Server Interfaces}
Der verwendete Tomcat-Server bietet seinem Clients zur Kommunikation ein REST Interface an. Das Ansprechen der verschiedenen REST Resourcen ist in der App hinter dem Interface \textit{TomcatRestApi}. Das Interface bietet den aufrufenden Klassen Methoden zum aufrufen der REST Resourcen an, ohne das ein Aufrufer etwas von der eigentlichen Kommunikation mit dem Server wissen muss. \\

\textbf{beteiligte Klassen}
\begin{itemize}
	\item \textit{TomcatRestApi} \\
	Das Interface ist die Fassade, die die Schnittstelle zum Tomcat-Server hinter sich versteckt. Nach außen werden Methoden bereitgestellt, die von anderen Klassen aufgerufen werden können, um Server-Dienste in Anspruch nehmen zu können, ohne sich um die Details der Kommunikation zu kümmern.
\end{itemize}

\subsection{Dekorierer zur Erweiterung der Aktivitäten für Sonderbenutzer}
Für GO-Verantwortliche und Gruppenadmins werden GroupDetailActivity oder GoDetailActivity entsprechend erweitert. Zusätzliche Buttons und Methoden werden hinzugefügt.(z.B. Name der Gruppe ändern, Mitglieder hinzufügen usw.) Dazu haben wir eine Android-Version von Dekorierer benutzt. Die spezielle Unterklassen (GroupDetailActivityOwner bzw. GoDetailActivityOwner) von oben genannten Activities benutzen fertige Oberklassen Activities und fügen darauf die benötigte Funktionalität hinzu.\\

\textbf{beteiligte Klassen}
\begin{itemize}
\item \textit{GroupDetailActivity} \\
Activity, wo die Gruppendetails angezeigt werden. Ist eine Oberklasse von GroupDetailActivityOwner.
\item \textit{GroupDetailActivityOwner}\\
Erweitert die Oberklasse um Funktionen für die Admins.
\item \textit{GoDetailActivity}\\
Activity, wo Go-Details angezeigt werden. Oberklasse von GoDetailActivityOwner.
\item \textit{GoDetailActivityOwner}\\
Erweitert die Oberklasse um Funktionen für den GO-Verantwortlichen
\end{itemize}


\subsection{Command Muster zur Bearbeitung der Server Messages auf der Client Seite}
Mit dem Command Muster haben wir die Bearbeitung der Messages von den Messages selbst getrennt. Messages kommen vom Server zu Client mit Hilfe von Firbase. Auf der Client Seite wird das Message vom MessageReceiver empfangen und zu einer der ServerCommand Unterklassen gemappt. Das erlaubt uns auch den Message Flow zu loggen z.B. In dem Command selbst wird schon entschieden, was der Client mit dem Message macht und was ausgeführt wird.

\textbf{beteiligte Klassen}
\begin{itemize}
\item \textit{FcmClient} \\
Verschickt die Messages an die Clients.
\item \textit{MessageReceiver}\\
Empfängt die Messages und mappt diese zu einem ServerCommand.
\item \textit{ServerCommand}\\
Kümmert sich um die Ausführung des Befehls, ändert die Daten auf dem Client entsprechend.
\end{itemize}

\subsection{Singleton in UserViewModel}
Benutzer Daten werden im UserViewModel gespeichert. Also ist es sinnvoll ein Singleton Muster da zu implementieren, da es nur ein User per Session gibt. Andere Klassen können dann die UserId kriegen und man ist sicher, dass UserId eindeutig ist.

\textbf{beteiligte Klasse}
\begin{itemize}
\item \textit{UserViewModel} \\
Singleton.
\end{itemize}

\newpage

\section{Klassenübersicht - Client}
\subsection*{Klassen}
{\raggedright
\hspace{0.0cm} $\bullet$ java.lang.Object {\tiny \refdefined{java.lang.Object}} \\
\hspace{1.0cm} $\bullet$  {\tiny } \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.view.recyclerView.ListAdapter {\tiny \refdefined{edu.kit.pse17.go_app.view.recyclerView.ListAdapter}} \\
\hspace{1.0cm} $\bullet$ AppCompatActivity {\tiny } \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.login.SignInHelper {\tiny \refdefined{edu.kit.pse17.go_app.login.SignInHelper}} \\
\hspace{3.0cm} $\bullet$ edu.kit.pse17.go\_app.login.FirebaseSignInHelper {\tiny \refdefined{edu.kit.pse17.go_app.login.FirebaseSignInHelper}} \\
\hspace{3.0cm} $\bullet$ edu.kit.pse17.go\_app.login.GoSignInHelper {\tiny \refdefined{edu.kit.pse17.go_app.login.GoSignInHelper}} \\
\hspace{1.0cm} $\bullet$ FirebaseInstanceIdService {\tiny } \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.serverCommunication.downstream.TokenService {\tiny \refdefined{edu.kit.pse17.go_app.serverCommunication.downstream.TokenService}} \\
\hspace{1.0cm} $\bullet$ FirebaseMessagingService {\tiny } \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.serverCommunication.downstream.MessageReceiver {\tiny \refdefined{edu.kit.pse17.go_app.serverCommunication.downstream.MessageReceiver}} \\
\hspace{1.0cm} $\bullet$ LifecycleActivity {\tiny } \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.view.BaseActivity {\tiny \refdefined{edu.kit.pse17.go_app.view.BaseActivity}} \\
\hspace{3.0cm} $\bullet$ edu.kit.pse17.go\_app.view.GoDetailActivity {\tiny \refdefined{edu.kit.pse17.go_app.view.GoDetailActivity}} \\
\hspace{4.0cm} $\bullet$ edu.kit.pse17.go\_app.view.GoDetailActivityOwner {\tiny \refdefined{edu.kit.pse17.go_app.view.GoDetailActivityOwner}} \\
\hspace{3.0cm} $\bullet$ edu.kit.pse17.go\_app.view.GroupDetailActivity {\tiny \refdefined{edu.kit.pse17.go_app.view.GroupDetailActivity}} \\
\hspace{4.0cm} $\bullet$ edu.kit.pse17.go\_app.view.GroupDetailActivityOwner {\tiny \refdefined{edu.kit.pse17.go_app.view.GroupDetailActivityOwner}} \\
\hspace{3.0cm} $\bullet$ edu.kit.pse17.go\_app.view.GroupListActivity {\tiny \refdefined{edu.kit.pse17.go_app.view.GroupListActivity}} \\
\hspace{3.0cm} $\bullet$ edu.kit.pse17.go\_app.view.InformationActivity {\tiny \refdefined{edu.kit.pse17.go_app.view.InformationActivity}} \\
\hspace{3.0cm} $\bullet$ edu.kit.pse17.go\_app.view.SettingsActivity {\tiny \refdefined{edu.kit.pse17.go_app.view.SettingsActivity}} \\
\hspace{3.0cm} $\bullet$ edu.kit.pse17.go\_app.view.SignInActivity {\tiny \refdefined{edu.kit.pse17.go_app.view.SignInActivity}} \\
\hspace{1.0cm} $\bullet$ ViewHolder {\tiny } \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.view.recyclerView.ListViewHolder {\tiny \refdefined{edu.kit.pse17.go_app.view.recyclerView.ListViewHolder}} \\
\hspace{1.0cm} $\bullet$ ViewModel {\tiny } \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.viewModel.GoViewModel {\tiny \refdefined{edu.kit.pse17.go_app.viewModel.GoViewModel}} \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.viewModel.GroupListViewModel {\tiny \refdefined{edu.kit.pse17.go_app.viewModel.GroupListViewModel}} \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.viewModel.GroupViewModel {\tiny \refdefined{edu.kit.pse17.go_app.viewModel.GroupViewModel}} \\
\hspace{1.0cm} $\bullet$ edu.kit.pse17.go\_app.ServerCommand {\tiny \refdefined{edu.kit.pse17.go_app.ServerCommand}} \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.AdminAddedCommand {\tiny \refdefined{edu.kit.pse17.go_app.AdminAddedCommand}} \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.GoAddedCommand {\tiny \refdefined{edu.kit.pse17.go_app.GoAddedCommand}} \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.GoEditedCommand {\tiny \refdefined{edu.kit.pse17.go_app.GoEditedCommand}} \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.GoRemovedCommand {\tiny \refdefined{edu.kit.pse17.go_app.GoRemovedCommand}} \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.GroupEditedCommand {\tiny \refdefined{edu.kit.pse17.go_app.GroupEditedCommand}} \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.GroupRemovedCommand {\tiny \refdefined{edu.kit.pse17.go_app.GroupRemovedCommand}} \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.GroupRequestReceivedCommand {\tiny \refdefined{edu.kit.pse17.go_app.GroupRequestReceivedCommand}} \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.MemberAddedCommand {\tiny \refdefined{edu.kit.pse17.go_app.MemberAddedCommand}} \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.MemberRemovedCommand {\tiny \refdefined{edu.kit.pse17.go_app.MemberRemovedCommand}} \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.RequestDeniedCommand {\tiny \refdefined{edu.kit.pse17.go_app.RequestDeniedCommand}} \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.StatusChangedCommand {\tiny \refdefined{edu.kit.pse17.go_app.StatusChangedCommand}} \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.UserDeletedCommand {\tiny \refdefined{edu.kit.pse17.go_app.UserDeletedCommand}} \\
\hspace{1.0cm} $\bullet$ edu.kit.pse17.go\_app.model.entities.Cluster {\tiny \refdefined{edu.kit.pse17.go_app.model.entities.Cluster}} \\
\hspace{1.0cm} $\bullet$ edu.kit.pse17.go\_app.model.entities.Go {\tiny \refdefined{edu.kit.pse17.go_app.model.entities.Go}} \\
\hspace{1.0cm} $\bullet$ edu.kit.pse17.go\_app.model.entities.Group {\tiny \refdefined{edu.kit.pse17.go_app.model.entities.Group}} \\
\hspace{1.0cm} $\bullet$ edu.kit.pse17.go\_app.model.entities.GroupMembership {\tiny \refdefined{edu.kit.pse17.go_app.model.entities.GroupMembership}} \\
\hspace{1.0cm} $\bullet$ edu.kit.pse17.go\_app.model.entities.User {\tiny \refdefined{edu.kit.pse17.go_app.model.entities.User}} \\
\hspace{1.0cm} $\bullet$ edu.kit.pse17.go\_app.model.entities.UserGoStatus {\tiny \refdefined{edu.kit.pse17.go_app.model.entities.UserGoStatus}} \\
\hspace{1.0cm} $\bullet$ edu.kit.pse17.go\_app.repositories.Repository {\tiny \refdefined{edu.kit.pse17.go_app.repositories.Repository}} \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.repositories.GoRepository {\tiny \refdefined{edu.kit.pse17.go_app.repositories.GoRepository}} \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.repositories.GroupRepository {\tiny \refdefined{edu.kit.pse17.go_app.repositories.GroupRepository}} \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.repositories.UserRepository {\tiny \refdefined{edu.kit.pse17.go_app.repositories.UserRepository}} \\
\hspace{1.0cm} $\bullet$ edu.kit.pse17.go\_app.view.EditGoActivity {\tiny \refdefined{edu.kit.pse17.go_app.view.EditGoActivity}} \\
\hspace{1.0cm} $\bullet$ edu.kit.pse17.go\_app.view.EditGroupActivity {\tiny \refdefined{edu.kit.pse17.go_app.view.EditGroupActivity}} \\
\hspace{1.0cm} $\bullet$ edu.kit.pse17.go\_app.view.recyclerView.listItems.GOListItem {\tiny \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.GOListItem}} \\
\hspace{1.0cm} $\bullet$ edu.kit.pse17.go\_app.view.recyclerView.listItems.GroupListItem {\tiny \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.GroupListItem}} \\
\hspace{1.0cm} $\bullet$ edu.kit.pse17.go\_app.view.recyclerView.listItems.UserMailListItem {\tiny \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.UserMailListItem}} \\
\hspace{1.0cm} $\bullet$ edu.kit.pse17.go\_app.view.recyclerView.listItems.UserStatusListItem {\tiny \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.UserStatusListItem}} \\
\hspace{1.0cm} $\bullet$ edu.kit.pse17.go\_app.viewModel.UserViewModel {\tiny \refdefined{edu.kit.pse17.go_app.viewModel.UserViewModel}} \\
\hspace{1.0cm} $\bullet$ java.lang.Enum {\tiny \refdefined{java.lang.Enum}} \\
\hspace{2.0cm} $\bullet$ edu.kit.pse17.go\_app.model.Status {\tiny \refdefined{edu.kit.pse17.go_app.model.Status}} \\
}
\subsection*{Interfaces}
\hspace{0.0cm} $\bullet$ edu.kit.pse17.go\_app.serverCommunication.upstream.TomcatRestApi {\tiny \refdefined{edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi}} \\
\hspace{0.0cm} $\bullet$ edu.kit.pse17.go\_app.view.recyclerView.OnListItemClicked {\tiny \refdefined{edu.kit.pse17.go_app.view.recyclerView.OnListItemClicked}} \\
\hspace{0.0cm} $\bullet$ edu.kit.pse17.go\_app.view.recyclerView.listItems.ListItem {\tiny \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}} \\


\section{Package ServerCommands}{
\label{edu.kit.pse17.go_app}\hypertarget{edu.kit.pse17.go_app}{}
\subsection{\label{edu.kit.pse17.go_app.AdminAddedCommand}Klasse AdminAddedCommand}{
\hypertarget{edu.kit.pse17.go_app.AdminAddedCommand}{}\vskip .1in 
Diese Klasse implementiert einen Befehl, der bei der Erteilung von Admin-Rechten zu einem Mitglied der Gruppe vom Admin dieser Gruppe ausgefuehrt wird.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class AdminAddedCommand
 extends edu.kit.pse17.go_app.ServerCommand\end{lstlisting}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{AdminAddedCommand()}
\hypertarget{edu.kit.pse17.go_app.AdminAddedCommand()}{{\bf  AdminAddedCommand}\\}
\begin{lstlisting}[frame=none]
public AdminAddedCommand()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onCommandReceived()}
\hypertarget{edu.kit.pse17.go_app.AdminAddedCommand.onCommandReceived()}{{\bf  onCommandReceived}\\}
\begin{lstlisting}[frame=none]
public void onCommandReceived()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode aendert folgende Daten in Repositorien der App: -Alle Mitglieder der Gruppe werden ueber den neuen Admin benachrichtigt.
}
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Von ServerCommand vererbte Methoden }{
\texttt{edu.kit.pse17.go\_app.ServerCommand} {\small 
\refdefined{edu.kit.pse17.go_app.ServerCommand}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public abstract void {\bf  onCommandReceived}()
}%end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.GoAddedCommand}Klasse GoAddedCommand}{
\hypertarget{edu.kit.pse17.go_app.GoAddedCommand}{}\vskip .1in 
Diese Klasse implementiert einen Befehl, der bei dem Erstellen eines neuen GOs der Gruppe ausgefuehrt wird.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GoAddedCommand
 extends edu.kit.pse17.go_app.ServerCommand\end{lstlisting}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GoAddedCommand()}
\hypertarget{edu.kit.pse17.go_app.GoAddedCommand()}{{\bf  GoAddedCommand}\\}
\begin{lstlisting}[frame=none]
public GoAddedCommand()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onCommandReceived()}
\hypertarget{edu.kit.pse17.go_app.GoAddedCommand.onCommandReceived()}{{\bf  onCommandReceived}\\}
\begin{lstlisting}[frame=none]
public void onCommandReceived()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode aendert folgende Daten in Repositorien der App: -Alle Mitglieder der Gruppe werden ueber das neue GO benachrichtigt.
}
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Von ServerCommand vererbte Methoden }{
\texttt{edu.kit.pse17.go\_app.ServerCommand} {\small 
\refdefined{edu.kit.pse17.go_app.ServerCommand}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public abstract void {\bf  onCommandReceived}()
}%end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.GoEditedCommand}Klasse GoEditedCommand}{
\hypertarget{edu.kit.pse17.go_app.GoEditedCommand}{}\vskip .1in 
Diese Klasse implementiert einen Befehl, der bei der Veraenderung der Daten eines GOs ausgefuehrt wird.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GoEditedCommand
 extends edu.kit.pse17.go_app.ServerCommand\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GoEditedCommand()}
\hypertarget{edu.kit.pse17.go_app.GoEditedCommand()}{{\bf  GoEditedCommand}\\}
\begin{lstlisting}[frame=none]
public GoEditedCommand()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onCommandReceived()}
\hypertarget{edu.kit.pse17.go_app.GoEditedCommand.onCommandReceived()}{{\bf  onCommandReceived}\\}
\begin{lstlisting}[frame=none]
public void onCommandReceived()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode aendert folgende Daten in Repositorien der App: -Alle Mitglieder der Gruppe werden ueber die neuen Daten des GOs benachrichtigt.
}
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Von ServerCommand vererbte Methoden }{
\texttt{edu.kit.pse17.go\_app.ServerCommand} {\small 
\refdefined{edu.kit.pse17.go_app.ServerCommand}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public abstract void {\bf  onCommandReceived}()
}%end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.GoRemovedCommand}Klasse GoRemovedCommand}{
\hypertarget{edu.kit.pse17.go_app.GoRemovedCommand}{}\vskip .1in 
Diese Klasse implementiert einen Befehl, der bei dem Loeschen eines GOs der Gruppe ausgefuehrt wird.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GoRemovedCommand
 extends edu.kit.pse17.go_app.ServerCommand\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GoRemovedCommand()}
\hypertarget{edu.kit.pse17.go_app.GoRemovedCommand()}{{\bf  GoRemovedCommand}\\}
\begin{lstlisting}[frame=none]
public GoRemovedCommand()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onCommandReceived()}
\hypertarget{edu.kit.pse17.go_app.GoRemovedCommand.onCommandReceived()}{{\bf  onCommandReceived}\\}
\begin{lstlisting}[frame=none]
public void onCommandReceived()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode aendert folgende Daten in Repositorien der App: -Alle Mitglieder der Gruppe werden benachrichtigt, dass das GO nicht mehr existiert.
}
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Von ServerCommand vererbte Methoden }{
\texttt{edu.kit.pse17.go\_app.ServerCommand} {\small 
\refdefined{edu.kit.pse17.go_app.ServerCommand}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public abstract void {\bf  onCommandReceived}()
}%end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.GroupEditedCommand}Klasse GroupEditedCommand}{
\hypertarget{edu.kit.pse17.go_app.GroupEditedCommand}{}\vskip .1in 
Diese Klasse implementiert einen Befehl, der bei der Veraenderung der Daten einer Gruppe ausgefuehrt wird.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GroupEditedCommand
 extends edu.kit.pse17.go_app.ServerCommand\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GroupEditedCommand()}
\hypertarget{edu.kit.pse17.go_app.GroupEditedCommand()}{{\bf  GroupEditedCommand}\\}
\begin{lstlisting}[frame=none]
public GroupEditedCommand()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onCommandReceived()}
\hypertarget{edu.kit.pse17.go_app.GroupEditedCommand.onCommandReceived()}{{\bf  onCommandReceived}\\}
\begin{lstlisting}[frame=none]
public void onCommandReceived()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode aendert folgende Daten in Repositorien der App: -Alle Mitglieder der Gruppe werden ueber die neuen Daten benachrichtigt.
}
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Von ServerCommand vererbte Methoden}{
\texttt{edu.kit.pse17.go\_app.ServerCommand} {\small 
\refdefined{edu.kit.pse17.go_app.ServerCommand}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public abstract void {\bf  onCommandReceived}()
}%end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.GroupRemovedCommand}Klasse GroupRemovedCommand}{
\hypertarget{edu.kit.pse17.go_app.GroupRemovedCommand}{}\vskip .1in 
Diese Klasse implementiert einen Befehl, der bei dem Loeschen einer Gruppe ausgefuehrt wird.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GroupRemovedCommand
 extends edu.kit.pse17.go_app.ServerCommand\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GroupRemovedCommand()}
\hypertarget{edu.kit.pse17.go_app.GroupRemovedCommand()}{{\bf  GroupRemovedCommand}\\}
\begin{lstlisting}[frame=none]
public GroupRemovedCommand()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onCommandReceived()}
\hypertarget{edu.kit.pse17.go_app.GroupRemovedCommand.onCommandReceived()}{{\bf  onCommandReceived}\\}
\begin{lstlisting}[frame=none]
public void onCommandReceived()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode aendert folgende Daten in Repositorien der App: -Alle Mitglieder der Gruppe werden benachrichtigt, dass die Gruppe nicht mehr existiert; -Alle GOs der Gruppe werden geloescht; -Die Gruppe selbst (und alle Daten) werden geloescht.
}
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Von ServerCommand vererbte Methoden}{
\texttt{edu.kit.pse17.go\_app.ServerCommand} {\small 
\refdefined{edu.kit.pse17.go_app.ServerCommand}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public abstract void {\bf  onCommandReceived}()
}%end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.GroupRequestReceivedCommand}Klasse GroupRequestReceivedCommand}{
\hypertarget{edu.kit.pse17.go_app.GroupRequestReceivedCommand}{}\vskip .1in 
Diese Klasse implementiert einen Befehl, der bei dem Senden einer Gruppenanfrage vom Admin der Gruppe zu einem Benutzer ausgefuehrt wird.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GroupRequestReceivedCommand
 extends edu.kit.pse17.go_app.ServerCommand\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GroupRequestReceivedCommand()}
\hypertarget{edu.kit.pse17.go_app.GroupRequestReceivedCommand()}{{\bf  GroupRequestReceivedCommand}\\}
\begin{lstlisting}[frame=none]
public GroupRequestReceivedCommand()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onCommandReceived()}
\hypertarget{edu.kit.pse17.go_app.GroupRequestReceivedCommand.onCommandReceived()}{{\bf  onCommandReceived}\\}
\begin{lstlisting}[frame=none]
public void onCommandReceived()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode aendert folgende Daten in Repositorien der App: -Dem ausgewaehlten Benutzer wird eine Gruppenanfrage gesendet, die in der App des Benutzers gezeigt wird.
}
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Von ServerCommand vererbte Methoden}{
\texttt{edu.kit.pse17.go\_app.ServerCommand} {\small 
\refdefined{edu.kit.pse17.go_app.ServerCommand}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public abstract void {\bf  onCommandReceived}()
}%end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.MemberAddedCommand}klasse MemberAddedCommand}{
\hypertarget{edu.kit.pse17.go_app.MemberAddedCommand}{}\vskip .1in 
Diese Klasse implementiert einen Befehl, der bei dem Beitreten einer Gruppe vom Benutzer ausgefuehrt wird. D.h. der Benutzer hat die Gruppenanfrage bestaetigt.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class MemberAddedCommand
 extends edu.kit.pse17.go_app.ServerCommand\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{MemberAddedCommand()}
\hypertarget{edu.kit.pse17.go_app.MemberAddedCommand()}{{\bf  MemberAddedCommand}\\}
\begin{lstlisting}[frame=none]
public MemberAddedCommand()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onCommandReceived()}
\hypertarget{edu.kit.pse17.go_app.MemberAddedCommand.onCommandReceived()}{{\bf  onCommandReceived}\\}
\begin{lstlisting}[frame=none]
public void onCommandReceived()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode aendert folgende Daten in Repositorien der App: -Dem ausgewaehlten Benutzer werden alle Daten der Gruppe gesendet; -Alle Mitglieder der Gruppe werden ueber den neuen Benutzer benachrichtigt.
}
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Von ServerCommand vererbte Methoden}{
\texttt{edu.kit.pse17.go\_app.ServerCommand} {\small 
\refdefined{edu.kit.pse17.go_app.ServerCommand}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public abstract void {\bf  onCommandReceived}()
}%end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.MemberRemovedCommand}Klasse MemberRemovedCommand}{
\hypertarget{edu.kit.pse17.go_app.MemberRemovedCommand}{}\vskip .1in 
Diese Klasse implementiert einen Befehl, der bei dem Austreten (oder Loeschen) eines Mitglieds aus der Gruppe ausgefuehrt wird.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class MemberRemovedCommand
 extends edu.kit.pse17.go_app.ServerCommand\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{MemberRemovedCommand()}
\hypertarget{edu.kit.pse17.go_app.MemberRemovedCommand()}{{\bf  MemberRemovedCommand}\\}
\begin{lstlisting}[frame=none]
public MemberRemovedCommand()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onCommandReceived()}
\hypertarget{edu.kit.pse17.go_app.MemberRemovedCommand.onCommandReceived()}{{\bf  onCommandReceived}\\}
\begin{lstlisting}[frame=none]
public void onCommandReceived()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode aendert folgende Daten in Repositorien der App: -Alle Mitglieder der Gruppe werden benachrichtigt, dass ein Mitglied aus der Gruppe ausgetreten (oder geloescht) ist; -Alle GOs, bei denen der Benutzer GO-Verantwortlicher war, werden geloescht; -Wenn die Gruppe nur einen einzigen Mitglied hatte, wird diese Gruppe geloescht.
}
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Von ServerCommand vererbte Methoden}{
\texttt{edu.kit.pse17.go\_app.ServerCommand} {\small 
\refdefined{edu.kit.pse17.go_app.ServerCommand}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public abstract void {\bf  onCommandReceived}()
}%end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.RequestDeniedCommand}Klasse RequestDeniedCommand}{
\hypertarget{edu.kit.pse17.go_app.RequestDeniedCommand}{}\vskip .1in 
Diese Klasse implementiert einen Befehl, der bei dem Ablehnen einer Gruppenanfrage vom Benutzer ausgefuehrt wird. D.h. der Benutzer hat die Gruppenanfrage abgelehnt.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class RequestDeniedCommand
 extends edu.kit.pse17.go_app.ServerCommand\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{RequestDeniedCommand()}
\hypertarget{edu.kit.pse17.go_app.RequestDeniedCommand()}{{\bf  RequestDeniedCommand}\\}
\begin{lstlisting}[frame=none]
public RequestDeniedCommand()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onCommandReceived()}
\hypertarget{edu.kit.pse17.go_app.RequestDeniedCommand.onCommandReceived()}{{\bf  onCommandReceived}\\}
\begin{lstlisting}[frame=none]
public void onCommandReceived()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode aendert folgende Daten in Repositorien der App: -Alle Administratoren der Gruppe werden benachrichtigt (d.h., diese eroeffnete Gruppenanfrage wird geloescht).
}
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Von ServerCommand vererbte Methoden}{
\texttt{edu.kit.pse17.go\_app.ServerCommand} {\small 
\refdefined{edu.kit.pse17.go_app.ServerCommand}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public abstract void {\bf  onCommandReceived}()
}%end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.ServerCommand}Klasse ServerCommand}{
\hypertarget{edu.kit.pse17.go_app.ServerCommand}{}\vskip .1in 
Die abstrakte Klasse ist eine allgemeine Klasse fuer Befehle, die bei Ankunft einer Nachricht vom Server ausgefuehrt werden. Diese Befehle aendern die Daten in den Repositorien, sodass die App diese spaeter holen kann.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public abstract class ServerCommand
 extends java.lang.Object\end{lstlisting}
\subsubsection{All known subclasses}{AdminAddedCommand\small{\refdefined{edu.kit.pse17.go_app.AdminAddedCommand}}, GoAddedCommand\small{\refdefined{edu.kit.pse17.go_app.GoAddedCommand}}, GoRemovedCommand\small{\refdefined{edu.kit.pse17.go_app.GoRemovedCommand}}, StatusChangedCommand\small{\refdefined{edu.kit.pse17.go_app.StatusChangedCommand}}, RequestDeniedCommand\small{\refdefined{edu.kit.pse17.go_app.RequestDeniedCommand}}, MemberRemovedCommand\small{\refdefined{edu.kit.pse17.go_app.MemberRemovedCommand}}, GroupRemovedCommand\small{\refdefined{edu.kit.pse17.go_app.GroupRemovedCommand}}, GoEditedCommand\small{\refdefined{edu.kit.pse17.go_app.GoEditedCommand}}, GroupRequestReceivedCommand\small{\refdefined{edu.kit.pse17.go_app.GroupRequestReceivedCommand}}, UserDeletedCommand\small{\refdefined{edu.kit.pse17.go_app.UserDeletedCommand}}, MemberAddedCommand\small{\refdefined{edu.kit.pse17.go_app.MemberAddedCommand}}, GroupEditedCommand\small{\refdefined{edu.kit.pse17.go_app.GroupEditedCommand}}}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{ServerCommand()}
\hypertarget{edu.kit.pse17.go_app.ServerCommand()}{{\bf  ServerCommand}\\}
\begin{lstlisting}[frame=none]
public ServerCommand()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onCommandReceived()}
\hypertarget{edu.kit.pse17.go_app.ServerCommand.onCommandReceived()}{{\bf  onCommandReceived}\\}
\begin{lstlisting}[frame=none]
public abstract void onCommandReceived()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode implementiert Befehle, die die neuen Daten im Repositorium ablegen. Wird von der Methode onMessageReceived() der Klasse MessageReceiver aufgerufen, sobald die App eine Nachricht des Tomcat-Servers erhaelt und in einen Befehl dekodiert.
}
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.StatusChangedCommand}Klasse StatusChangedCommand}{
\hypertarget{edu.kit.pse17.go_app.StatusChangedCommand}{}\vskip .1in 
Diese Klasse implementiert einen Befehl, der bei der Veraenderung eines Status des Benutzers innerhalb eines GOs ausgefuehrt wird.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class StatusChangedCommand
 extends edu.kit.pse17.go_app.ServerCommand\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{StatusChangedCommand()}
\hypertarget{edu.kit.pse17.go_app.StatusChangedCommand()}{{\bf  StatusChangedCommand}\\}
\begin{lstlisting}[frame=none]
public StatusChangedCommand()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onCommandReceived()}
\hypertarget{edu.kit.pse17.go_app.StatusChangedCommand.onCommandReceived()}{{\bf  onCommandReceived}\\}
\begin{lstlisting}[frame=none]
public void onCommandReceived()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode aendert folgende Daten in Repositorien der App: -Alle Teilnehmer des GOs werden ueber dan neuen Status des Benutzers benachrichtigt.
}
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Von ServerCommand vererbte Methoden}{
\texttt{edu.kit.pse17.go\_app.ServerCommand} {\small 
\refdefined{edu.kit.pse17.go_app.ServerCommand}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public abstract void {\bf  onCommandReceived}()
}%end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.UserDeletedCommand}Klasse UserDeletedCommand}{
\hypertarget{edu.kit.pse17.go_app.UserDeletedCommand}{}\vskip .1in 
Diese Klasse implementiert einen Befehl, der bei dem Loeschen vom Account eines Benutzers ausgefuehrt wird.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class UserDeletedCommand
 extends edu.kit.pse17.go_app.ServerCommand\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{UserDeletedCommand()}
\hypertarget{edu.kit.pse17.go_app.UserDeletedCommand()}{{\bf  UserDeletedCommand}\\}
\begin{lstlisting}[frame=none]
public UserDeletedCommand()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onCommandReceived()}
\hypertarget{edu.kit.pse17.go_app.UserDeletedCommand.onCommandReceived()}{{\bf  onCommandReceived}\\}
\begin{lstlisting}[frame=none]
public void onCommandReceived()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode aendert folgende Daten in Repositorien der App: -Alle Mitglieder der Gruppen, bei denen der Benutzer Mitglied war, werden benachrichtigt, dass dieser Mitglied geloescht ist; -Alle Teilnehmer der GOs, bei denen der Benutzer Teilnehmer war, werden benachrichtigt, dass dieser Benutzer geloescht ist; -Alle GOs, bei denen der Benutzer GO-Verantwortlicher war, werden geloescht; -Wenn die Gruppe nur einen einzigen Mitglied hatte, wird diese Gruppe geloescht.
}
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Von ServerCommand vererbte Methoden}{
\texttt{edu.kit.pse17.go\_app.ServerCommand} {\small 
\refdefined{edu.kit.pse17.go_app.ServerCommand}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public abstract void {\bf  onCommandReceived}()
}%end signature
}%end item
\end{itemize}
}
}
}
\section{Package Login}{
\label{edu.kit.pse17.go_app.login}\hypertarget{edu.kit.pse17.go_app.login}{}
\hskip -.05in
\hbox to \hsize{\textit{ Package Contents\hfil Page}}
\vskip .13in
\subsection{\label{edu.kit.pse17.go_app.login.FirebaseSignInHelper}Klasse FirebaseSignInHelper}{
\hypertarget{edu.kit.pse17.go_app.login.FirebaseSignInHelper}{}\vskip .1in 
Diese Klasse ist fuer die Kommunikation mit Firebase und Google API waehrend des Login-Prozesses zustaendig. Sie implementiert die Methoden configureSignIn() und startSignInProcess() zur Schablonenmethode signIn() der Oberklasse SignInHelper.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class FirebaseSignInHelper
 extends edu.kit.pse17.go_app.login.SignInHelper\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{FirebaseSignInHelper()}
\hypertarget{edu.kit.pse17.go_app.login.FirebaseSignInHelper()}{{\bf  FirebaseSignInHelper}\\}
\begin{lstlisting}[frame=none]
public FirebaseSignInHelper()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{configureSignIn()}
\hypertarget{edu.kit.pse17.go_app.login.FirebaseSignInHelper.configureSignIn()}{{\bf  configureSignIn}\\}
\begin{lstlisting}[frame=none]
protected void configureSignIn()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Implementierung gehoert zur Schablonenmethode signIn()
}
\end{itemize}
}%end item
\item{ 
\index{onActivityResult(int, int, Intent)}
\hypertarget{edu.kit.pse17.go_app.login.FirebaseSignInHelper.onActivityResult(int, int, Intent)}{{\bf  onActivityResult}\\}
\begin{lstlisting}[frame=none]
protected void onActivityResult(int requestCode,int resultCode,Intent data)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Methode erwartet das Resultat der signInAktivitaet der GoogleSignInApi. War die Aktivitaet erfolgreich, wird die Authentifizierung mit Firebase gestartet.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{requestCode} -- Request Code, mit dem Aktivitaet gestartet wurde}
   \item{
\texttt{resultCode} -- Result Code der Aktivitaet}
   \item{
\texttt{data} -- Intent, den die Aktivitaet uebergibt}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{onConnectionFailed(ConnectionResult)}
\hypertarget{edu.kit.pse17.go_app.login.FirebaseSignInHelper.onConnectionFailed(ConnectionResult)}{{\bf  onConnectionFailed}\\}
\begin{lstlisting}[frame=none]
public void onConnectionFailed(ConnectionResult connectionResult)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode wird aufgerufen, falls Verbindung zu Google Play Services fehlschlaegt
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{connectionResult} -- Ergebnis der fehlgeschlagenen Verbindung}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{signOut()}
\hypertarget{edu.kit.pse17.go_app.login.FirebaseSignInHelper.signOut()}{{\bf  signOut}\\}
\begin{lstlisting}[frame=none]
public void signOut()\end{lstlisting} %end signature
}%end item
\item{ 
\index{startSignInProcess()}
\hypertarget{edu.kit.pse17.go_app.login.FirebaseSignInHelper.startSignInProcess()}{{\bf  startSignInProcess}\\}
\begin{lstlisting}[frame=none]
protected void startSignInProcess()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Implementierung gehoert zur Schablonenmethode signIn() Die Methode startet die signIn Aktivitaet der GoogleSignInApi
}
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Von SignInHelper vererbte Methoden}{
\texttt{edu.kit.pse17.go\_app.login.SignInHelper} {\small 
\refdefined{edu.kit.pse17.go_app.login.SignInHelper}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public static final {\bf  ACCOUNT\_DATA\_CODE}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{protected abstract void {\bf  configureSignIn}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{protected void {\bf  onCreate}(\texttt{Bundle} {\bf  savedInstanceState})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{protected void {\bf  onStart}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{protected void {\bf  returnActivityResult}(\texttt{java.io.Serializable} {\bf  accountData})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public static final {\bf  SIGN\_IN\_DATA\_CODE}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public static void {\bf  signIn}(\texttt{Activity} {\bf  activity},
\texttt{int} {\bf  requestCode},
\texttt{java.io.Serializable} {\bf  signInData},
\texttt{java.lang.Class} {\bf  signinHelper})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{protected abstract void {\bf  startSignInProcess}()
}%end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.login.GoSignInHelper}Klasse GoSignInHelper}{
\hypertarget{edu.kit.pse17.go_app.login.GoSignInHelper}{}\vskip .1in 
Die Klasse ist fuer die Anmeldung eines Beutzers am Go-Server zustaendig. Sie implemetiert die Methoden configureSignIn() und startSignInProcess() zur Schablonenmethode signIn() der Oberklasse SignInHelper.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GoSignInHelper
 extends edu.kit.pse17.go_app.login.SignInHelper\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GoSignInHelper()}
\hypertarget{edu.kit.pse17.go_app.login.GoSignInHelper()}{{\bf  GoSignInHelper}\\}
\begin{lstlisting}[frame=none]
public GoSignInHelper()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{configureSignIn()}
\hypertarget{edu.kit.pse17.go_app.login.GoSignInHelper.configureSignIn()}{{\bf  configureSignIn}\\}
\begin{lstlisting}[frame=none]
protected abstract void configureSignIn()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.login.SignInHelper}{SignInHelper}{\small \refdefined{edu.kit.pse17.go_app.login.SignInHelper}} }

Diese Methode wird von Unterklassen implementiert und in Schablonenmethode aufgerufen
}
\end{itemize}
}%end item
\item{ 
\index{startSignInProcess()}
\hypertarget{edu.kit.pse17.go_app.login.GoSignInHelper.startSignInProcess()}{{\bf  startSignInProcess}\\}
\begin{lstlisting}[frame=none]
protected abstract void startSignInProcess()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.login.SignInHelper}{SignInHelper}{\small \refdefined{edu.kit.pse17.go_app.login.SignInHelper}} }

Diese Methode wird von Unterklassen implementiert und in Schablonenmethode aufgerufen
}
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Von SignInHelper vererbte Methoden}{
\texttt{edu.kit.pse17.go\_app.login.SignInHelper} {\small 
\refdefined{edu.kit.pse17.go_app.login.SignInHelper}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public static final {\bf  ACCOUNT\_DATA\_CODE}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{protected abstract void {\bf  configureSignIn}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{protected void {\bf  onCreate}(\texttt{Bundle} {\bf  savedInstanceState})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{protected void {\bf  onStart}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{protected void {\bf  returnActivityResult}(\texttt{java.io.Serializable} {\bf  accountData})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public static final {\bf  SIGN\_IN\_DATA\_CODE}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public static void {\bf  signIn}(\texttt{Activity} {\bf  activity},
\texttt{int} {\bf  requestCode},
\texttt{java.io.Serializable} {\bf  signInData},
\texttt{java.lang.Class} {\bf  signinHelper})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{protected abstract void {\bf  startSignInProcess}()
}%end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.login.SignInHelper}Klasse SignInHelper}{
\hypertarget{edu.kit.pse17.go_app.login.SignInHelper}{}\vskip .1in 
Abstrakte Klasse, die als Schablone fuer den Anmelde-Prozess ihrer Unterklassen dient.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public abstract class SignInHelper
 extends AppCompatActivity\end{lstlisting}
\subsubsection{All known subclasses}{GoSignInHelper\small{\refdefined{edu.kit.pse17.go_app.login.GoSignInHelper}}, FirebaseSignInHelper\small{\refdefined{edu.kit.pse17.go_app.login.FirebaseSignInHelper}}}

\subsubsection{statische Felder}{
\begin{itemize}
\item{
\index{SIGN\_IN\_DATA\_CODE}
\label{edu.kit.pse17.go_app.login.SignInHelper.SIGN_IN_DATA_CODE}\hypertarget{edu.kit.pse17.go_app.login.SignInHelper.SIGN_IN_DATA_CODE}{\texttt{public static final java.lang.String\ {\bf  SIGN\_IN\_DATA\_CODE}}
}
\begin{itemize}
\item{\vskip -.9ex 
Name des Intent-Extra, das Anmeldedaten an die SignIn-Aktivitaet uebergibt}
\end{itemize}
}
\item{
\index{ACCOUNT\_DATA\_CODE}
\label{edu.kit.pse17.go_app.login.SignInHelper.ACCOUNT_DATA_CODE}\hypertarget{edu.kit.pse17.go_app.login.SignInHelper.ACCOUNT_DATA_CODE}{\texttt{public static final java.lang.String\ {\bf  ACCOUNT\_DATA\_CODE}}
}
\begin{itemize}
\item{\vskip -.9ex 
Name des Intent-Extra, das als Ergebnis der Anmelde-Aktivitaet zurueckgegeben wird}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{SignInHelper()}
\hypertarget{edu.kit.pse17.go_app.login.SignInHelper()}{{\bf  SignInHelper}\\}
\begin{lstlisting}[frame=none]
public SignInHelper()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{configureSignIn()}
\hypertarget{edu.kit.pse17.go_app.login.SignInHelper.configureSignIn()}{{\bf  configureSignIn}\\}
\begin{lstlisting}[frame=none]
protected abstract void configureSignIn()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode wird von Unterklassen implementiert und in Schablonenmethode aufgerufen
}
\end{itemize}
}%end item
\item{ 
\index{onCreate(Bundle)}
\hypertarget{edu.kit.pse17.go_app.login.SignInHelper.onCreate(Bundle)}{{\bf  onCreate}\\}
\begin{lstlisting}[frame=none]
protected void onCreate(Bundle savedInstanceState)\end{lstlisting} %end signature
}%end item
\item{ 
\index{onStart()}
\hypertarget{edu.kit.pse17.go_app.login.SignInHelper.onStart()}{{\bf  onStart}\\}
\begin{lstlisting}[frame=none]
protected void onStart()\end{lstlisting} %end signature
}%end item
\item{ 
\index{returnActivityResult(Serializable)}
\hypertarget{edu.kit.pse17.go_app.login.SignInHelper.returnActivityResult(java.io.Serializable)}{{\bf  returnActivityResult}\\}
\begin{lstlisting}[frame=none]
protected void returnActivityResult(java.io.Serializable accountData)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode gibt das Ergebnis der Anmelde-Aktivitaet an das aufrufende Objekt zurueck
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{accountData} -- Ergebnis der Anmelde-Aktivitaet}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{signIn(Activity, int, Serializable, Class)}
\hypertarget{edu.kit.pse17.go_app.login.SignInHelper.signIn(Activity, int, java.io.Serializable, java.lang.Class)}{{\bf  signIn}\\}
\begin{lstlisting}[frame=none]
public static void signIn(Activity activity,int requestCode,java.io.Serializable signInData,java.lang.Class signinHelper)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Schablonenmethode fuer den Anmelde-Prozess der konkreten SignInHelper
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{activity} -- Aktivity, die die anmeldung aufruft}
   \item{
\texttt{requestCode} -- Request-Code des Aktivitaets-Aufrufs}
   \item{
\texttt{signInData} -- AnmeldeDaten die ggfs an Anmelde-Aktivitaet uebergeben werden muessen}
   \item{
\texttt{signinHelper} -- Referenz auf die Unterklasse, die Methode ausfuehrt}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{startSignInProcess()}
\hypertarget{edu.kit.pse17.go_app.login.SignInHelper.startSignInProcess()}{{\bf  startSignInProcess}\\}
\begin{lstlisting}[frame=none]
protected abstract void startSignInProcess()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode wird von Unterklassen implementiert und in Schablonenmethode aufgerufen
}
\end{itemize}
}%end item
\end{itemize}
}
}
}
\section{Package ViewModel}{
\label{edu.kit.pse17.go_app.viewModel}\hypertarget{edu.kit.pse17.go_app.viewModel}{}
\hskip -.05in
\hbox to \hsize{\textit{ Package Contents\hfil Page}}
\vskip .13in

\subsection{\label{edu.kit.pse17.go_app.viewModel.GoViewModel}Klasse GoViewModel}{
\hypertarget{edu.kit.pse17.go_app.viewModel.GoViewModel}{}\vskip .1in 
Die ViewModel Klasse, die alle Daten fuer ein GO beinhaltet, und die Bearbeitungsaufrufe von Activities auf den Daten ausfuehrt.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GoViewModel
 extends ViewModel\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GoViewModel()}
\hypertarget{edu.kit.pse17.go_app.viewModel.GoViewModel()}{{\bf  GoViewModel}\\}
\begin{lstlisting}[frame=none]
public GoViewModel()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{changeStatus(String, String, Status)}
\hypertarget{edu.kit.pse17.go_app.viewModel.GoViewModel.changeStatus(java.lang.String, java.lang.String, edu.kit.pse17.go_app.model.Status)}{{\bf  changeStatus}\\}
\begin{lstlisting}[frame=none]
public void changeStatus(java.lang.String userId,java.lang.String goId,edu.kit.pse17.go_app.model.Status status)\end{lstlisting} %end signature
}%end item
\item{ 
\index{editGo(String, Go)}
\hypertarget{edu.kit.pse17.go_app.viewModel.GoViewModel.editGo(java.lang.String, edu.kit.pse17.go_app.model.entities.Go)}{{\bf  editGo}\\}
\begin{lstlisting}[frame=none]
public void editGo(java.lang.String goid,edu.kit.pse17.go_app.model.entities.Go go)\end{lstlisting} %end signature
}%end item
\item{ 
\index{getCluster(String, String, Location)}
\hypertarget{edu.kit.pse17.go_app.viewModel.GoViewModel.getCluster(java.lang.String, java.lang.String, Location)}{{\bf  getCluster}\\}
\begin{lstlisting}[frame=none]
public <any> getCluster(java.lang.String userId,java.lang.String groupId,Location location)\end{lstlisting} %end signature
}%end item
\item{ 
\index{init()}
\hypertarget{edu.kit.pse17.go_app.viewModel.GoViewModel.init()}{{\bf  init}\\}
\begin{lstlisting}[frame=none]
public void init()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.viewModel.GroupListViewModel}Klasse GroupListViewModel}{
\hypertarget{edu.kit.pse17.go_app.viewModel.GroupListViewModel}{}\vskip .1in 
Stellt die Daten fuer die GroupDetailActivity View-Komponente zur Verfuegung und uebernimmt die Kommunikation mit der Programmlogik, um die richtigen Daten an die View weiterzugeben. Das ViewModel hat keine Abhaengigkeit zu der View und wird, anders als die Views, bei Konfigurationsaenderungen nicht zerstoert, sondern bleibt erhalten.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GroupListViewModel
 extends ViewModel\end{lstlisting}

\subsubsection{statische Felder}{
\begin{itemize}
\item{
\index{currentViewModel}
\label{edu.kit.pse17.go_app.viewModel.GroupListViewModel.currentViewModel}\hypertarget{edu.kit.pse17.go_app.viewModel.GroupListViewModel.currentViewModel}{\texttt{public static GroupListViewModel\ {\bf  currentViewModel}}
}
}
\end{itemize}
}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GroupListViewModel(GroupRepository)}
\hypertarget{edu.kit.pse17.go_app.viewModel.GroupListViewModel(edu.kit.pse17.go_app.repositories.GroupRepository)}{{\bf  GroupListViewModel}\\}
\begin{lstlisting}[frame=none]
public GroupListViewModel(edu.kit.pse17.go_app.repositories.GroupRepository groupRepo)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{createGroup(Group)}
\hypertarget{edu.kit.pse17.go_app.viewModel.GroupListViewModel.createGroup(edu.kit.pse17.go_app.model.entities.Group)}{{\bf  createGroup}\\}
\begin{lstlisting}[frame=none]
public void createGroup(edu.kit.pse17.go_app.model.entities.Group group)\end{lstlisting} %end signature
}%end item
\item{ 
\index{getCurrentGroupListViewModel()}
\hypertarget{edu.kit.pse17.go_app.viewModel.GroupListViewModel.getCurrentGroupListViewModel()}{{\bf  getCurrentGroupListViewModel}\\}
\begin{lstlisting}[frame=none]
public static GroupListViewModel getCurrentGroupListViewModel()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getGroups(String)}
\hypertarget{edu.kit.pse17.go_app.viewModel.GroupListViewModel.getGroups(java.lang.String)}{{\bf  getGroups}\\}
\begin{lstlisting}[frame=none]
public <any> getGroups(java.lang.String userId)\end{lstlisting} %end signature
}%end item
\item{ 
\index{init(String)}
\hypertarget{edu.kit.pse17.go_app.viewModel.GroupListViewModel.init(java.lang.String)}{{\bf  init}\\}
\begin{lstlisting}[frame=none]
public void init(java.lang.String uId)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.viewModel.GroupViewModel}Klasse GroupViewModel}{
\hypertarget{edu.kit.pse17.go_app.viewModel.GroupViewModel}{}\vskip .1in 
ViewModel, die alle Daten fuer eine Gruppe beinhaltet.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GroupViewModel
 extends ViewModel\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GroupViewModel()}
\hypertarget{edu.kit.pse17.go_app.viewModel.GroupViewModel()}{{\bf  GroupViewModel}\\}
\begin{lstlisting}[frame=none]
public GroupViewModel()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{addMember(String)}
\hypertarget{edu.kit.pse17.go_app.viewModel.GroupViewModel.addMember(java.lang.String)}{{\bf  addMember}\\}
\begin{lstlisting}[frame=none]
public void addMember(java.lang.String EMail)\end{lstlisting} %end signature
}%end item
\item{ 
\index{answerGroupRequest(boolean)}
\hypertarget{edu.kit.pse17.go_app.viewModel.GroupViewModel.answerGroupRequest(boolean)}{{\bf  answerGroupRequest}\\}
\begin{lstlisting}[frame=none]
public void answerGroupRequest(boolean answer)\end{lstlisting} %end signature
}%end item
\item{ 
\index{createGo(Go)}
\hypertarget{edu.kit.pse17.go_app.viewModel.GroupViewModel.createGo(edu.kit.pse17.go_app.model.entities.Go)}{{\bf  createGo}\\}
\begin{lstlisting}[frame=none]
public void createGo(edu.kit.pse17.go_app.model.entities.Go go)\end{lstlisting} %end signature
}%end item
\item{ 
\index{editGroup(Group)}
\hypertarget{edu.kit.pse17.go_app.viewModel.GroupViewModel.editGroup(Group)}{{\bf  editGroup}\\}
\begin{lstlisting}[frame=none]
public void editGroup(Group group)\end{lstlisting} %end signature
}%end item
\item{ 
\index{getGos(String)}
\hypertarget{edu.kit.pse17.go_app.viewModel.GroupViewModel.getGos(java.lang.String)}{{\bf  getGos}\\}
\begin{lstlisting}[frame=none]
public <any> getGos(java.lang.String groupId)\end{lstlisting} %end signature
}%end item
\item{ 
\index{init()}
\hypertarget{edu.kit.pse17.go_app.viewModel.GroupViewModel.init()}{{\bf  init}\\}
\begin{lstlisting}[frame=none]
public void init()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.viewModel.UserViewModel}Class UserViewModel}{
\hypertarget{edu.kit.pse17.go_app.viewModel.UserViewModel}{}\vskip .1in 
ViewModel, die alle Benutzerdaten beinhaltet. Ist als Singleton implementiert.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class UserViewModel
 extends java.lang.Object\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{UserViewModel()}
\hypertarget{edu.kit.pse17.go_app.viewModel.UserViewModel()}{{\bf  UserViewModel}\\}
\begin{lstlisting}[frame=none]
public UserViewModel()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{deleteUser()}
\hypertarget{edu.kit.pse17.go_app.viewModel.UserViewModel.deleteUser()}{{\bf  deleteUser}\\}
\begin{lstlisting}[frame=none]
public void deleteUser()\end{lstlisting} %end signature
}%end item
\item{ 
\index{deleteUserCredentials()}
\hypertarget{edu.kit.pse17.go_app.viewModel.UserViewModel.deleteUserCredentials()}{{\bf  deleteUserCredentials}\\}
\begin{lstlisting}[frame=none]
public void deleteUserCredentials()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getUserData(String)}
\hypertarget{edu.kit.pse17.go_app.viewModel.UserViewModel.getUserData(java.lang.String)}{{\bf  getUserData}\\}
\begin{lstlisting}[frame=none]
public <any> getUserData(java.lang.String uId)\end{lstlisting} %end signature
}%end item
\item{ 
\index{getUserId()}
\hypertarget{edu.kit.pse17.go_app.viewModel.UserViewModel.getUserId()}{{\bf  getUserId}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getUserId()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getUserInstance()}
\hypertarget{edu.kit.pse17.go_app.viewModel.UserViewModel.getUserInstance()}{{\bf  getUserInstance}\\}
\begin{lstlisting}[frame=none]
public static edu.kit.pse17.go_app.model.entities.User getUserInstance()\end{lstlisting} %end signature
}%end item
\item{ 
\index{init(String)}
\hypertarget{edu.kit.pse17.go_app.viewModel.UserViewModel.init(java.lang.String)}{{\bf  init}\\}
\begin{lstlisting}[frame=none]
public void init(java.lang.String uId)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setUserCredentials(User)}
\hypertarget{edu.kit.pse17.go_app.viewModel.UserViewModel.setUserCredentials(edu.kit.pse17.go_app.model.entities.User)}{{\bf  setUserCredentials}\\}
\begin{lstlisting}[frame=none]
public void setUserCredentials(edu.kit.pse17.go_app.model.entities.User user)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
}
\section{Package Model.entities}{
\label{edu.kit.pse17.go_app.model.entities}\hypertarget{edu.kit.pse17.go_app.model.entities}{}
\hskip -.05in
\hbox to \hsize{\textit{ Package Contents\hfil Page}}
\vskip .13in
\hbox{{\bf  Classes}}
\entityintro{Cluster}{edu.kit.pse17.go_app.model.entities.Cluster}{Die Objekte dieser Klasse repraesentieren die Cluster, die dem Benutzer waehrend eines GOs auf der Karte angezeigt werden.}
\entityintro{Go}{edu.kit.pse17.go_app.model.entities.Go}{Entity-Klasse.}
\entityintro{Group}{edu.kit.pse17.go_app.model.entities.Group}{Entity-Klasse.}
\entityintro{GroupMembership}{edu.kit.pse17.go_app.model.entities.GroupMembership}{Entity-Klasse.}
\entityintro{User}{edu.kit.pse17.go_app.model.entities.User}{Entity-Klasse.}
\entityintro{UserGoStatus}{edu.kit.pse17.go_app.model.entities.UserGoStatus}{Entity-Klasse.}
\vskip .1in
\vskip .1in
\subsection{\label{edu.kit.pse17.go_app.model.entities.Cluster}Class Cluster}{
\hypertarget{edu.kit.pse17.go_app.model.entities.Cluster}{}\vskip .1in 
Die Objekte dieser Klasse repraesentieren die Cluster, die dem Benutzer waehrend eines GOs auf der Karte angezeigt werden. Im Gegensatz zu den anderen Entity-Klassen, wird diese Klasse nicht von Room in der lokalen SQLite Datenbank gespeichert, da eine langfristige Verfuegbarkeit der Daten nicht benoetigt wird. Die Klasse dient Gson als Vorlage zum Parsen der Gso-objekte die via Retrofit gesendet und empfangen werden.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class Cluster
 extends java.lang.Object\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{Cluster(long, long, int)}
\hypertarget{edu.kit.pse17.go_app.model.entities.Cluster(long, long, int)}{{\bf  Cluster}\\}
\begin{lstlisting}[frame=none]
public Cluster(long lat,long lon,int size)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getLat()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Cluster.getLat()}{{\bf  getLat}\\}
\begin{lstlisting}[frame=none]
public long getLat()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getLon()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Cluster.getLon()}{{\bf  getLon}\\}
\begin{lstlisting}[frame=none]
public long getLon()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getSize()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Cluster.getSize()}{{\bf  getSize}\\}
\begin{lstlisting}[frame=none]
public int getSize()\end{lstlisting} %end signature
}%end item
\item{ 
\index{setLat(long)}
\hypertarget{edu.kit.pse17.go_app.model.entities.Cluster.setLat(long)}{{\bf  setLat}\\}
\begin{lstlisting}[frame=none]
public void setLat(long lat)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setLon(long)}
\hypertarget{edu.kit.pse17.go_app.model.entities.Cluster.setLon(long)}{{\bf  setLon}\\}
\begin{lstlisting}[frame=none]
public void setLon(long lon)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setSize(int)}
\hypertarget{edu.kit.pse17.go_app.model.entities.Cluster.setSize(int)}{{\bf  setSize}\\}
\begin{lstlisting}[frame=none]
public void setSize(int size)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.model.entities.Go}Klasse Go}{
\hypertarget{edu.kit.pse17.go_app.model.entities.Go}{}\vskip .1in 
Entity-Klasse. Anhand dieser Klasse wird eine Tabelle in der lokalen SQLite Datenbank generiert, die Go-Objekte persistiert. Der Zugriff auf die Daten laeuft ausschliesslich ueber die GoEntityDAO-Klasse\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class Go
 extends java.lang.Object\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{Go()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go()}{{\bf  Go}\\}
\begin{lstlisting}[frame=none]
public Go()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getDescription()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go.getDescription()}{{\bf  getDescription}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getDescription()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getDesLat()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go.getDesLat()}{{\bf  getDesLat}\\}
\begin{lstlisting}[frame=none]
public long getDesLat()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getDesLon()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go.getDesLon()}{{\bf  getDesLon}\\}
\begin{lstlisting}[frame=none]
public long getDesLon()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getEnd()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go.getEnd()}{{\bf  getEnd}\\}
\begin{lstlisting}[frame=none]
public java.util.Date getEnd()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getId()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go.getId()}{{\bf  getId}\\}
\begin{lstlisting}[frame=none]
public long getId()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getName()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go.getName()}{{\bf  getName}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getName()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getOwner()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go.getOwner()}{{\bf  getOwner}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getOwner()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getOwnerName()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go.getOwnerName()}{{\bf  getOwnerName}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getOwnerName()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getParticipantsList()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go.getParticipantsList()}{{\bf  getParticipantsList}\\}
\begin{lstlisting}[frame=none]
public java.util.List getParticipantsList()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getStart()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go.getStart()}{{\bf  getStart}\\}
\begin{lstlisting}[frame=none]
public java.util.Date getStart()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getUserStatus()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go.getUserStatus()}{{\bf  getUserStatus}\\}
\begin{lstlisting}[frame=none]
public edu.kit.pse17.go_app.model.Status getUserStatus()\end{lstlisting} %end signature
}%end item
\item{ 
\index{setDescription(String)}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go.setDescription(java.lang.String)}{{\bf  setDescription}\\}
\begin{lstlisting}[frame=none]
public void setDescription(java.lang.String description)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setDesLat(long)}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go.setDesLat(long)}{{\bf  setDesLat}\\}
\begin{lstlisting}[frame=none]
public void setDesLat(long lat)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setDesLon(long)}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go.setDesLon(long)}{{\bf  setDesLon}\\}
\begin{lstlisting}[frame=none]
public void setDesLon(long lon)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setEnd(Date)}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go.setEnd(java.util.Date)}{{\bf  setEnd}\\}
\begin{lstlisting}[frame=none]
public void setEnd(java.util.Date end)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setId(long)}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go.setId(long)}{{\bf  setId}\\}
\begin{lstlisting}[frame=none]
public void setId(long id)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setName(String)}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go.setName(java.lang.String)}{{\bf  setName}\\}
\begin{lstlisting}[frame=none]
public void setName(java.lang.String name)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setOwner(String)}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go.setOwner(java.lang.String)}{{\bf  setOwner}\\}
\begin{lstlisting}[frame=none]
public void setOwner(java.lang.String owner)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setOwnerName(String)}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go.setOwnerName(java.lang.String)}{{\bf  setOwnerName}\\}
\begin{lstlisting}[frame=none]
public void setOwnerName(java.lang.String ownerName)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setParticipantsList(List)}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go.setParticipantsList(java.util.List)}{{\bf  setParticipantsList}\\}
\begin{lstlisting}[frame=none]
public void setParticipantsList(java.util.List participantsList)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setStart(Date)}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go.setStart(java.util.Date)}{{\bf  setStart}\\}
\begin{lstlisting}[frame=none]
public void setStart(java.util.Date start)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setUserStatus(Status)}
\hypertarget{edu.kit.pse17.go_app.model.entities.Go.setUserStatus(edu.kit.pse17.go_app.model.Status)}{{\bf  setUserStatus}\\}
\begin{lstlisting}[frame=none]
public void setUserStatus(edu.kit.pse17.go_app.model.Status userStatus)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.model.entities.Group}Klasse Group}{
\hypertarget{edu.kit.pse17.go_app.model.entities.Group}{}\vskip .1in 
Entity-Klasse. Anhand dieser Klasse wird eine Tabelle in der lokalen SQLite Datenbank generiert, die Gruppen-Objekte persistiert. Der Zugriff auf die Daten laeuft ausschliesslich ueber die GroupEntityDAO-Klasse\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class Group
 extends java.lang.Object\end{lstlisting}

\subsubsection{statische Felder}{
\begin{itemize}
\item{
\index{icon}
\label{edu.kit.pse17.go_app.model.entities.Group.icon}\hypertarget{edu.kit.pse17.go_app.model.entities.Group.icon}{\texttt{public Icon\ {\bf  icon}}
}
\begin{itemize}
\item{\vskip -.9ex 
Das Bild der Gruppe}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{Group()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Group()}{{\bf  Group}\\}
\begin{lstlisting}[frame=none]
public Group()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getCurrentGos()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Group.getCurrentGos()}{{\bf  getCurrentGos}\\}
\begin{lstlisting}[frame=none]
public java.util.List getCurrentGos()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getDescription()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Group.getDescription()}{{\bf  getDescription}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getDescription()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getIcon()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Group.getIcon()}{{\bf  getIcon}\\}
\begin{lstlisting}[frame=none]
public Icon getIcon()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getId()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Group.getId()}{{\bf  getId}\\}
\begin{lstlisting}[frame=none]
public long getId()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getMemberCount()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Group.getMemberCount()}{{\bf  getMemberCount}\\}
\begin{lstlisting}[frame=none]
public int getMemberCount()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getMembershipList()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Group.getMembershipList()}{{\bf  getMembershipList}\\}
\begin{lstlisting}[frame=none]
public java.util.List getMembershipList()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getName()}
\hypertarget{edu.kit.pse17.go_app.model.entities.Group.getName()}{{\bf  getName}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getName()\end{lstlisting} %end signature
}%end item
\item{ 
\index{setCurrentGos(List)}
\hypertarget{edu.kit.pse17.go_app.model.entities.Group.setCurrentGos(java.util.List)}{{\bf  setCurrentGos}\\}
\begin{lstlisting}[frame=none]
public void setCurrentGos(java.util.List currentGos)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setDescription(String)}
\hypertarget{edu.kit.pse17.go_app.model.entities.Group.setDescription(java.lang.String)}{{\bf  setDescription}\\}
\begin{lstlisting}[frame=none]
public void setDescription(java.lang.String description)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setIcon(Icon)}
\hypertarget{edu.kit.pse17.go_app.model.entities.Group.setIcon(Icon)}{{\bf  setIcon}\\}
\begin{lstlisting}[frame=none]
public void setIcon(Icon icon)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setId(long)}
\hypertarget{edu.kit.pse17.go_app.model.entities.Group.setId(long)}{{\bf  setId}\\}
\begin{lstlisting}[frame=none]
public void setId(long id)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setMemberCount(int)}
\hypertarget{edu.kit.pse17.go_app.model.entities.Group.setMemberCount(int)}{{\bf  setMemberCount}\\}
\begin{lstlisting}[frame=none]
public void setMemberCount(int memberCount)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setMembershipList(List)}
\hypertarget{edu.kit.pse17.go_app.model.entities.Group.setMembershipList(java.util.List)}{{\bf  setMembershipList}\\}
\begin{lstlisting}[frame=none]
public void setMembershipList(java.util.List membershipList)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setName(String)}
\hypertarget{edu.kit.pse17.go_app.model.entities.Group.setName(java.lang.String)}{{\bf  setName}\\}
\begin{lstlisting}[frame=none]
public void setName(java.lang.String name)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.model.entities.GroupMembership}Class GroupMembership}{
\hypertarget{edu.kit.pse17.go_app.model.entities.GroupMembership}{}\vskip .1in 
Entity-Klasse. Anhand dieser Klasse wird eine Tabelle in der lokalen SQLite Datenbank generiert, die GroupMembership-Objekte persistiert. Diese Klasse stellt alle Mitglieder der Gruppe + Information ob das Mitglied ein Administrator ist oder ob es sich bei der Mitgliedschaft lediglich um eine offene Grupppenanfrage handelt dar.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GroupMembership
 extends java.lang.Object\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GroupMembership(User, Group, boolean, boolean)}
\hypertarget{edu.kit.pse17.go_app.model.entities.GroupMembership(edu.kit.pse17.go_app.model.entities.User, edu.kit.pse17.go_app.model.entities.Group, boolean, boolean)}{{\bf  GroupMembership}\\}
\begin{lstlisting}[frame=none]
public GroupMembership(User user,Group group,boolean isAdmin,boolean isRequest)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getGroup()}
\hypertarget{edu.kit.pse17.go_app.model.entities.GroupMembership.getGroup()}{{\bf  getGroup}\\}
\begin{lstlisting}[frame=none]
public Group getGroup()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getUser()}
\hypertarget{edu.kit.pse17.go_app.model.entities.GroupMembership.getUser()}{{\bf  getUser}\\}
\begin{lstlisting}[frame=none]
public User getUser()\end{lstlisting} %end signature
}%end item
\item{ 
\index{isAdmin()}
\hypertarget{edu.kit.pse17.go_app.model.entities.GroupMembership.isAdmin()}{{\bf  isAdmin}\\}
\begin{lstlisting}[frame=none]
public boolean isAdmin()\end{lstlisting} %end signature
}%end item
\item{ 
\index{isRequest()}
\hypertarget{edu.kit.pse17.go_app.model.entities.GroupMembership.isRequest()}{{\bf  isRequest}\\}
\begin{lstlisting}[frame=none]
public boolean isRequest()\end{lstlisting} %end signature
}%end item
\item{ 
\index{setAdmin(boolean)}
\hypertarget{edu.kit.pse17.go_app.model.entities.GroupMembership.setAdmin(boolean)}{{\bf  setAdmin}\\}
\begin{lstlisting}[frame=none]
public void setAdmin(boolean admin)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setGroup(Group)}
\hypertarget{edu.kit.pse17.go_app.model.entities.GroupMembership.setGroup(edu.kit.pse17.go_app.model.entities.Group)}{{\bf  setGroup}\\}
\begin{lstlisting}[frame=none]
public void setGroup(Group group)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setRequest(boolean)}
\hypertarget{edu.kit.pse17.go_app.model.entities.GroupMembership.setRequest(boolean)}{{\bf  setRequest}\\}
\begin{lstlisting}[frame=none]
public void setRequest(boolean request)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setUser(User)}
\hypertarget{edu.kit.pse17.go_app.model.entities.GroupMembership.setUser(edu.kit.pse17.go_app.model.entities.User)}{{\bf  setUser}\\}
\begin{lstlisting}[frame=none]
public void setUser(User user)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.model.entities.User}Klasse User}{
\hypertarget{edu.kit.pse17.go_app.model.entities.User}{}\vskip .1in 
Entity-Klasse. Anhand dieser Klasse wird eine Tabelle in der lokalen SQLite Datenbank generiert, die User-Objekte persistiert. Der Zugriff auf die Daten laeuft ausschliesslich ueber die UserEntityDAO-Klasse\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class User
 extends java.lang.Object implements java.io.Serializable\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{User(String, String, String, String, Icon)}
\hypertarget{edu.kit.pse17.go_app.model.entities.User(java.lang.String, java.lang.String, java.lang.String, java.lang.String, Icon)}{{\bf  User}\\}
\begin{lstlisting}[frame=none]
public User(java.lang.String uid,java.lang.String instanceId,java.lang.String name,java.lang.String email,Icon icon)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getEmail()}
\hypertarget{edu.kit.pse17.go_app.model.entities.User.getEmail()}{{\bf  getEmail}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getEmail()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getIcon()}
\hypertarget{edu.kit.pse17.go_app.model.entities.User.getIcon()}{{\bf  getIcon}\\}
\begin{lstlisting}[frame=none]
public Icon getIcon()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getInstanceId()}
\hypertarget{edu.kit.pse17.go_app.model.entities.User.getInstanceId()}{{\bf  getInstanceId}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getInstanceId()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getName()}
\hypertarget{edu.kit.pse17.go_app.model.entities.User.getName()}{{\bf  getName}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getName()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getUid()}
\hypertarget{edu.kit.pse17.go_app.model.entities.User.getUid()}{{\bf  getUid}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getUid()\end{lstlisting} %end signature
}%end item
\item{ 
\index{setEmail(String)}
\hypertarget{edu.kit.pse17.go_app.model.entities.User.setEmail(java.lang.String)}{{\bf  setEmail}\\}
\begin{lstlisting}[frame=none]
public void setEmail(java.lang.String email)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setIcon(Icon)}
\hypertarget{edu.kit.pse17.go_app.model.entities.User.setIcon(Icon)}{{\bf  setIcon}\\}
\begin{lstlisting}[frame=none]
public void setIcon(Icon icon)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setInstanceId(String)}
\hypertarget{edu.kit.pse17.go_app.model.entities.User.setInstanceId(java.lang.String)}{{\bf  setInstanceId}\\}
\begin{lstlisting}[frame=none]
public void setInstanceId(java.lang.String instanceId)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setName(String)}
\hypertarget{edu.kit.pse17.go_app.model.entities.User.setName(java.lang.String)}{{\bf  setName}\\}
\begin{lstlisting}[frame=none]
public void setName(java.lang.String name)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setUid(String)}
\hypertarget{edu.kit.pse17.go_app.model.entities.User.setUid(java.lang.String)}{{\bf  setUid}\\}
\begin{lstlisting}[frame=none]
public void setUid(java.lang.String uid)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.model.entities.UserGoStatus}Klasse UserGoStatus}{
\hypertarget{edu.kit.pse17.go_app.model.entities.UserGoStatus}{}\vskip .1in 
Entity-Klasse. Anhand dieser Klasse wird eine Tabelle in der lokalen SQLite Datenbank generiert, die UserGoStatus-Objekte persistiert. Diese Klasse stellt alle Teilnehmer eines GOs + Status des Teilnehmers bei diesem GO dar. Jeder Benutzer darf nur Status innerhalb eines GOs haben.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class UserGoStatus
 extends java.lang.Object\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{UserGoStatus(User, Go, Status)}
\hypertarget{edu.kit.pse17.go_app.model.entities.UserGoStatus(edu.kit.pse17.go_app.model.entities.User, edu.kit.pse17.go_app.model.entities.Go, edu.kit.pse17.go_app.model.Status)}{{\bf  UserGoStatus}\\}
\begin{lstlisting}[frame=none]
public UserGoStatus(User user,Go go,edu.kit.pse17.go_app.model.Status status)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getGo()}
\hypertarget{edu.kit.pse17.go_app.model.entities.UserGoStatus.getGo()}{{\bf  getGo}\\}
\begin{lstlisting}[frame=none]
public Go getGo()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getStatus()}
\hypertarget{edu.kit.pse17.go_app.model.entities.UserGoStatus.getStatus()}{{\bf  getStatus}\\}
\begin{lstlisting}[frame=none]
public edu.kit.pse17.go_app.model.Status getStatus()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getUser()}
\hypertarget{edu.kit.pse17.go_app.model.entities.UserGoStatus.getUser()}{{\bf  getUser}\\}
\begin{lstlisting}[frame=none]
public User getUser()\end{lstlisting} %end signature
}%end item
\item{ 
\index{setGo(Go)}
\hypertarget{edu.kit.pse17.go_app.model.entities.UserGoStatus.setGo(edu.kit.pse17.go_app.model.entities.Go)}{{\bf  setGo}\\}
\begin{lstlisting}[frame=none]
public void setGo(Go go)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setStatus(Status)}
\hypertarget{edu.kit.pse17.go_app.model.entities.UserGoStatus.setStatus(edu.kit.pse17.go_app.model.Status)}{{\bf  setStatus}\\}
\begin{lstlisting}[frame=none]
public void setStatus(edu.kit.pse17.go_app.model.Status status)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setUser(User)}
\hypertarget{edu.kit.pse17.go_app.model.entities.UserGoStatus.setUser(edu.kit.pse17.go_app.model.entities.User)}{{\bf  setUser}\\}
\begin{lstlisting}[frame=none]
public void setUser(User user)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
}
\section{Package Model}{
\label{edu.kit.pse17.go_app.model}\hypertarget{edu.kit.pse17.go_app.model}{}
\hskip -.05in
\hbox to \hsize{\textit{ Package Contents\hfil Page}}
\vskip .13in
\hbox{{\bf  Classes}}
\entityintro{Status}{edu.kit.pse17.go_app.model.Status}{Moeglicher Teilnahmestatus fuer GOs: NOT\_GOING = Abgelehnt GOING = Bestaetigt GONE = Unterwegs}
\vskip .1in
\vskip .1in
\subsection{\label{edu.kit.pse17.go_app.model.Status}Enum Status}{
\hypertarget{edu.kit.pse17.go_app.model.Status}{}\vskip .1in 
Moeglicher Teilnahmestatus fuer GOs: NOT\_GOING = Abgelehnt GOING = Bestaetigt GONE = Unterwegs\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public final class Status
 extends java.lang.Enum\end{lstlisting}

\subsubsection{statische Felder}{
\begin{itemize}
\item{
\index{NOT\_GOING}
\label{edu.kit.pse17.go_app.model.Status.NOT_GOING}\hypertarget{edu.kit.pse17.go_app.model.Status.NOT_GOING}{\texttt{public static final Status\ {\bf  NOT\_GOING}}
}
}
\item{
\index{GOING}
\label{edu.kit.pse17.go_app.model.Status.GOING}\hypertarget{edu.kit.pse17.go_app.model.Status.GOING}{\texttt{public static final Status\ {\bf  GOING}}
}
}
\item{
\index{GONE}
\label{edu.kit.pse17.go_app.model.Status.GONE}\hypertarget{edu.kit.pse17.go_app.model.Status.GONE}{\texttt{public static final Status\ {\bf  GONE}}
}
}
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{valueOf(String)}
\hypertarget{edu.kit.pse17.go_app.model.Status.valueOf(java.lang.String)}{{\bf  valueOf}\\}
\begin{lstlisting}[frame=none]
public static Status valueOf(java.lang.String name)\end{lstlisting} %end signature
}%end item
\item{ 
\index{values()}
\hypertarget{edu.kit.pse17.go_app.model.Status.values()}{{\bf  values}\\}
\begin{lstlisting}[frame=none]
public static Status[] values()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{von Enum vererbte Methoden}{
\texttt{java.lang.Enum} {\small 
\refdefined{java.lang.Enum}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{protected final Object {\bf  clone}() throws CloneNotSupportedException
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public final int {\bf  compareTo}(\texttt{Enum} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public final boolean {\bf  equals}(\texttt{Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{protected final void {\bf  finalize}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public final Class {\bf  getDeclaringClass}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public final int {\bf  hashCode}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public final String {\bf  name}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public final int {\bf  ordinal}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public String {\bf  toString}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public static Enum {\bf  valueOf}(\texttt{Class} {\bf  arg0},
\texttt{String} {\bf  arg1})
}%end signature
}%end item
\end{itemize}
}
}
}
\section{Package ServerCommunication.downstream}{

\subsection{\label{edu.kit.pse17.go_app.serverCommunication.downstream.MessageReceiver}Klasse MessageReceiver}{
\hypertarget{edu.kit.pse17.go_app.serverCommunication.downstream.MessageReceiver}{}\vskip .1in 
Dies Klasse ist eine Unterklasse von FirebaseMessagingService, die auf den Go Tomcat-Server hoert. DAs heisst, schickt der Server via FCM eine Nachricht an den LCient, wird sie in dieser Klasse empfangen. Wird eine Nachricht an den CLient gesendet waehrend die App im Hintergrund laeuft, wird der Inhalt der Nachricht uaf dem System Tray gespeichert. Bei erneutem Aufrufen der App muss ueberprueft werden, ob in der Zwischenzeit NAchrichten angekommen sind. Sind es zu viele Nachrichten die auf dem System Tray gespeichert worden sind, so kann nicht garantiert werden, dass alle noch vorhanden sind. In diesem Fall wird die Methode onDeletedMessages() aufgerufen. Hier sollten die gesamten Nutzerdaten von Server abgefragt werden, um sicherzugehen, dass der Client alle aktuellen bei sich hat. Bei Ankunft einer Nachricht des Servers, wird die onMessageReceived-Methode aufgerufen und dort weiter behandelt. Der Service muss beim Start der App gesstartet werden und beim Schliessen der App wieder beendet. Dabei muss der Service auf einem Backgroun Thread und nicht auf dem main UI Thread laufen.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class MessageReceiver
 extends FirebaseMessagingService\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{MessageReceiver()}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.downstream.MessageReceiver()}{{\bf  MessageReceiver}\\}
\begin{lstlisting}[frame=none]
public MessageReceiver()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onDeletedMessages()}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.downstream.MessageReceiver.onDeletedMessages()}{{\bf  onDeletedMessages}\\}
\begin{lstlisting}[frame=none]
public void onDeletedMessages()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode wird aufgerufen, falls zu viele Benachrichtigungen an den CLient gesendet wurden, waehrend die App im Hintergrund lief. Dann sit es nicht mehr garantiert, dass alle diese Nachrichten noch in der System tray zu finden sind. Es sollten also die gesamten Nuterdaten nochmal vom Server angefragt werden. Das passiert in dieser Methode.
}
\end{itemize}
}%end item
\item{ 
\index{onMessageReceived(RemoteMessage)}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.downstream.MessageReceiver.onMessageReceived(RemoteMessage)}{{\bf  onMessageReceived}\\}
\begin{lstlisting}[frame=none]
public void onMessageReceived(RemoteMessage remoteMessage)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode wird aufgerufen, wenn die App eine Nachricht vom FCM Server erhaelt waehrend sie im Vordergrund laeuft. Die Nachricht sollte spaetestens 10s nach ihrer Ankunft behandelt werden, vie Spezifikation der Fcm API.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{remoteMessage} -- die erhaltene Nachricht, verpackt in ein RemoteMessage-Objekt. Dieses Objekt wird vom FCM Server erzeugt und enthaelt die Attribute from und data, mit denen die fuer diese Anwendung relevanten Daten ermittelt werden koennen.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.serverCommunication.downstream.TokenService}Klasse TokenService}{
\hypertarget{edu.kit.pse17.go_app.serverCommunication.downstream.TokenService}{}\vskip .1in 
Die Klasse erzeugt ein InstanceID Token, welches an den Server uebergeben wird, um von Server-Seite aus Nachrichten an ein einzelnes Geraet schicken zu koennen. Bei jeder Anmeldung in der App muss eine solche InstanceID erzeugt werden, um sicher zu gehen, dass diese auch aktuell und gueltig ist. Danach wird diese an den Server weitergeleitet. Es kann waehrend der Ausfuehrung der App auch zu einer Erneuerung der InstanceID kommen. In diesem Fall wird die onTokenReferesh() Methode dieser Klasse aufgerufen.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class TokenService
 extends FirebaseInstanceIdService\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{TokenService()}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.downstream.TokenService()}{{\bf  TokenService}\\}
\begin{lstlisting}[frame=none]
public TokenService()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onTokenRefresh()}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.downstream.TokenService.onTokenRefresh()}{{\bf  onTokenRefresh}\\}
\begin{lstlisting}[frame=none]
public void onTokenRefresh()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Wird ein neues Token fuer ein Geraet erzeugt, wird automatisch diese Methode aufgerufen. In der Methode wird das neue Token an den Tomcat-Server gesendet, damit weiterhin Server-Nachrichten an diesen Client gesendet werden koennen.
}
\end{itemize}
}%end item
\end{itemize}
}
}
}
\section{Package ServerCommunication.upstream}{
\label{edu.kit.pse17.go_app.serverCommunication.upstream}\hypertarget{edu.kit.pse17.go_app.serverCommunication.upstream}{}

\subsection{\label{edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi}Interface TomcatRestApi}{
\hypertarget{edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi}{}\vskip .1in 
das Interface ist die Schnittstelle des Clients zur REST-API des Tomcat-Servers. Die Kommunikation mit der Rest-API des Servers wird von dem Framework Retrofit uebernommen. In diesem Interface werden deshalb alle Methoden definiert, die von der REST API des Servers angeboten werden. Die Implementierung ist nicht noetig, dies wird von Retrofit uebernommen. Aufgerufen werden diese Methoden in der Klassen des Repository Moduls. Genauere Beschreibungen zur Funktion, den Argumenten und Rueckgabetypen der Methoden sind in den Implementierungen der REST-API zu finden. dabei stimmen die Rueckgabetypen der Methoden dieses Interface mit den Rueckgabetypen der Rest-Methoden des Servers ueberein, sind jedoch in einem Call\_Objket gewrappt, wie es bei der Benutzung des Retrofit Frameworks ueblich ist.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public interface TomcatRestApi
\end{lstlisting}

\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{acceptRequest(long, String)}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi.acceptRequest(long, java.lang.String)}{{\bf  acceptRequest}\\}
\begin{lstlisting}[frame=none]
<any> acceptRequest(long groupId,java.lang.String userId)\end{lstlisting} %end signature
}%end item
\item{ 
\index{addAdmin(String, String)}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi.addAdmin(java.lang.String, java.lang.String)}{{\bf  addAdmin}\\}
\begin{lstlisting}[frame=none]
<any> addAdmin(java.lang.String groupId,java.lang.String userId)\end{lstlisting} %end signature
}%end item
\item{ 
\index{changeStatus(long, String, Status)}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi.changeStatus(long, java.lang.String, edu.kit.pse17.go_app.model.Status)}{{\bf  changeStatus}\\}
\begin{lstlisting}[frame=none]
<any> changeStatus(long goId,java.lang.String userId,edu.kit.pse17.go_app.model.Status status)\end{lstlisting} %end signature
}%end item
\item{ 
\index{createGo(String, String, Date, Date, double, double, int, long, String)}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi.createGo(java.lang.String, java.lang.String, java.util.Date, java.util.Date, double, double, int, long, java.lang.String)}{{\bf  createGo}\\}
\begin{lstlisting}[frame=none]
<any> createGo(java.lang.String name,java.lang.String description,java.util.Date start,java.util.Date end,double lat,double lon,int threshold,long groupId,java.lang.String userId)\end{lstlisting} %end signature
}%end item
\item{ 
\index{createGroup(String, String, String)}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi.createGroup(java.lang.String, java.lang.String, java.lang.String)}{{\bf  createGroup}\\}
\begin{lstlisting}[frame=none]
<any> createGroup(java.lang.String name,java.lang.String description,java.lang.String userId)\end{lstlisting} %end signature
}%end item
\item{ 
\index{createUser(String)}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi.createUser(java.lang.String)}{{\bf  createUser}\\}
\begin{lstlisting}[frame=none]
<any> createUser(java.lang.String userId)\end{lstlisting} %end signature
}%end item
\item{ 
\index{deleteGo(String)}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi.deleteGo(java.lang.String)}{{\bf  deleteGo}\\}
\begin{lstlisting}[frame=none]
<any> deleteGo(java.lang.String goId)\end{lstlisting} %end signature
}%end item
\item{ 
\index{deleteGroup(Long)}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi.deleteGroup(java.lang.Long)}{{\bf  deleteGroup}\\}
\begin{lstlisting}[frame=none]
<any> deleteGroup(java.lang.Long groupId)\end{lstlisting} %end signature
}%end item
\item{ 
\index{deleteUser(String)}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi.deleteUser(java.lang.String)}{{\bf  deleteUser}\\}
\begin{lstlisting}[frame=none]
<any> deleteUser(java.lang.String userId)\end{lstlisting} %end signature
}%end item
\item{ 
\index{denyRequest(String, String)}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi.denyRequest(java.lang.String, java.lang.String)}{{\bf  denyRequest}\\}
\begin{lstlisting}[frame=none]
<any> denyRequest(java.lang.String userId,java.lang.String groupId)\end{lstlisting} %end signature
}%end item
\item{ 
\index{editGo(String, String, String, Date, Date, long, long, int)}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi.editGo(java.lang.String, java.lang.String, java.lang.String, java.util.Date, java.util.Date, long, long, int)}{{\bf  editGo}\\}
\begin{lstlisting}[frame=none]
<any> editGo(java.lang.String goId,java.lang.String name,java.lang.String description,java.util.Date start,java.util.Date end,long lat,long lon,int threshold)\end{lstlisting} %end signature
}%end item
\item{ 
\index{editGroup(long, String, String)}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi.editGroup(long, java.lang.String, java.lang.String)}{{\bf  editGroup}\\}
\begin{lstlisting}[frame=none]
<any> editGroup(long groupId,java.lang.String name,java.lang.String description)\end{lstlisting} %end signature
}%end item
\item{ 
\index{getData(String)}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi.getData(java.lang.String)}{{\bf  getData}\\}
\begin{lstlisting}[frame=none]
<any> getData(java.lang.String userId)\end{lstlisting} %end signature
}%end item
\item{ 
\index{getLocation(String)}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi.getLocation(java.lang.String)}{{\bf  getLocation}\\}
\begin{lstlisting}[frame=none]
<any> getLocation(java.lang.String goId)\end{lstlisting} %end signature
}%end item
\item{ 
\index{inviteMember(long, String)}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi.inviteMember(long, java.lang.String)}{{\bf  inviteMember}\\}
\begin{lstlisting}[frame=none]
<any> inviteMember(long groupId,java.lang.String userId)\end{lstlisting} %end signature
}%end item
\item{ 
\index{registerDevice(String)}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi.registerDevice(java.lang.String)}{{\bf  registerDevice}\\}
\begin{lstlisting}[frame=none]
<any> registerDevice(java.lang.String instanceId)\end{lstlisting} %end signature
}%end item
\item{ 
\index{removeMember(String, long)}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi.removeMember(java.lang.String, long)}{{\bf  removeMember}\\}
\begin{lstlisting}[frame=none]
<any> removeMember(java.lang.String userId,long groupId)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setLocation(String, long, long, String)}
\hypertarget{edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi.setLocation(java.lang.String, long, long, java.lang.String)}{{\bf  setLocation}\\}
\begin{lstlisting}[frame=none]
<any> setLocation(java.lang.String userId,long lat,long lon,java.lang.String goId)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
}
\section{Package Repositories}{
\label{edu.kit.pse17.go_app.repositories}\hypertarget{edu.kit.pse17.go_app.repositories}{}

\subsection{\label{edu.kit.pse17.go_app.repositories.GoRepository}Klasse GoRepository}{
\hypertarget{edu.kit.pse17.go_app.repositories.GoRepository}{}\vskip .1in 
Das Go-Repository ist verantwortlich fuer saemtliche Operationen auf den Go-Daten und stellt eine einfache Schnittstelle zum Holen, aendern und Loeschen von Daten zur Verfuegung. Bei einer Anfrage weiss das Repository, wo es die Daten holen muss (lokal oder vom remote Server). Das Repository agiert als Vermittler zwischen der lokalen Datanbank und den Daten die die App vom Server erhaelt.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GoRepository
 extends edu.kit.pse17.go_app.repositories.Repository\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GoRepository(TomcatRestApi, GoDao, Executor)}
\hypertarget{edu.kit.pse17.go_app.repositories.GoRepository(edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi, GoDao, java.util.concurrent.Executor)}{{\bf  GoRepository}\\}
\begin{lstlisting}[frame=none]
public GoRepository(edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi webService,GoDao goDao,java.util.concurrent.Executor executor)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{changeStatus(Status, String, String)}
\hypertarget{edu.kit.pse17.go_app.repositories.GoRepository.changeStatus(Status, java.lang.String, java.lang.String)}{{\bf  changeStatus}\\}
\begin{lstlisting}[frame=none]
public void changeStatus(Status status,java.lang.String goId,java.lang.String userId)\end{lstlisting} %end signature
}%end item
\item{ 
\index{editGo(Go)}
\hypertarget{edu.kit.pse17.go_app.repositories.GoRepository.editGo(edu.kit.pse17.go_app.model.entities.Go)}{{\bf  editGo}\\}
\begin{lstlisting}[frame=none]
public void editGo(edu.kit.pse17.go_app.model.entities.Go go)\end{lstlisting} %end signature
}%end item
\item{ 
\index{fetchData()}
\hypertarget{edu.kit.pse17.go_app.repositories.GoRepository.fetchData()}{{\bf  fetchData}\\}
\begin{lstlisting}[frame=none]
public abstract <any> fetchData()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getLocations(String, Location)}
\hypertarget{edu.kit.pse17.go_app.repositories.GoRepository.getLocations(java.lang.String, Location)}{{\bf  getLocations}\\}
\begin{lstlisting}[frame=none]
public <any> getLocations(java.lang.String goId,Location location)\end{lstlisting} %end signature
}%end item
\item{ 
\index{getUpdatedData()}
\hypertarget{edu.kit.pse17.go_app.repositories.GoRepository.getUpdatedData()}{{\bf  getUpdatedData}\\}
\begin{lstlisting}[frame=none]
public abstract <any> getUpdatedData()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{von Repository geerbte Methoden}{
\texttt{edu.kit.pse17.go\_app.repositories.Repository} {\small 
\refdefined{edu.kit.pse17.go_app.repositories.Repository}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public abstract  {\bf  fetchData}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public abstract  {\bf  getUpdatedData}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public static void {\bf  receiveUpdatedData}()
}%end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.repositories.GroupRepository}Klasse GroupRepository}{
\hypertarget{edu.kit.pse17.go_app.repositories.GroupRepository}{}\vskip .1in 
Das Go-Repository ist verantwortlich fuer saemtliche Operationen auf den Go-Daten und stellt eine einfache Schnittstelle zum Holen, aendern und Loeschen von Daten zur Verfuegung. Bei einer Anfrage weiss das Repository, wo es die Daten holen muss (lokal oder vom remote Server). Das Repository agiert als Vermittler zwischen der lokalen Datanbank und den Daten die die App vom Server erhaelt.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GroupRepository
 extends edu.kit.pse17.go_app.repositories.Repository\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GroupRepository(TomcatRestApi, GroupDao, Executor)}
\hypertarget{edu.kit.pse17.go_app.repositories.GroupRepository(edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi, GroupDao, java.util.concurrent.Executor)}{{\bf  GroupRepository}\\}
\begin{lstlisting}[frame=none]
public GroupRepository(edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi webservice,GroupDao groupDao,java.util.concurrent.Executor executor)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{addMember(String, String)}
\hypertarget{edu.kit.pse17.go_app.repositories.GroupRepository.addMember(java.lang.String, java.lang.String)}{{\bf  addMember}\\}
\begin{lstlisting}[frame=none]
public void addMember(java.lang.String Email,java.lang.String groupid)\end{lstlisting} %end signature
}%end item
\item{ 
\index{answerGroupRequest(String, boolean)}
\hypertarget{edu.kit.pse17.go_app.repositories.GroupRepository.answerGroupRequest(java.lang.String, boolean)}{{\bf  answerGroupRequest}\\}
\begin{lstlisting}[frame=none]
public void answerGroupRequest(java.lang.String groupId,boolean answer)\end{lstlisting} %end signature
}%end item
\item{ 
\index{createGo(Go, String)}
\hypertarget{edu.kit.pse17.go_app.repositories.GroupRepository.createGo(edu.kit.pse17.go_app.model.entities.Go, java.lang.String)}{{\bf  createGo}\\}
\begin{lstlisting}[frame=none]
public void createGo(edu.kit.pse17.go_app.model.entities.Go go,java.lang.String groupId)\end{lstlisting} %end signature
}%end item
\item{ 
\index{createGroup(Group)}
\hypertarget{edu.kit.pse17.go_app.repositories.GroupRepository.createGroup(edu.kit.pse17.go_app.model.entities.Group)}{{\bf  createGroup}\\}
\begin{lstlisting}[frame=none]
public void createGroup(edu.kit.pse17.go_app.model.entities.Group group)\end{lstlisting} %end signature
}%end item
\item{ 
\index{editGroup(Group)}
\hypertarget{edu.kit.pse17.go_app.repositories.GroupRepository.editGroup(edu.kit.pse17.go_app.model.entities.Group)}{{\bf  editGroup}\\}
\begin{lstlisting}[frame=none]
public void editGroup(edu.kit.pse17.go_app.model.entities.Group group)\end{lstlisting} %end signature
}%end item
\item{ 
\index{fetchData()}
\hypertarget{edu.kit.pse17.go_app.repositories.GroupRepository.fetchData()}{{\bf  fetchData}\\}
\begin{lstlisting}[frame=none]
public abstract <any> fetchData()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getUpdatedData()}
\hypertarget{edu.kit.pse17.go_app.repositories.GroupRepository.getUpdatedData()}{{\bf  getUpdatedData}\\}
\begin{lstlisting}[frame=none]
public abstract <any> getUpdatedData()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{von Repository geerbte Methoden}{
\texttt{edu.kit.pse17.go\_app.repositories.Repository} {\small 
\refdefined{edu.kit.pse17.go_app.repositories.Repository}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public abstract  {\bf  fetchData}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public abstract  {\bf  getUpdatedData}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public static void {\bf  receiveUpdatedData}()
}%end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.repositories.Repository}Klasse Repository}{
\hypertarget{edu.kit.pse17.go_app.repositories.Repository}{}\vskip .1in 
Die Klasse dient als Vermittler zwischen ViewModel und Laden von Daten Hier wird entschieden, wen man anspricht um bestimmte Daten zu laden\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public abstract class Repository
 extends java.lang.Object\end{lstlisting}
\subsubsection{Unterklassen}{GroupRepository\small{\refdefined{edu.kit.pse17.go_app.repositories.GroupRepository}}, GoRepository\small{\refdefined{edu.kit.pse17.go_app.repositories.GoRepository}}, UserRepository\small{\refdefined{edu.kit.pse17.go_app.repositories.UserRepository}}}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{Repository()}
\hypertarget{edu.kit.pse17.go_app.repositories.Repository()}{{\bf  Repository}\\}
\begin{lstlisting}[frame=none]
public Repository()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{fetchData()}
\hypertarget{edu.kit.pse17.go_app.repositories.Repository.fetchData()}{{\bf  fetchData}\\}
\begin{lstlisting}[frame=none]
public abstract <any> fetchData()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getUpdatedData()}
\hypertarget{edu.kit.pse17.go_app.repositories.Repository.getUpdatedData()}{{\bf  getUpdatedData}\\}
\begin{lstlisting}[frame=none]
public abstract <any> getUpdatedData()\end{lstlisting} %end signature
}%end item
\item{ 
\index{receiveUpdatedData()}
\hypertarget{edu.kit.pse17.go_app.repositories.Repository.receiveUpdatedData()}{{\bf  receiveUpdatedData}\\}
\begin{lstlisting}[frame=none]
public static void receiveUpdatedData()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.repositories.UserRepository}Klasse UserRepository}{
\hypertarget{edu.kit.pse17.go_app.repositories.UserRepository}{}\vskip .1in 
Dieses Repository verwaltet und vermittelt Datenanfragen und Datenaenderungen, die mit dem Benutzerkonto selbst verknuepfte Informationen betreffen. Im Gegensatz zu anderen Repositories spricht diese Klasse auch die SharedPreferences des Systems an.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class UserRepository
 extends edu.kit.pse17.go_app.repositories.Repository\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{UserRepository(TomcatRestApi, SharedPreferences, Executor)}
\hypertarget{edu.kit.pse17.go_app.repositories.UserRepository(edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi, SharedPreferences, java.util.concurrent.Executor)}{{\bf  UserRepository}\\}
\begin{lstlisting}[frame=none]
public UserRepository(edu.kit.pse17.go_app.serverCommunication.upstream.TomcatRestApi webService,SharedPreferences sharedPrefManager,java.util.concurrent.Executor executor)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{deleteUser(String)}
\hypertarget{edu.kit.pse17.go_app.repositories.UserRepository.deleteUser(java.lang.String)}{{\bf  deleteUser}\\}
\begin{lstlisting}[frame=none]
public void deleteUser(java.lang.String uid)\end{lstlisting} %end signature
}%end item
\item{ 
\index{fetchData()}
\hypertarget{edu.kit.pse17.go_app.repositories.UserRepository.fetchData()}{{\bf  fetchData}\\}
\begin{lstlisting}[frame=none]
public abstract <any> fetchData()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getUpdatedData()}
\hypertarget{edu.kit.pse17.go_app.repositories.UserRepository.getUpdatedData()}{{\bf  getUpdatedData}\\}
\begin{lstlisting}[frame=none]
public abstract <any> getUpdatedData()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{von Repository geerbte Methoden}{
\texttt{edu.kit.pse17.go\_app.repositories.Repository} {\small 
\refdefined{edu.kit.pse17.go_app.repositories.Repository}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public abstract  {\bf  fetchData}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public abstract  {\bf  getUpdatedData}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public static void {\bf  receiveUpdatedData}()
}%end signature
}%end item
\end{itemize}
}
}
}
\section{Package View}{

\subsection{\label{edu.kit.pse17.go_app.view.BaseActivity}Klasse BaseActivity}{
\hypertarget{edu.kit.pse17.go_app.view.BaseActivity}{}\vskip .1in 
Die Base-Activity ist Oberklasse fuer alle weiteren Activities und kuemmert sich um Funktionalitaet, die alle Activities gemeinsam haben. BaseActivity erbt von LifecycleActivty, was eine Lifecycle-Owner Klasse ist. Dies erlaubt es Objekte, die Lifecycle-Aware sind (z.B. LiveData-Objekten) den Lifecycle der Activity zu beobachten und je nach Zustand der Activity ein entsprechendes UI-Update zu triggern.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class BaseActivity
 extends LifecycleActivity\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{BaseActivity()}
\hypertarget{edu.kit.pse17.go_app.view.BaseActivity()}{{\bf  BaseActivity}\\}
\begin{lstlisting}[frame=none]
public BaseActivity()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.view.EditGoActivity}Klasse EditGoActivity}{
\hypertarget{edu.kit.pse17.go_app.view.EditGoActivity}{}\vskip .1in 
Die activity, die fuer GO-Verantwortlichen zugaenglich ist, wo man die Informationen eines GOs aendern kann.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class EditGoActivity
 extends java.lang.Object\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{EditGoActivity()}
\hypertarget{edu.kit.pse17.go_app.view.EditGoActivity()}{{\bf  EditGoActivity}\\}
\begin{lstlisting}[frame=none]
public EditGoActivity()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.view.EditGroupActivity}Klasse EditGroupActivity}{
\hypertarget{edu.kit.pse17.go_app.view.EditGroupActivity}{}\vskip .1in 
Activity die fuer den Gruppenadmins zugaenglich ist, wo man die Gruppendaten veraendern kann.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class EditGroupActivity
 extends java.lang.Object\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{EditGroupActivity()}
\hypertarget{edu.kit.pse17.go_app.view.EditGroupActivity()}{{\bf  EditGroupActivity}\\}
\begin{lstlisting}[frame=none]
public EditGroupActivity()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.view.GoDetailActivity}Klasse GoDetailActivity}{
\hypertarget{edu.kit.pse17.go_app.view.GoDetailActivity}{}\vskip .1in 
die Activity ist zusammen mit der Layout File go\_detail.xml Teil des Views, der dem user die Details eines Gos anzeigt. Die Activity ist hauptsaechlich fuer die Darstellung von Informationen zustaendig. Die einzige Datenmanipulation, die hier vorgenommen werden kann, ist die aenderung des Teilnahmestatus des Users.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GoDetailActivity
 extends edu.kit.pse17.go_app.view.BaseActivity\end{lstlisting}
\subsubsection{Unterklassen}{GoDetailActivityOwner\small{\refdefined{edu.kit.pse17.go_app.view.GoDetailActivityOwner}}}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GoDetailActivity()}
\hypertarget{edu.kit.pse17.go_app.view.GoDetailActivity()}{{\bf  GoDetailActivity}\\}
\begin{lstlisting}[frame=none]
public GoDetailActivity()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onCreate(Bundle)}
\hypertarget{edu.kit.pse17.go_app.view.GoDetailActivity.onCreate(Bundle)}{{\bf  onCreate}\\}
\begin{lstlisting}[frame=none]
protected void onCreate(Bundle savedInstanceState)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Lifecycle-Methode der Activity, die beim Erzeugen aufgreufen wird. Dem ContentView der App wird das richtige XML Layout zugewiesen und die Informationen die das ViewModel bereitstellt den Layout\_komponenten zur Darstellung uebergeben. Es die Livedata des ViewModels auf zum Beobachten registriert, um bei aenderungen die View updaten zu koennen.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{savedInstanceState} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.view.GoDetailActivityOwner}Klasse GoDetailActivityOwner}{
\hypertarget{edu.kit.pse17.go_app.view.GoDetailActivityOwner}{}\vskip .1in 
Die Klasse dekoriert dir Aktivity-Klasse "GoDetailActivity". Die Go-Detailansicht eines Go-Verantwortlichen unterscheidet dich von der Detailansicht eines "normalen" Teilnahemers nur in einer zusaetzlichen Schaltflaeche ("edit"), die geklickt werden kann, um die aenderungsansicht des GOs aufzurufen.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GoDetailActivityOwner
 extends edu.kit.pse17.go_app.view.GoDetailActivity\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GoDetailActivityOwner()}
\hypertarget{edu.kit.pse17.go_app.view.GoDetailActivityOwner()}{{\bf  GoDetailActivityOwner}\\}
\begin{lstlisting}[frame=none]
public GoDetailActivityOwner()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onCreate(Bundle)}
\hypertarget{edu.kit.pse17.go_app.view.GoDetailActivityOwner.onCreate(Bundle)}{{\bf  onCreate}\\}
\begin{lstlisting}[frame=none]
protected void onCreate(Bundle savedInstanceState)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.GoDetailActivity}{GoDetailActivity}{\small \refdefined{edu.kit.pse17.go_app.view.GoDetailActivity}} }

Lifecycle-Methode der Activity, die beim Erzeugen aufgreufen wird. Dem ContentView der App wird das richtige XML Layout zugewiesen und die Informationen die das ViewModel bereitstellt den Layout\_komponenten zur Darstellung uebergeben. Es die Livedata des ViewModels auf zum Beobachten registriert, um bei aenderungen die View updaten zu koennen.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{savedInstanceState} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Members inherited from class GoDetailActivity }{
\texttt{edu.kit.pse17.go\_app.view.GoDetailActivity} {\small 
\refdefined{edu.kit.pse17.go_app.view.GoDetailActivity}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{protected void {\bf  onCreate}(\texttt{Bundle} {\bf  savedInstanceState})
}%end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.view.GroupDetailActivity}Klasse GroupDetailActivity}{
\hypertarget{edu.kit.pse17.go_app.view.GroupDetailActivity}{}\vskip .1in 
die Activity ist zusammen mit der Layout File group\_details.xml Teil des Views, der dem user die Details eines Gruppe anzeigt. Die Activity ist hauptsaechlich fuer die Darstellung von Informationen zustaendig. Die einzige Datenmanipulation, die hier vorgenommen werden kann, ist die aenderung das Austreten des Users aus der Gruppe.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GroupDetailActivity
 extends edu.kit.pse17.go_app.view.BaseActivity implements edu.kit.pse17.go_app.view.recyclerView.OnListItemClicked\end{lstlisting}
\subsubsection{Unterklassen}{GroupDetailActivityOwner\small{\refdefined{edu.kit.pse17.go_app.view.GroupDetailActivityOwner}}}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GroupDetailActivity()}
\hypertarget{edu.kit.pse17.go_app.view.GroupDetailActivity()}{{\bf  GroupDetailActivity}\\}
\begin{lstlisting}[frame=none]
public GroupDetailActivity()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onCreate(Bundle)}
\hypertarget{edu.kit.pse17.go_app.view.GroupDetailActivity.onCreate(Bundle)}{{\bf  onCreate}\\}
\begin{lstlisting}[frame=none]
public void onCreate(Bundle savedInstanceState)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Lifecycle-Methode der Activity, die beim Erzeugen aufgreufen wird. Dem ContentView der App wird das richtige XML Layout zugewiesen und die Informationen die das ViewModel bereitstellt den Layout-Komponenten zur Darstellung uebergeben. Es die Livedata des ViewModels auf zum Beobachten registriert, um bei aenderungen die View updaten zu koennen.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{savedInstanceState} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{onItemClicked(int)}
\hypertarget{edu.kit.pse17.go_app.view.GroupDetailActivity.onItemClicked(int)}{{\bf  onItemClicked}\\}
\begin{lstlisting}[frame=none]
void onItemClicked(int position)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.recyclerView.OnListItemClicked}{recyclerView.OnListItemClicked}{\small \refdefined{edu.kit.pse17.go_app.view.recyclerView.OnListItemClicked}} }

fuehrt gewuenschte Aktion der implemetierenden Klasse aus, falls auf das ListItem an Position position geklickt wird
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{position} -- Position des ListItems, auf das geklickt wurde}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.view.GroupDetailActivityOwner}Klasse GroupDetailActivityOwner}{
\hypertarget{edu.kit.pse17.go_app.view.GroupDetailActivityOwner}{}\vskip .1in 
Klasse dekoriert die GroupDetailActivity und fuegt ihr die Admin-Funktionalitaeten hinzu. Diese bestehen aus zwei zusaetzlichen Schaltflaechen, die einerseits die aenderungsansicht der Gruppe aufrufen ("edit"), anderersetis gibt es eine zusaetzliche Schaltflaeche zum Hinzuguegen eiens neuen Gruppenmitglieds ("addMember")\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GroupDetailActivityOwner
 extends edu.kit.pse17.go_app.view.GroupDetailActivity\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GroupDetailActivityOwner()}
\hypertarget{edu.kit.pse17.go_app.view.GroupDetailActivityOwner()}{{\bf  GroupDetailActivityOwner}\\}
\begin{lstlisting}[frame=none]
public GroupDetailActivityOwner()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onCreate(Bundle)}
\hypertarget{edu.kit.pse17.go_app.view.GroupDetailActivityOwner.onCreate(Bundle)}{{\bf  onCreate}\\}
\begin{lstlisting}[frame=none]
public void onCreate(Bundle savedInstanceState)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.GroupDetailActivity}{GroupDetailActivity}{\small \refdefined{edu.kit.pse17.go_app.view.GroupDetailActivity}} }

Lifecycle-Methode der Activity, die beim Erzeugen aufgreufen wird. Dem ContentView der App wird das richtige XML Layout zugewiesen und die Informationen die das ViewModel bereitstellt den Layout-Komponenten zur Darstellung uebergeben. Es die Livedata des ViewModels auf zum Beobachten registriert, um bei aenderungen die View updaten zu koennen.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{savedInstanceState} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{von GroupDetailActivity vererbte Methoden und Feler}{
\texttt{edu.kit.pse17.go\_app.view.GroupDetailActivity} {\small 
\refdefined{edu.kit.pse17.go_app.view.GroupDetailActivity}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public void {\bf  onCreate}(\texttt{Bundle} {\bf  savedInstanceState})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public void {\bf  onItemClicked}(\texttt{int} {\bf  position})
}%end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.view.GroupListActivity}Klasse GroupListActivity}{
\hypertarget{edu.kit.pse17.go_app.view.GroupListActivity}{}\vskip .1in 
Hauptansicht der App. Zeigt alle Gruppen eines Benutzers in einer RecyclerView\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GroupListActivity
 extends edu.kit.pse17.go_app.view.BaseActivity implements edu.kit.pse17.go_app.view.recyclerView.OnListItemClicked\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GroupListActivity()}
\hypertarget{edu.kit.pse17.go_app.view.GroupListActivity()}{{\bf  GroupListActivity}\\}
\begin{lstlisting}[frame=none]
public GroupListActivity()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onClick(View)}
\hypertarget{edu.kit.pse17.go_app.view.GroupListActivity.onClick(View)}{{\bf  onClick}\\}
\begin{lstlisting}[frame=none]
public void onClick(View v)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

ClickListener fuer addGroupButton
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{v} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{onCreate(Bundle)}
\hypertarget{edu.kit.pse17.go_app.view.GroupListActivity.onCreate(Bundle)}{{\bf  onCreate}\\}
\begin{lstlisting}[frame=none]
protected void onCreate(Bundle savedInstanceState)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

RecyclerView und passender Listadapter werden erzeugt
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{savedInstanceState} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{onItemClicked(int)}
\hypertarget{edu.kit.pse17.go_app.view.GroupListActivity.onItemClicked(int)}{{\bf  onItemClicked}\\}
\begin{lstlisting}[frame=none]
public void onItemClicked(int position)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

ClickListener fuer RecyclerView-Elemente
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{position} -- Position des ListItems, auf das geklickt wurde}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{start(Activity, User)}
\hypertarget{edu.kit.pse17.go_app.view.GroupListActivity.start(Activity, edu.kit.pse17.go_app.model.entities.User)}{{\bf  start}\\}
\begin{lstlisting}[frame=none]
public static void start(Activity activity,edu.kit.pse17.go_app.model.entities.User user)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.view.InformationActivity}Klasse InformationActivity}{
\hypertarget{edu.kit.pse17.go_app.view.InformationActivity}{}\vskip .1in 
Diese Activity ist zustaendig fuer die Darstellung eines Informationstextes.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class InformationActivity
 extends edu.kit.pse17.go_app.view.BaseActivity\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{InformationActivity()}
\hypertarget{edu.kit.pse17.go_app.view.InformationActivity()}{{\bf  InformationActivity}\\}
\begin{lstlisting}[frame=none]
public InformationActivity()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.view.SettingsActivity}Klasse SettingsActivity}{
\hypertarget{edu.kit.pse17.go_app.view.SettingsActivity}{}\vskip .1in 
Die Aktivitaet stellt dem User ein Menue zur Verfuegung, in dem er verschiedende Einstellungsaenderungen vornehmen kann. Die Aufgabe der Aktivitaet ist dabei, dem Benutzer die View zur Verfuegung zu stellen, den User-input entgegenzunehmen und an die Eingabe an die entsprechenden Klassen weiterzuleiten.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class SettingsActivity
 extends edu.kit.pse17.go_app.view.BaseActivity\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{SettingsActivity()}
\hypertarget{edu.kit.pse17.go_app.view.SettingsActivity()}{{\bf  SettingsActivity}\\}
\begin{lstlisting}[frame=none]
public SettingsActivity()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onCreate(Bundle)}
\hypertarget{edu.kit.pse17.go_app.view.SettingsActivity.onCreate(Bundle)}{{\bf  onCreate}\\}
\begin{lstlisting}[frame=none]
protected void onCreate(Bundle savedInstanceState)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.view.SignInActivity}Klasse SignInActivity}{
\hypertarget{edu.kit.pse17.go_app.view.SignInActivity}{}\vskip .1in 
Die Klasse stellt die View fuer den LogIn- und SignIn-Prozess bereit.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class SignInActivity
 extends edu.kit.pse17.go_app.view.BaseActivity\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{SignInActivity()}
\hypertarget{edu.kit.pse17.go_app.view.SignInActivity()}{{\bf  SignInActivity}\\}
\begin{lstlisting}[frame=none]
public SignInActivity()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onActivityResult(int, int, Intent)}
\hypertarget{edu.kit.pse17.go_app.view.SignInActivity.onActivityResult(int, int, Intent)}{{\bf  onActivityResult}\\}
\begin{lstlisting}[frame=none]
protected void onActivityResult(int requestCode,int resultCode,Intent data)\end{lstlisting} %end signature
}%end item
\item{ 
\index{onClick(View)}
\hypertarget{edu.kit.pse17.go_app.view.SignInActivity.onClick(View)}{{\bf  onClick}\\}
\begin{lstlisting}[frame=none]
public void onClick(View v)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Click-Listener, der auf Klicken des Signin Buttons wartet --\textgreater  SignIn wird gestartet
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{v} -- geklickter View}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{onCreate(Bundle)}
\hypertarget{edu.kit.pse17.go_app.view.SignInActivity.onCreate(Bundle)}{{\bf  onCreate}\\}
\begin{lstlisting}[frame=none]
protected void onCreate(Bundle savedInstanceState)\end{lstlisting} %end signature
}%end item
\item{ 
\index{onResume()}
\hypertarget{edu.kit.pse17.go_app.view.SignInActivity.onResume()}{{\bf  onResume}\\}
\begin{lstlisting}[frame=none]
protected void onResume()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
}
\section{Package RecyclerView}{
\label{edu.kit.pse17.go_app.view.recyclerView}\hypertarget{edu.kit.pse17.go_app.view.recyclerView}{}

\subsection{\label{edu.kit.pse17.go_app.view.recyclerView.OnListItemClicked}Interface OnListItemClicked}{
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.OnListItemClicked}{}\vskip .1in 
ClickListener fuer die ListItems eines RecyclerViews Created by tina on 17.06.17.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public interface OnListItemClicked
\end{lstlisting}
\subsubsection{Subinterfaces}{GroupDetailActivityOwner\small{\refdefined{edu.kit.pse17.go_app.view.GroupDetailActivityOwner}}, GroupDetailActivity\small{\refdefined{edu.kit.pse17.go_app.view.GroupDetailActivity}}, GroupListActivity\small{\refdefined{edu.kit.pse17.go_app.view.GroupListActivity}}}
\subsubsection{Klassen, die das Interface implementieren}{GroupDetailActivity\small{\refdefined{edu.kit.pse17.go_app.view.GroupDetailActivity}}, GroupListActivity\small{\refdefined{edu.kit.pse17.go_app.view.GroupListActivity}}}

\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onItemClicked(int)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.OnListItemClicked.onItemClicked(int)}{{\bf  onItemClicked}\\}
\begin{lstlisting}[frame=none]
void onItemClicked(int position)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

fuehrt gewuenschte Aktion der implemetierenden Klasse aus, falls auf das ListItem an Position position geklickt wird
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{position} -- Position des ListItems, auf das geklickt wurde}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.view.recyclerView.ListAdapter}Klasse ListAdapter}{
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.ListAdapter}{}\vskip .1in 
Abstrakte Klasse, die Schablone fuer konkrete Adapter-Klassen bietet. Unterklassen muessen die Methode setLayout() implementieren, um dem Adapter ein passendes XML-Layout zuzuweisen Created by tina on 17.06.17.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class ListAdapter
 extends <any>\end{lstlisting}

\subsubsection{statische Felder}{
\begin{itemize}
\item{
\index{data}
\label{edu.kit.pse17.go_app.view.recyclerView.ListAdapter.data}\hypertarget{edu.kit.pse17.go_app.view.recyclerView.ListAdapter.data}{\texttt{protected java.util.List\ {\bf  data}}
}
\begin{itemize}
\item{\vskip -.9ex 
ListItems, die in dem RecyclerView angezeigt werden sollen}
\end{itemize}
}
\item{
\index{onListItemClicked}
\label{edu.kit.pse17.go_app.view.recyclerView.ListAdapter.onListItemClicked}\hypertarget{edu.kit.pse17.go_app.view.recyclerView.ListAdapter.onListItemClicked}{\texttt{protected final OnListItemClicked\ {\bf  onListItemClicked}}
}
\begin{itemize}
\item{\vskip -.9ex 
ClickListener fuer die Listenelemente}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{ListAdapter(List, OnListItemClicked)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.ListAdapter(java.util.List, edu.kit.pse17.go_app.view.recyclerView.OnListItemClicked)}{{\bf  ListAdapter}\\}
\begin{lstlisting}[frame=none]
public ListAdapter(java.util.List data,OnListItemClicked onListItemClicked)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Konstruktor
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{data} -- ListItems, die in dem RecyclerView angezeigt werden sollen}
   \item{
\texttt{onListItemClicked} -- ClickListener fuer die Listenelemente}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{addItem(ListItem)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.ListAdapter.addItem(edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem)}{{\bf  addItem}\\}
\begin{lstlisting}[frame=none]
public void addItem(listItems.ListItem item)\end{lstlisting} %end signature
}%end item
\item{ 
\index{getItem(int)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.ListAdapter.getItem(int)}{{\bf  getItem}\\}
\begin{lstlisting}[frame=none]
public listItems.ListItem getItem(int position)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

gibt das ListItem an der angegebenen Position zurueck
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{position} -- Listenposition des gewuenschten ListItems}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
ListItem, an der angegebenen Position aus der Liste data 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getItemCount()}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.ListAdapter.getItemCount()}{{\bf  getItemCount}\\}
\begin{lstlisting}[frame=none]
public int getItemCount()\end{lstlisting} %end signature
}%end item
\item{ 
\index{onBindViewHolder(ListViewHolder, int)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.ListAdapter.onBindViewHolder(edu.kit.pse17.go_app.view.recyclerView.ListViewHolder, int)}{{\bf  onBindViewHolder}\\}
\begin{lstlisting}[frame=none]
public void onBindViewHolder(ListViewHolder holder,int position)\end{lstlisting} %end signature
}%end item
\item{ 
\index{onCreateViewHolder(ViewGroup, int)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.ListAdapter.onCreateViewHolder(ViewGroup, int)}{{\bf  onCreateViewHolder}\\}
\begin{lstlisting}[frame=none]
public ListViewHolder onCreateViewHolder(ViewGroup parent,int viewType)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Schablonenmethode: erzeugt ListViewHolder, dem das passende XML layout zugewiesen wird wird aufgerufen, wenn ein RecyclerView einen neuen ViewHolder braucht, um ein ListItem zu repraesentieren
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{parent} -- Viewgroup, zu der der neue View hinzugefuegt werden soll}
   \item{
\texttt{viewType} -- viewType des neuen Views}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
neuer ViewHolder des gewuenschten Typs 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.view.recyclerView.ListViewHolder}Klasse ListViewHolder}{
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.ListViewHolder}{}\vskip .1in 
Die Klasse erzeugt ViewHolder-Objekte, die die Datenobjekt fuer die RecyclerView enthalten Created by tina on 17.06.17.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class ListViewHolder
 extends ViewHolder\end{lstlisting}

\subsubsection{statische Felder}{
\begin{itemize}
\item{
\index{title}
\label{edu.kit.pse17.go_app.view.recyclerView.ListViewHolder.title}\hypertarget{edu.kit.pse17.go_app.view.recyclerView.ListViewHolder.title}{\texttt{public TextView\ {\bf  title}}
}
\begin{itemize}
\item{\vskip -.9ex 
Titel des Items}
\end{itemize}
}
\item{
\index{subtitle}
\label{edu.kit.pse17.go_app.view.recyclerView.ListViewHolder.subtitle}\hypertarget{edu.kit.pse17.go_app.view.recyclerView.ListViewHolder.subtitle}{\texttt{public TextView\ {\bf  subtitle}}
}
\begin{itemize}
\item{\vskip -.9ex 
Untertitel des Items}
\end{itemize}
}
\item{
\index{icon}
\label{edu.kit.pse17.go_app.view.recyclerView.ListViewHolder.icon}\hypertarget{edu.kit.pse17.go_app.view.recyclerView.ListViewHolder.icon}{\texttt{public ImageView\ {\bf  icon}}
}
\begin{itemize}
\item{\vskip -.9ex 
Icon, das zum Item angezeigt werden soll}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{ListViewHolder(View)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.ListViewHolder(View)}{{\bf  ListViewHolder}\\}
\begin{lstlisting}[frame=none]
public ListViewHolder(View itemView)\end{lstlisting} %end signature
}%end item
\item{ 
\index{ListViewHolder(View, OnListItemClicked)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.ListViewHolder(View, edu.kit.pse17.go_app.view.recyclerView.OnListItemClicked)}{{\bf  ListViewHolder}\\}
\begin{lstlisting}[frame=none]
public ListViewHolder(View itemView,OnListItemClicked onListItemClicked)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Konstruktor
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{itemView} -- View, in der die Items angezeigt werden sollen}
   \item{
\texttt{onListItemClicked} -- ClickListener fuer ListItems}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{onClick(View)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.ListViewHolder.onClick(View)}{{\bf  onClick}\\}
\begin{lstlisting}[frame=none]
public void onClick(View v)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
}
\section{Package RecyclerView.listItems}{
\label{edu.kit.pse17.go_app.view.recyclerView.listItems}\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems}{}

\subsection{\label{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}Interface ListItem}{
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}{}\vskip .1in 
Interface fuer ListItems, die die Datenobjekt in den verschiedenen RecyclerViews der App sind Created by tina on 18.06.17.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public interface ListItem
\end{lstlisting}
\subsubsection{Subinterfaces}{GOListItem\small{\refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.GOListItem}}, UserMailListItem\small{\refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.UserMailListItem}}, UserStatusListItem\small{\refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.UserStatusListItem}}, GroupListItem\small{\refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.GroupListItem}}}
\subsubsection{Klassen, die das Interface implementieren}{GOListItem\small{\refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.GOListItem}}, UserMailListItem\small{\refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.UserMailListItem}}, UserStatusListItem\small{\refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.UserStatusListItem}}, GroupListItem\small{\refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.GroupListItem}}}

\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getIcon()}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem.getIcon()}{{\bf  getIcon}\\}
\begin{lstlisting}[frame=none]
Icon getIcon()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

getter-Methode fuer Icon des ListItems
}
\item{{\bf  Returns} -- 
Icon des Datenobjekts 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getSubtitle()}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem.getSubtitle()}{{\bf  getSubtitle}\\}
\begin{lstlisting}[frame=none]
java.lang.String getSubtitle()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

getter-Methode fuer Untertitel des ListItems. Muss ggfs. erst generiert werden, die Information wird als Datentyp T im Objekt gespeichert
}
\item{{\bf  Returns} -- 
Untertitel des Datenobjekts 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getTitle()}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem.getTitle()}{{\bf  getTitle}\\}
\begin{lstlisting}[frame=none]
java.lang.String getTitle()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

getter-Methode fuer ueberschrift des ListItems
}
\item{{\bf  Returns} -- 
Titel des Datenobjekts 
}%end item
\end{itemize}
}%end item
\item{ 
\index{setIcon(Icon)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem.setIcon(Icon)}{{\bf  setIcon}\\}
\begin{lstlisting}[frame=none]
void setIcon(Icon icon)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

setter-Methode fuer icon des ListItems
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{icon} -- das neue Icon}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{setSubtitle(T)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem.setSubtitle(T)}{{\bf  setSubtitle}\\}
\begin{lstlisting}[frame=none]
void setSubtitle(java.lang.Object t)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

setter-Methode fuer Untertitel. Methode erwartet Datentyp T, der Untertitel wird dann innerhalb der Klasse als String-Objekt erzeugt
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{t} -- Objekt/Datentyp, aus dem Untertitel erzeugt wird}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{setTitle(String)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem.setTitle(java.lang.String)}{{\bf  setTitle}\\}
\begin{lstlisting}[frame=none]
void setTitle(java.lang.String title)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

setter-Methode fuer ueberschrift des ListItems
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{title} -- der neue Titel}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.view.recyclerView.listItems.GOListItem}Klasse GOListItem}{
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.GOListItem}{}\vskip .1in 
Diese Klasse repraesentiert ListItems, die Informationen ueber ein Go in einem RecyclerView darstellen sollen Created by tina on 17.06.17.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GOListItem
 extends java.lang.Object implements ListItem\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GOListItem(Go)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.GOListItem(edu.kit.pse17.go_app.model.entities.Go)}{{\bf  GOListItem}\\}
\begin{lstlisting}[frame=none]
public GOListItem(edu.kit.pse17.go_app.model.entities.Go go)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Konstruktor
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{go} -- Go-Objekt, das von dem ListItem repraesentiert werden soll}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{GOListItem(String, Date, Icon)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.GOListItem(java.lang.String, java.util.Date, Icon)}{{\bf  GOListItem}\\}
\begin{lstlisting}[frame=none]
public GOListItem(java.lang.String name,java.util.Date start,Icon icon)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Konstruktor
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{name} -- Go-Bezeichnung}
   \item{
\texttt{start} -- Startzeitpunkt des GOs}
   \item{
\texttt{icon} -- Go-Icon}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getIcon()}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.GOListItem.getIcon()}{{\bf  getIcon}\\}
\begin{lstlisting}[frame=none]
Icon getIcon()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}{ListItem}{\small \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}} }

getter-Methode fuer Icon des ListItems
}
\item{{\bf  Returns} -- 
Icon des Datenobjekts 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getSubtitle()}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.GOListItem.getSubtitle()}{{\bf  getSubtitle}\\}
\begin{lstlisting}[frame=none]
java.lang.String getSubtitle()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}{ListItem}{\small \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}} }

getter-Methode fuer Untertitel des ListItems. Muss ggfs. erst generiert werden, die Information wird als Datentyp T im Objekt gespeichert
}
\item{{\bf  Returns} -- 
Untertitel des Datenobjekts 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getTitle()}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.GOListItem.getTitle()}{{\bf  getTitle}\\}
\begin{lstlisting}[frame=none]
java.lang.String getTitle()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}{ListItem}{\small \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}} }

getter-Methode fuer ueberschrift des ListItems
}
\item{{\bf  Returns} -- 
Titel des Datenobjekts 
}%end item
\end{itemize}
}%end item
\item{ 
\index{setIcon(Icon)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.GOListItem.setIcon(Icon)}{{\bf  setIcon}\\}
\begin{lstlisting}[frame=none]
void setIcon(Icon icon)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}{ListItem}{\small \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}} }

setter-Methode fuer icon des ListItems
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{icon} -- das neue Icon}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{setSubtitle(Date)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.GOListItem.setSubtitle(java.util.Date)}{{\bf  setSubtitle}\\}
\begin{lstlisting}[frame=none]
public void setSubtitle(java.util.Date date)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setTitle(String)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.GOListItem.setTitle(java.lang.String)}{{\bf  setTitle}\\}
\begin{lstlisting}[frame=none]
void setTitle(java.lang.String title)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}{ListItem}{\small \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}} }

setter-Methode fuer ueberschrift des ListItems
}
\item{
{\bf  Parameters}

  \begin{itemize}
   \item{
\texttt{title} -- der neue Titel}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.view.recyclerView.listItems.GroupListItem}Klasse GroupListItem}{
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.GroupListItem}{}\vskip .1in 
Diese Klasse repraesentiert ListItems, die Informationen ueber eine Gruppe in einem RecyclerView darstellen sollen Created by tina on 17.06.17.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GroupListItem
 extends java.lang.Object implements ListItem\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GroupListItem(Group)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.GroupListItem(edu.kit.pse17.go_app.model.entities.Group)}{{\bf  GroupListItem}\\}
\begin{lstlisting}[frame=none]
public GroupListItem(edu.kit.pse17.go_app.model.entities.Group group)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Konstruktor
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{group} -- gruppen-Objekt, das von dem ListItem repraesentiert werden soll}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{GroupListItem(String, int, Icon)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.GroupListItem(java.lang.String, int, Icon)}{{\bf  GroupListItem}\\}
\begin{lstlisting}[frame=none]
public GroupListItem(java.lang.String title,int memberCount,Icon icon)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Konstruktor
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{title} -- Gruppenname}
   \item{
\texttt{memberCount} -- Anzahl der Gruppenmitglieder}
   \item{
\texttt{icon} -- Gruppenbild}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getIcon()}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.GroupListItem.getIcon()}{{\bf  getIcon}\\}
\begin{lstlisting}[frame=none]
Icon getIcon()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}{ListItem}{\small \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}} }

getter-Methode fuer Icon des ListItems
}
\item{{\bf  Returns} -- 
Icon des Datenobjekts 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getSubtitle()}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.GroupListItem.getSubtitle()}{{\bf  getSubtitle}\\}
\begin{lstlisting}[frame=none]
java.lang.String getSubtitle()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}{ListItem}{\small \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}} }

getter-Methode fuer Untertitel des ListItems. Muss ggfs. erst generiert werden, die Information wird als Datentyp T im Objekt gespeichert
}
\item{{\bf  Returns} -- 
Untertitel des Datenobjekts 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getTitle()}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.GroupListItem.getTitle()}{{\bf  getTitle}\\}
\begin{lstlisting}[frame=none]
java.lang.String getTitle()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}{ListItem}{\small \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}} }

getter-Methode fuer ueberschrift des ListItems
}
\item{{\bf  Returns} -- 
Titel des Datenobjekts 
}%end item
\end{itemize}
}%end item
\item{ 
\index{setIcon(Icon)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.GroupListItem.setIcon(Icon)}{{\bf  setIcon}\\}
\begin{lstlisting}[frame=none]
void setIcon(Icon icon)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}{ListItem}{\small \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}} }

setter-Methode fuer icon des ListItems
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{icon} -- das neue Icon}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{setSubtitle(Integer)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.GroupListItem.setSubtitle(java.lang.Integer)}{{\bf  setSubtitle}\\}
\begin{lstlisting}[frame=none]
public void setSubtitle(java.lang.Integer memberCount)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setTitle(String)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.GroupListItem.setTitle(java.lang.String)}{{\bf  setTitle}\\}
\begin{lstlisting}[frame=none]
void setTitle(java.lang.String title)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}{ListItem}{\small \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}} }

setter-Methode fuer ueberschrift des ListItems
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{title} -- der neue Titel}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.view.recyclerView.listItems.UserMailListItem}Klasse UserMailListItem}{
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.UserMailListItem}{}\vskip .1in 
Diese Klasse repraesentiert ListItems, die Informationen ueber einen User in einem RecyclerView darstellen sollen Created by tina on 19.06.17.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class UserMailListItem
 extends java.lang.Object implements ListItem\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{UserMailListItem(String, String, Icon)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.UserMailListItem(java.lang.String, java.lang.String, Icon)}{{\bf  UserMailListItem}\\}
\begin{lstlisting}[frame=none]
public UserMailListItem(java.lang.String title,java.lang.String email,Icon icon)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Konstruktor
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{title} -- Benutzername}
   \item{
\texttt{email} -- EMail-Adresse, die zur Anmeldung verwendet wurde}
   \item{
\texttt{icon} -- Profilbild}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{UserMailListItem(User)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.UserMailListItem(edu.kit.pse17.go_app.model.entities.User)}{{\bf  UserMailListItem}\\}
\begin{lstlisting}[frame=none]
public UserMailListItem(edu.kit.pse17.go_app.model.entities.User user)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Konstruktor
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{user} -- Das User-Objekt, das von dem ListItem repraesentiert werden soll}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getIcon()}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.UserMailListItem.getIcon()}{{\bf  getIcon}\\}
\begin{lstlisting}[frame=none]
Icon getIcon()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}{ListItem}{\small \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}} }

getter-Methode fuer Icon des ListItems
}
\item{{\bf  Returns} -- 
Icon des Datenobjekts 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getSubtitle()}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.UserMailListItem.getSubtitle()}{{\bf  getSubtitle}\\}
\begin{lstlisting}[frame=none]
java.lang.String getSubtitle()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}{ListItem}{\small \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}} }

getter-Methode fuer Untertitel des ListItems. Muss ggfs. erst generiert werden, die Information wird als Datentyp T im Objekt gespeichert
}
\item{{\bf  Returns} -- 
Untertitel des Datenobjekts 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getTitle()}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.UserMailListItem.getTitle()}{{\bf  getTitle}\\}
\begin{lstlisting}[frame=none]
java.lang.String getTitle()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}{ListItem}{\small \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}} }

getter-Methode fuer ueberschrift des ListItems
}
\item{{\bf  Returns} -- 
Titel des Datenobjekts 
}%end item
\end{itemize}
}%end item
\item{ 
\index{setIcon(Icon)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.UserMailListItem.setIcon(Icon)}{{\bf  setIcon}\\}
\begin{lstlisting}[frame=none]
void setIcon(Icon icon)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}{ListItem}{\small \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}} }

setter-Methode fuer icon des ListItems
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{icon} -- das neue Icon}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{setSubtitle(String)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.UserMailListItem.setSubtitle(java.lang.String)}{{\bf  setSubtitle}\\}
\begin{lstlisting}[frame=none]
public void setSubtitle(java.lang.String s)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setTitle(String)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.UserMailListItem.setTitle(java.lang.String)}{{\bf  setTitle}\\}
\begin{lstlisting}[frame=none]
void setTitle(java.lang.String title)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}{ListItem}{\small \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}} }

setter-Methode fuer ueberschrift des ListItems
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{title} -- der neue Titel}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.view.recyclerView.listItems.UserStatusListItem}Klasse UserStatusListItem}{
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.UserStatusListItem}{}\vskip .1in 
Diese Klasse repraesentiert ListItems, die Informationen ueber einen User in einem RecyclerView darstellen sollen Created by tina on 19.06.17.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class UserStatusListItem
 extends java.lang.Object implements ListItem\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{UserStatusListItem(String, Status, Icon)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.UserStatusListItem(java.lang.String, edu.kit.pse17.go_app.model.Status, Icon)}{{\bf  UserStatusListItem}\\}
\begin{lstlisting}[frame=none]
public UserStatusListItem(java.lang.String title,edu.kit.pse17.go_app.model.Status status,Icon icon)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Konstruktor
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{title} -- Benutzername}
   \item{
\texttt{status} -- Status des Users}
   \item{
\texttt{icon} -- Profilbild}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{UserStatusListItem(User, Go)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.UserStatusListItem(edu.kit.pse17.go_app.model.entities.User, edu.kit.pse17.go_app.model.entities.Go)}{{\bf  UserStatusListItem}\\}
\begin{lstlisting}[frame=none]
public UserStatusListItem(edu.kit.pse17.go_app.model.entities.User user,edu.kit.pse17.go_app.model.entities.Go go)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getIcon()}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.UserStatusListItem.getIcon()}{{\bf  getIcon}\\}
\begin{lstlisting}[frame=none]
Icon getIcon()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}{ListItem}{\small \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}} }

getter-Methode fuer Icon des ListItems
}
\item{{\bf  Returns} -- 
Icon des Datenobjekts 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getSubtitle()}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.UserStatusListItem.getSubtitle()}{{\bf  getSubtitle}\\}
\begin{lstlisting}[frame=none]
java.lang.String getSubtitle()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}{ListItem}{\small \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}} }

getter-Methode fuer Untertitel des ListItems. Muss ggfs. erst generiert werden, die Information wird als Datentyp T im Objekt gespeichert
}
\item{{\bf  Returns} -- 
Untertitel des Datenobjekts 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getTitle()}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.UserStatusListItem.getTitle()}{{\bf  getTitle}\\}
\begin{lstlisting}[frame=none]
java.lang.String getTitle()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}{ListItem}{\small \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}} }

getter-Methode fuer ueberschrift des ListItems
}
\item{{\bf  Returns} -- 
Titel des Datenobjekts 
}%end item
\end{itemize}
}%end item
\item{ 
\index{setIcon(Icon)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.UserStatusListItem.setIcon(Icon)}{{\bf  setIcon}\\}
\begin{lstlisting}[frame=none]
void setIcon(Icon icon)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}{ListItem}{\small \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}} }

setter-Methode fuer icon des ListItems
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{icon} -- das neue Icon}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{setSubtitle(Status)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.UserStatusListItem.setSubtitle(edu.kit.pse17.go_app.model.Status)}{{\bf  setSubtitle}\\}
\begin{lstlisting}[frame=none]
public void setSubtitle(edu.kit.pse17.go_app.model.Status s)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setTitle(String)}
\hypertarget{edu.kit.pse17.go_app.view.recyclerView.listItems.UserStatusListItem.setTitle(java.lang.String)}{{\bf  setTitle}\\}
\begin{lstlisting}[frame=none]
void setTitle(java.lang.String title)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}{ListItem}{\small \refdefined{edu.kit.pse17.go_app.view.recyclerView.listItems.ListItem}} }

setter-Methode fuer ueberschrift des ListItems
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{title} -- der neue Titel}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
}
\newpage

\section{Klassenübersicht - Server}

% ------- textdoclet_include/intro.tex end

\thispagestyle{empty}
\subsection*{Classes}
{\raggedright
\hspace{0.0cm} $\bullet$ java.lang.Object {\tiny \refdefined{java.lang.Object}} \\
\hspace{1.0cm} $\bullet$ ClientCommunication.Downstream.FcmClient {\tiny \refdefined{edu.kit.pse17.go_app.ClientCommunication.Downstream.FcmClient}} \\
\hspace{1.0cm} $\bullet$ ClientCommunication.Upstream.GoRestController {\tiny \refdefined{edu.kit.pse17.go_app.ClientCommunication.Upstream.GoRestController}} \\
\hspace{1.0cm} $\bullet$ ClientCommunication.Upstream.GroupRestController {\tiny \refdefined{edu.kit.pse17.go_app.ClientCommunication.Upstream.GroupRestController}} \\
\hspace{1.0cm} $\bullet$ ClientCommunication.Upstream.UserRestController {\tiny \refdefined{edu.kit.pse17.go_app.ClientCommunication.Upstream.UserRestController}} \\
\hspace{1.0cm} $\bullet$ Main {\tiny \refdefined{edu.kit.pse17.go_app.Main}} \\
\hspace{1.0cm} $\bullet$ PersistenceLayer.GoEntity {\tiny \refdefined{edu.kit.pse17.go_app.PersistenceLayer.GoEntity}} \\
\hspace{1.0cm} $\bullet$ PersistenceLayer.GroupEntity {\tiny \refdefined{edu.kit.pse17.go_app.PersistenceLayer.GroupEntity}} \\
\hspace{1.0cm} $\bullet$ PersistenceLayer.UserEntity {\tiny \refdefined{edu.kit.pse17.go_app.PersistenceLayer.UserEntity}} \\
\hspace{1.0cm} $\bullet$ PersistenceLayer.daos.GoDaoImp {\tiny \refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDaoImp}} \\
\hspace{1.0cm} $\bullet$ PersistenceLayer.daos.GroupDaoImp {\tiny \refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDaoImp}} \\
\hspace{1.0cm} $\bullet$ PersistenceLayer.daos.UserDaoImp {\tiny \refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp}} \\
\hspace{1.0cm} $\bullet$ ServiceLayer.Cluster {\tiny \refdefined{edu.kit.pse17.go_app.ServiceLayer.Cluster}} \\
\hspace{1.0cm} $\bullet$ ServiceLayer.EntitiyRemovedObserver {\tiny \refdefined{edu.kit.pse17.go_app.ServiceLayer.EntitiyRemovedObserver}} \\
\hspace{1.0cm} $\bullet$ ServiceLayer.EntityAddedObserver {\tiny \refdefined{edu.kit.pse17.go_app.ServiceLayer.EntityAddedObserver}} \\
\hspace{1.0cm} $\bullet$ ServiceLayer.EntityChangedObserver {\tiny \refdefined{edu.kit.pse17.go_app.ServiceLayer.EntityChangedObserver}} \\
\hspace{1.0cm} $\bullet$ ServiceLayer.GoClusterStrategy {\tiny \refdefined{edu.kit.pse17.go_app.ServiceLayer.GoClusterStrategy}} \\
\hspace{1.0cm} $\bullet$ ServiceLayer.LocationService {\tiny \refdefined{edu.kit.pse17.go_app.ServiceLayer.LocationService}} \\
\hspace{1.0cm} $\bullet$ ServiceLayer.UserLocation {\tiny \refdefined{edu.kit.pse17.go_app.ServiceLayer.UserLocation}} \\
\hspace{1.0cm} $\bullet$ java.lang.Enum {\tiny \refdefined{java.lang.Enum}} \\
\hspace{2.0cm} $\bullet$ ClientCommunication.Downstream.EventArg {\tiny \refdefined{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg}} \\
\hspace{2.0cm} $\bullet$ PersistenceLayer.Status {\tiny \refdefined{edu.kit.pse17.go_app.PersistenceLayer.Status}} \\
}
\subsection*{Interfaces}
\hspace{0.0cm} $\bullet$ PersistenceLayer.daos.AbstractDao {\tiny \refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.AbstractDao}} \\
\hspace{0.0cm} $\bullet$ PersistenceLayer.daos.GoDao {\tiny \refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDao}} \\
\hspace{0.0cm} $\bullet$ PersistenceLayer.daos.GroupDao {\tiny \refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDao}} \\
\hspace{0.0cm} $\bullet$ PersistenceLayer.daos.UserDao {\tiny \refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDao}} \\
\hspace{0.0cm} $\bullet$ ServiceLayer.ClusterStrategy {\tiny \refdefined{edu.kit.pse17.go_app.ServiceLayer.ClusterStrategy}} \\
\hspace{0.0cm} $\bullet$ ServiceLayer.Observable {\tiny \refdefined{edu.kit.pse17.go_app.ServiceLayer.Observable}} \\
\hspace{0.0cm} $\bullet$ ServiceLayer.Observer {\tiny \refdefined{edu.kit.pse17.go_app.ServiceLayer.Observer}} \\

\section{Package PersistenceLayer}{
\label{edu.kit.pse17.go_app.PersistenceLayer}\hypertarget{edu.kit.pse17.go_app.PersistenceLayer}{}
\hskip -.05in
\hbox to \hsize{\textit{ Package Inhalt\hfil Page}}
\vskip .13in
\hbox{{\bf  Klassen}}
\entityintro{GoEntity}{edu.kit.pse17.go_app.PersistenceLayer.GoEntity}{Dies ist eine Entity Klasse.}
\entityintro{GroupEntity}{edu.kit.pse17.go_app.PersistenceLayer.GroupEntity}{Dies ist eine Entity Klasse.}
\entityintro{Status}{edu.kit.pse17.go_app.PersistenceLayer.Status}{Dieses Enum definiert die verschiedenen Teilnahmestatus, die ein Benutzer in einem GO innehaben kann.}
\entityintro{UserEntity}{edu.kit.pse17.go_app.PersistenceLayer.UserEntity}{Dies ist eine Entity Klasse.}
\vskip .1in
\vskip .1in
\subsection{\label{edu.kit.pse17.go_app.PersistenceLayer.GoEntity}Klasse GoEntity}{
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity}{}\vskip .1in 
Dies ist eine Entity Klasse. Sie wird von dem Framework Hibernate dazu verwendet, POJOS auf Tupel in einer Datenbank zu mappen. Wie das Mapping geschieht ist in dieser Klasse durch Annotations festgelegt. Der Rest der Anwendung kann somit überall mit Java-Objekten hantieren und muss sich nicht um die konkrete Implementierung der Datenbank kümmern. Der Zugriff auf die Datenbank erfolgt nicht in dieser Klasse, sondern nur über eine DAO Klasse, die das Interface GoDao implementiert. Zusätzlich dient diese Klasse als Vorlage des Frameworks Gson zum Parsen von JSON-Objekten, die von der REST API empfangen und gesendet werden. Die Attribute der Klasse bestimmen dabei die Struktur des JSON-Objekts.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GoEntity
 extends java.lang.Object\end{lstlisting}

\subsubsection{Attribute}{
\begin{verse}
{{\bf private long id}} Eine global eindeutige Nummer, anhand derer ein Go-Objekt eindeutig identifiziert werden kann. Die ID ist eine positive ganze Zahl im Wertebereich des Datentyps long. Nach Erzeugung des Objekts kann sie bis zu seiner Zerstörung nicht verändert werden.\\[0.5em]

{{\bf private long groupId}} Die ID der Gruppe, in der dieses GO angelegt wurde. Es muss sich dabei um eine gültige Gruppen-ID handeln. Nach Erzeugung der Entity ist der Wert dieser Variable nicht mehr veränderbar.\\[0.5em]

{{\bf private String owner}} Die userId des Benutzer der das GO erstellt hat und somit der Go-Verantwortliche ist. Es muss sich dabei um eine gültige UserId handeln. Nach Erzeugung der Entity ist der Wert dieser Variable nicht mehr veränderbar.\\[0.5em]

{{\bf private String name}} Der Name des GOs. Dieser muss nicht eindeutig sein. Es handelt sich dabei um einen String, der weniger als 50 Zeichen enthält. Der Name eines GOs kann nachträglich (nach Erzeugung des Objekts) geändert werden, es sind entsprechende Methoden zu implementieren. Generiert wird die Id automatisch bei der Persistierung des Entity-Objekts in der Datenbank. Dadurch ist die Eindeutigkeit der ID garantiert.\\[0.5em]

{{\bf private String description}} Eine textuelle Ebschreibung des GOs. Diese muss nicht eindeutig sein.
     Es handelt sich dabei um einen String, der weniger als 140 Zeichen enthält.
     Die Beschreibung eines GOs kann nachträglich (nach Erzeugung des Objekts) geändert werden, es sind entsprechende Methoden zu implementieren.\\[0.5em]
     
{{\bf private Date start}} Der Startzeitpunkt des GOs. Er bestimmt ab wann die Standortverfolgung bei einem GO gestartet wird. Dabei darf der Zeitpunkt
      bei der Zuweisung der Variable nicht in der Vergangenheit befinden.
      Der Startzeitpunkt eines GOs kann nachträglich (nach Erzeugung des Objekts) geändert werden, es sind entsprechende Methoden zu implementieren.\\[0.5em]
      
{{\bf private Date end}} Der Endzeitpunkt des GOs. Er bestimmt ab wann die Standortverfolgung bei einem GO gestoppt wird. Dabei darf der Zeitpunkt
      nie vor dem Startzeitpunkt befinden.
     
     Der Endzeitpunkt eines GOs kann nachträglich (nach Erzeugung des Objekts) geändert werden, es sind entsprechende Methoden zu implementieren.\\[0.5em]
     
{{\bf private long lat}} Falls es einen Zielort für das GO gibt, wird in diesem Feld der geografische Breitengrad des Zielorts gespeichert. Der Wert muss als Breitengrad interpretierbar sein,
     muss also zwischen +90 und -90 liegen.
     Wurde kein Zielort für das GO bestimmt, kann der Wert dieses Feldes auch null sein. Der Wert kann nachträglich (nach Erzeugung des Objekts) geändert werden, es sind entsprechende Methoden zu implementieren.\\[0.5em]
     
{{\bf private long lon}} Falls es einen Zielort für das GO gibt, wird in diesem Feld der geografische Längengrad des Zielorts gespeichert. Der Wert muss als Längengrad interpretierbar sein, muss also zwischen +180 und -180 liegen.
     
      Wurde kein Zielort für das GO bestimmt, kann der Wert dieses Feldes auch null sein.
     
      Der Wert kann nachträglich (nach Erzeugung des Objekts) geändert werden, es sind entsprechende Methoden zu implementieren.\\[0.5em]
      
{{\bf private Map<UserEntity, Status> userStatus}} Eine Map mit allen Teilnehmern des GOs, um ihnen ihren Teilnahmestatus zuzuweisen.
     
      Bei Erzeugung eines Objekts dieser Klasse wird dem GO-Verantwortlichen automatisch der Status BESTÄTIGT zugewiesen, allen anderen Gruppenmitgliedern der Status
      ABGELEHNT.
      Es besteht keine Abhängigkeit dieser Liste zur LocationService-Klasse oder anderen Klassen, die von LocationService
      benutzt werden.
     
      Es dürfen nur Benutzer Teil dieser Liste sein, die auch Teil der Gruppe sind, in der das GO erstellt wurde. Jedes Mitglied der Gruppe des GOs muss in der Liste enthalten sein.
     
      Diese Liste ist veränderlich, es müssen also entsprechende Methoden implementiert werden, um Objekte zu der Liste hinzufügen und entfernen zu können.
\end{verse}
}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GoEntity()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity()}{{\bf  GoEntity}\\}
\begin{lstlisting}[frame=none]
public GoEntity()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{equals(Object)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity.equals(java.lang.Object)}{{\bf  equals}\\}
\begin{lstlisting}[frame=none]
public boolean equals(java.lang.Object arg0)\end{lstlisting} %end signature
}%end item
\item{ 
\index{getDescription()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity.getDescription()}{{\bf  getDescription}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getDescription()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getEnd()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity.getEnd()}{{\bf  getEnd}\\}
\begin{lstlisting}[frame=none]
public java.util.Date getEnd()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getGoingUsers()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity.getGoingUsers()}{{\bf  getGoingUsers}\\}
\begin{lstlisting}[frame=none]
public java.util.List getGoingUsers()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getGoneUsers()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity.getGoneUsers()}{{\bf  getGoneUsers}\\}
\begin{lstlisting}[frame=none]
public java.util.List getGoneUsers()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getID()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity.getID()}{{\bf  getID}\\}
\begin{lstlisting}[frame=none]
public long getID()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getLat()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity.getLat()}{{\bf  getLat}\\}
\begin{lstlisting}[frame=none]
public long getLat()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getLon()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity.getLon()}{{\bf  getLon}\\}
\begin{lstlisting}[frame=none]
public long getLon()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getName()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity.getName()}{{\bf  getName}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getName()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getNotGoingUsers()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity.getNotGoingUsers()}{{\bf  getNotGoingUsers}\\}
\begin{lstlisting}[frame=none]
public java.util.List getNotGoingUsers()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getStart()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity.getStart()}{{\bf  getStart}\\}
\begin{lstlisting}[frame=none]
public java.util.Date getStart()\end{lstlisting} %end signature
}%end item
\item{ 
\index{hashCode()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity.hashCode()}{{\bf  hashCode}\\}
\begin{lstlisting}[frame=none]
public native int hashCode()\end{lstlisting} %end signature
}%end item
\item{ 
\index{setDescription(String)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity.setDescription(java.lang.String)}{{\bf  setDescription}\\}
\begin{lstlisting}[frame=none]
public void setDescription(java.lang.String description)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setEnd(Date)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity.setEnd(java.util.Date)}{{\bf  setEnd}\\}
\begin{lstlisting}[frame=none]
public void setEnd(java.util.Date end)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setGoingUsers(List)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity.setGoingUsers(java.util.List)}{{\bf  setGoingUsers}\\}
\begin{lstlisting}[frame=none]
public void setGoingUsers(java.util.List goingUsers)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setGoneUsers(List)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity.setGoneUsers(java.util.List)}{{\bf  setGoneUsers}\\}
\begin{lstlisting}[frame=none]
public void setGoneUsers(java.util.List goneUsers)\end{lstlisting} %end signature
}%end item

\item{ 
\index{setLat(long)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity.setLat(long)}{{\bf  setLat}\\}
\begin{lstlisting}[frame=none]
public void setLat(long lat)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setLon(long)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity.setLon(long)}{{\bf  setLon}\\}
\begin{lstlisting}[frame=none]
public void setLon(long lon)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setName(String)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity.setName(java.lang.String)}{{\bf  setName}\\}
\begin{lstlisting}[frame=none]
public void setName(java.lang.String name)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setNotGoingUsers(List)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity.setNotGoingUsers(java.util.List)}{{\bf  setNotGoingUsers}\\}
\begin{lstlisting}[frame=none]
public void setNotGoingUsers(java.util.List notGoingUsers)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setStart(Date)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GoEntity.setStart(java.util.Date)}{{\bf  setStart}\\}
\begin{lstlisting}[frame=none]
public void setStart(java.util.Date start)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.PersistenceLayer.GroupEntity}Klasse GroupEntity}{
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GroupEntity}{}\vskip .1in 
Dies ist eine Entity Klasse. Sie wird von dem Framework Hibernate dazu verwendet, POJOS auf Tupel in einer Datenbank zu mappen. Wie das Mapping geschieht ist in dieser Klasse durch Annotations festgelegt. Der Rest der Anwendung kann somit überall mit Java-Objekten hantieren und muss sich nicht um die konkrete Implementierung der Datenbank kümmern. Der Zugriff auf die Datenbank erfolgt nicht in dieser Klasse, sondern nur über eine DAO Klasse, die das Interface GroupDao implementiert. Zusätzlich dient diese Klasse als Vorlage des Frameworks Gson zum Parsen von JSON-Objekten, die von der REST API empfangen und gesendet werden. Die Attribute der Klasse bestimmen dabei die Struktur des JSON-Objekts.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GroupEntity
 extends java.lang.Object\end{lstlisting}

\subsubsection{Attribute}{
\begin{verse}
{{\bf private long id}} Eine im gesamten System eindeutige ID-Nummer, anhand derer eine Gruppe eindeutig identifiziert werden kann.
      Die ID ist eine positive ganze Zahl im Wertebereich des Datentyps long.
      Nach Erzeugung des Objekts kann sie bis zu seiner Zerstörung nicht verändert werden. Generiert wird die Id automatisch bei der Persistierung des Entity-Objekts
      in der Datenbank. Dadurch ist die Eindeutigkeit der ID garantiert.\\[0.5em]
{{\bf private String name}} Der Name der Gruppe. Dieser muss nicht eindeutig sein.
      Es handelt sich dabei um einen String, der weniger als 50 Zeichen enthält.
      Der Name einer Gruppe kann nachträglich (nach Erzeugung des Objekts) geändert werden, es sind entsprechende Methoden zu implementieren.\\[0.5em]
{{\bf private String description}} Eine textuelle Beschreibung der Gruppe. Diese muss nicht eindeutig sein.
      Es handelt sich dabei um einen String, der weniger als 140 Zeichen enthält.
      Die Beschreibung einer Gruppe kann nachträglich (nach Erzeugung des Objekts) geändert werden, es sind entsprechende Methoden zu implementieren.\\[0.5em]
{{\bf private List<UserEntity> members}} Eine Liste, die alle Benutzer enthält, die vollwertige Mitglieder der Gruppe sind, also Benutzer die eine Mitgliedsanfrage erhalten und diese bestätigt haben,
      plus der Ersteller der Gruppe, sollte er noch nicht ausgetreten sein.
     
     Bei der Erzeugung eines Objekts dieser Klasse, wird der Ersteller automatisch diser Liste hinzugefügt.
     
      Die Länge der Liste liegt zwischen 1 und 50. Sie kann niemals komplett leer sein. Gruppen mit 0 Mitgliedern werden automatisch gelöscht.
     
      Die Liste muss auch nach der Erzeugung des Objekts veränderbar sein, entsprechende Methoden sind zu implementieren.\\[0.5em]
{{\bf private List<UserEntity> requests}} Eine Liste, die alle Benutzer enthält, die eine Mitgliedschaftsanfrage zu dieser Gruppe erhalten haben, diese aber noch nicht beantwortet
      haben.
     
      Bei Erzeugung dieses Objekts ist die Liste leer. Die Länge der Liste kann zwischen 0 und 50 liegen. Dabei hängt die maximale Länge auch
      von der aktuellen Mitgliederanzahl ab. Die Summe von beidem darf 50 nicht übersteigen.
     
     Die Liste muss auch nach der Erzeugung des Objekts veränderbar sein, entsprechende Methoden sind zu implementieren.\\[0.5em]
{{\bf private List<UserEntity> admins}} Eine Liste mit allen Admins der Gruppe. Jeder Benutzer, der Teil dieser Liste ist, muss auch teil der members-Liste sein, da nur ein
     Gruppenmitglied Administrator einer Gruppe sein kann.
     
      Bei der Erzeugung eines Objekts dieser Klasse, wird der Ersteller automatisch diser Liste hinzugefügt.
    
      Die Länge der Liste liegt zwischen 1 und 50. Sie kann niemals komplett leer sein. Gruppen mit 0 Mitgliedern werden automatisch gelöscht.
     
     Die Liste muss auch nach der Erzeugung des Objekts veränderbar sein, entsprechende Methoden sind zu implementieren.\\[0.5em]
{{\bf private List<GoEntity> gos}} Eine Liste mit allen GOs, die in dieser Gruppe erstellt wurden. DAbei handelt es sich nur um GOs, die gerade aktiv sind, oder in Zukunft
     noch aktiv sein werden. GOs, die schon vüruber sind werden automatisch aus dieser Liste gelöscht.
     
     Bei Erstellung eines Objekts dieser Klasse ist diese Liste leer. Die Länge der Liste liegt zwischen 0 und 10 GOs.
     
      Die Liste muss auch nach der Erzeugung des Objekts veränderbar sein, entsprechende Methoden sind zu implementieren.
\end{verse}
}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GroupEntity()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GroupEntity()}{{\bf  GroupEntity}\\}
\begin{lstlisting}[frame=none]
public GroupEntity()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{equals(Object)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GroupEntity.equals(java.lang.Object)}{{\bf  equals}\\}
\begin{lstlisting}[frame=none]
public boolean equals(java.lang.Object arg0)\end{lstlisting} %end signature
}%end item
\item{ 
\index{getAdmins()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GroupEntity.getAdmins()}{{\bf  getAdmins}\\}
\begin{lstlisting}[frame=none]
public java.util.List getAdmins()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getDescription()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GroupEntity.getDescription()}{{\bf  getDescription}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getDescription()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getID()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GroupEntity.getID()}{{\bf  getID}\\}
\begin{lstlisting}[frame=none]
public int getID()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getMembers()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GroupEntity.getMembers()}{{\bf  getMembers}\\}
\begin{lstlisting}[frame=none]
public java.util.List getMembers()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getName()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GroupEntity.getName()}{{\bf  getName}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getName()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getRequests()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GroupEntity.getRequests()}{{\bf  getRequests}\\}
\begin{lstlisting}[frame=none]
public java.util.List getRequests()\end{lstlisting} %end signature
}%end item
\item{ 
\index{hashCode()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GroupEntity.hashCode()}{{\bf  hashCode}\\}
\begin{lstlisting}[frame=none]
public native int hashCode()\end{lstlisting} %end signature
}%end item
\item{ 
\index{setAdmins(List)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GroupEntity.setAdmins(java.util.List)}{{\bf  setAdmins}\\}
\begin{lstlisting}[frame=none]
public void setAdmins(java.util.List admins)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setDescription(String)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GroupEntity.setDescription(java.lang.String)}{{\bf  setDescription}\\}
\begin{lstlisting}[frame=none]
public void setDescription(java.lang.String description)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setID(int)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GroupEntity.setID(int)}{{\bf  setID}\\}
\begin{lstlisting}[frame=none]
public void setID(int ID)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setMembers(List)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GroupEntity.setMembers(java.util.List)}{{\bf  setMembers}\\}
\begin{lstlisting}[frame=none]
public void setMembers(java.util.List members)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setName(String)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GroupEntity.setName(java.lang.String)}{{\bf  setName}\\}
\begin{lstlisting}[frame=none]
public void setName(java.lang.String name)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setRequests(List)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.GroupEntity.setRequests(java.util.List)}{{\bf  setRequests}\\}
\begin{lstlisting}[frame=none]
public void setRequests(java.util.List requests)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.PersistenceLayer.Status}Enum Status}{
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.Status}{}\vskip .1in 
Dieses Enum definiert die verschiedenen Teilnahmestatus, die ein Benutzer in einem GO innehaben kann.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public final class Status
 extends java.lang.Enum\end{lstlisting}

\subsubsection{Felder}{
\begin{itemize}
\item{
\index{ABGELEHNT}
\label{edu.kit.pse17.go_app.PersistenceLayer.Status.ABGELEHNT}\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.Status.ABGELEHNT}{\texttt{public static final Status\ {\bf  ABGELEHNT}}
}
\begin{itemize}
\item{\vskip -.9ex 
bedeutet, dass der Benutzer nicht an dem GO teilnehmen wird. Er teilt seinen Standort nicht mit anderen und kann auch die Standorte der anderen Go-Teilnehmer nicht sehen. Dieser Teilnahmestatus ist der default-Status bei der Erstellung eines GOs für alle Teilnehmer, außer dem Ersteller selbst. Der Ersteller kann niemals den Status "ABGELEHNT" annehmen.}
\end{itemize}
}
\item{
\index{BESTÄTIGT}
\label{edu.kit.pse17.go_app.PersistenceLayer.Status.BESTÄTIGT}\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.Status.BESTÄTIGT}{\texttt{public static final Status\ {\bf  BESTÄTIGT}}
}
\begin{itemize}
\item{\vskip -.9ex 
bedeutet, dass der Benutzer an dem GO teilnehmen wird. Er ist in dem GO allerdings noch nicht aktiv, d.h. er teilt seinen Standort nicht mit anderen. Gibt es andere Teilnehmer in dem GO, die bereits "UNTERWEGS" sind, kann der Benutzer deren Standorte sehen. Dieser Teilnahmestatus ist der default-Status für den Ersteller eines GOs.}
\end{itemize}
}
\item{
\index{UNTERWEGS}
\label{edu.kit.pse17.go_app.PersistenceLayer.Status.UNTERWEGS}\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.Status.UNTERWEGS}{\texttt{public static final Status\ {\bf  UNTERWEGS}}
}
\begin{itemize}
\item{\vskip -.9ex 
bedeutet, dass der Benutzer an dem GO teilnimmt und bereits aktiv ist, d.h. er teilt gerade seinen Standort mit anderen GO-Teilnehmern. Dieser kann von Benutzern mit dem Status "UNTERWEGS" oder "BESTÄTIGT" angesehen werden. Er selbst kann den Standort von anderen aktiven Go-Teilnehmern sehen.}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{valueOf(String)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.Status.valueOf(java.lang.String)}{{\bf  valueOf}\\}
\begin{lstlisting}[frame=none]
public static Status valueOf(java.lang.String name)\end{lstlisting} %end signature
}%end item
\item{ 
\index{values()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.Status.values()}{{\bf  values}\\}
\begin{lstlisting}[frame=none]
public static Status[] values()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Von der Klasse Enum vererbte Methoden }{
\texttt{java.lang.Enum} {\small 
\refdefined{java.lang.Enum}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{protected final Object {\bf  clone}() throws CloneNotSupportedException
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public final int {\bf  compareTo}(\texttt{Enum} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public final boolean {\bf  equals}(\texttt{Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{protected final void {\bf  finalize}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public final Class {\bf  getDeclaringClass}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public final int {\bf  hashCode}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public final String {\bf  name}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public final int {\bf  ordinal}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public String {\bf  toString}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public static Enum {\bf  valueOf}(\texttt{Class} {\bf  arg0},
\texttt{String} {\bf  arg1})
}%end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.PersistenceLayer.UserEntity}Klasse UserEntity}{
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.UserEntity}{}\vskip .1in 
Dies ist eine Entity Klasse. Sie wird von dem Framework Hibernate dazu verwendet, POJOS auf Tupel in einer Datenbank zu mappen. Wie das Mapping geschieht ist in dieser Klasse durch Annotations festgelegt. Der Rest der Anwendung kann somit überall mit Java-Objekten hantieren und muss sich nicht um die konkrete Implementierung der Datenbank kümmern. Der Zugriff auf die Datenbank erfolgt nicht in dieser Klasse, sondern nur über eine DAO Klasse, die das Interface UserDao implementiert. Zusätzlich dient diese Klasse als Vorlage des Frameworks Gson zum Parsen von JSON-Objekten, die von der REST API empfangen und gesendet werden. Die Attribute der Klasse bestimmen dabei die Struktur des JSON-Objekts.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class UserEntity
 extends java.lang.Object\end{lstlisting}

\begin{verse}
{{\bf private String uid}} Eine im System eindeutige UserID. Diese ID wird generiert von dem Firebase Authentication Service und von dieser Andwendung unverändert
     übernommen. Die ID wird nach der Registrierung nicht mehr verändert, bis der User seinen Account löscht.\\[0.5em]
     
{{\bf private String instanceID}} Ein String, mit dem das Gerät, das der Benutzer im Augenblick benutzt identifiziert werden kann. Diese ID wird vom Firebease Cloud
      Messaging Service benötigt und erlaubt es dem Server eine Nachricht an einen Client zu schicken, ohne dass dieser Client vorher den Server angesprochen
      haben muss.
     
      Da sich durch Gerätewechsel oder Konfigurationsänderungen am Gerät die InstanceId ändern kann, muss die DAO-Klasse eine Methode zur Änderung der InstanceId
      besitzen.\\[0.5em]
      
{{\bf private String name}} Der Benutzername des Users. Dieser muss nicht eindeutig sein. Er kann vom User nicht selbst bestimmt werden, sondern wird übernommen,
      von dem Google-Account mit dem sich der User in der App angemeldet hat. Da der Benutzer nach der Regsitrierun diesen Account nicht wechseln kann,
      bleibt auch der Benutzername die ganze Zeit unverändert.\\[0.5em]
      
{{\bf private String email}} Die Email-Adresse, die mit dem Google-Account asoziiert ist, mit dem sich der Benutzer registriert hat.
      Da der Benutzer nach der Registrierung diesen Account nicht wechseln kann, bleibt auch der Benutzername die ganze Zeit unverändert.\\[0.5em]
      
{{\bf private List<GroupEntity> groups}} Eine Liste mit allen Gruppen, in denen der Benutzer Mitglied ist. Dieses Feld enthält einen ForeignKeyConstraint: Die IDs der Gruppenobjekte der Liste
      sind die Primärschlüssel in der Gruppenrelation. Für dieses Feld müssen Methoden zum Ändern der Liste vorhanden sein, da sich die Gruppen, in den der Benutzer
      Mitglied ist verändern können.\\[0.5em]
\end{verse}
}


\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{UserEntity()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.UserEntity()}{{\bf  UserEntity}\\}
\begin{lstlisting}[frame=none]
public UserEntity()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{equals(Object)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.UserEntity.equals(java.lang.Object)}{{\bf  equals}\\}
\begin{lstlisting}[frame=none]
public boolean equals(java.lang.Object arg0)\end{lstlisting} %end signature
}%end item
\item{ 
\index{getEmail()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.UserEntity.getEmail()}{{\bf  getEmail}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getEmail()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getInstanceId()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.UserEntity.getInstanceId()}{{\bf  getInstanceId}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getInstanceId()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getName()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.UserEntity.getName()}{{\bf  getName}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getName()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getUid()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.UserEntity.getUid()}{{\bf  getUid}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getUid()\end{lstlisting} %end signature
}%end item
\item{ 
\index{hashCode()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.UserEntity.hashCode()}{{\bf  hashCode}\\}
\begin{lstlisting}[frame=none]
public native int hashCode()\end{lstlisting} %end signature
}%end item
\item{ 
\index{setEmail(String)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.UserEntity.setEmail(java.lang.String)}{{\bf  setEmail}\\}
\begin{lstlisting}[frame=none]
public void setEmail(java.lang.String email)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setInstanceId(String)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.UserEntity.setInstanceId(java.lang.String)}{{\bf  setInstanceId}\\}
\begin{lstlisting}[frame=none]
public void setInstanceId(java.lang.String instanceId)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setName(String)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.UserEntity.setName(java.lang.String)}{{\bf  setName}\\}
\begin{lstlisting}[frame=none]
public void setName(java.lang.String name)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setUid(String)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.UserEntity.setUid(java.lang.String)}{{\bf  setUid}\\}
\begin{lstlisting}[frame=none]
public void setUid(java.lang.String uid)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
}
\section{Package PersistenceLayer.daos}{
\label{edu.kit.pse17.go_app.PersistenceLayer.daos}\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos}{}
\hskip -.05in
\hbox to \hsize{\textit{ Package Contents\hfil Page}}
\vskip .13in
\hbox{{\bf  Interfaces}}
\entityintro{AbstractDao}{edu.kit.pse17.go_app.PersistenceLayer.daos.AbstractDao}{Bei diesem Interface handelt es sich um ein Interface für eine Data Access Object Klasse, die die Datenbankzugriffe in sich kapselt.}
\entityintro{GoDao}{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDao}{Bei diesem Interface handelt es sich um ein Interface für eine Data Access Object Klasse, die die Datenbankzugriffe in sich kapselt.}
\entityintro{GroupDao}{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDao}{Bei diesem Interface handelt es sich um ein Interface für eine Data Access Object Klasse, die die Datenbankzugriffe in sich kapselt.}
\entityintro{UserDao}{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDao}{Bei diesem Interface handelt es sich um ein Interface für eine Data Access Object Klasse, die die Datenbankzugriffe in sich kapselt.}
\vskip .13in
\hbox{{\bf  Klassen}}
\entityintro{GoDaoImp}{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDaoImp}{Created by tina on 30.06.17.}
\entityintro{GroupDaoImp}{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDaoImp}{Created by tina on 30.06.17.}
\entityintro{UserDaoImp}{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp}{Diese Klasse implementiert die Interfaces UserDao, AbstractDao und Observable.}
\vskip .1in
\vskip .1in
\subsection{\label{edu.kit.pse17.go_app.PersistenceLayer.daos.AbstractDao}Interface AbstractDao}{
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.AbstractDao}{}\vskip .1in 
Bei diesem Interface handelt es sich um ein Interface für eine Data Access Object Klasse, die die Datenbankzugriffe in sich kapselt. Dieses Interface definiert Methoden auf einer Datenbank, die standardmäßig für jede Tabelle zur Verfügung stehen sollten (CRUD). daher wird dieses Interface von jeder DAO-Klasse implementiert. Das Interface beinhaltet zwei Generics. Das Generic T definiert den entity-Typen, der in der jeweiligen Tabelle verwaltet wird. Das Generic PK ist der Datentyps des Primärschlüssels der Datenbanktabelle. Die Methoden dieses Interfaces werden von dieser DAO Klasse implementiert und sind nach außen sichtbar. Sie werden aufgerufen, von den RestController-Klassen, denn von dort werden die Server-Anfragen, die von Clients gestellt werden, an die Persistence-Klassen weitergeleitet.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public interface AbstractDao
\end{lstlisting}
\subsubsection{Subinterfaces}{GoDaoImp\small{\refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDaoImp}}, UserDaoImp\small{\refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp}}, GroupDaoImp\small{\refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDaoImp}}}
\subsubsection{Klassen, die das Interface implementieren}{GoDaoImp\small{\refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDaoImp}}, UserDaoImp\small{\refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp}}, GroupDaoImp\small{\refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDaoImp}}}

\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{delete(PK)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.AbstractDao.delete(PK)}{{\bf  delete}\\}
\begin{lstlisting}[frame=none]
void delete(java.lang.Object key) throws EntityNotFoundException\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode löscht ein Entity-Objekt aus der Datenbank. Es werden außerdem automatisch alle Entities gelöscht, die mit der gelöschten Entity assoziiert sind (Auch in anderen Datenbanktabellen, sodass der Datenbestand nach der Ausführung der Methode konsistent ist)
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{key} -- Der Primärschlüssel der Entity, die aus der Datenbanktabelle gelöscht werden soll. Der Datentyp wird durch das Generic PK bei der Implementierung der Klasse spezifiziert.}
  \end{itemize}
}%end item
\item{{\bf  Throws}
  \begin{itemize}
   \item{\vskip -.6ex \texttt{EntityNotFoundException} -- existiert keine Entity mit dem spezifizierten Schlüssel, wird eine EntityNotFoundException geworfen, die von der aufrufenden Klasse behandelt werden muss.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{get(PK)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.AbstractDao.get(PK)}{{\bf  get}\\}
\begin{lstlisting}[frame=none]
java.lang.Object get(java.lang.Object key)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode gibt ein Entity-Objekt zurück, das anhand seines Primärschlüssels aus der Datenbank geholt wurde.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{key} -- Der Primärschlüssel der Entity, die aus der Datenbank geholt werden soll. Der Datentyp wird von dem Generic PK bestimmt, mit dem das Interface implementiert wird.}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
Ein Entity-Objekt, das durch den Schlüssel identifiziert wurde. Konnte keine passende Entity in der Datenbank gefunden werden, gibt die Methode null zurück. 
}%end item
\end{itemize}
}%end item
\item{ 
\index{persist(T)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.AbstractDao.persist(T)}{{\bf  persist}\\}
\begin{lstlisting}[frame=none]
void persist(java.lang.Object entity)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode speichert eine neue Entity vom Typ T in der Datenbank ab. dabei wird das Entity-Objekt vor dem Methodenaufruf erzeugt und der Methode "fertig" übergeben.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{entity} -- Das Entity-Objekt, das in der Datenbank gespeichert werden soll. Es wird garantiert, dass das Objekt, welches der Methode übergeben wird gültig ist (alle Konsistenzbedingungen der Datenbank werden erfüllt).}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{update(T)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.AbstractDao.update(T)}{{\bf  update}\\}
\begin{lstlisting}[frame=none]
void update(java.lang.Object t) throws EntityNotFoundException\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode ändert Attributwerte eines bereits bestehenden Entity-Objekts. Dabei können nicht in jeder Entity-Klasse alle Attribute geändert werden. Welche Attribute geändert werden können ist in den Entity-Klassen und in den implementierenden Dao-Klassen spezifiziert.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{t} -- Ein Entity-Objekt, dass die geänderten Daten enthält. Das Objekt enthält die ID der Entity, die geändert werden soll und die Werte der Attribute die neu zugewiesen werden sollen. Alle anderen Attribute sind null, was der Methode signalisiert, dass diese Werte nicht geändert werden müssen.}
  \end{itemize}
}%end item
\item{{\bf  Throws}
  \begin{itemize}
   \item{\vskip -.6ex \texttt{EntityNotFoundException} -- existiert keine Entity mit dem spezifizierten Schlüssel, wird eine EntityNotFoundException geworfen, die von der aufrufenden Klasse behandelt werden muss.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDao}Interface GoDao}{
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDao}{}\vskip .1in 
Bei diesem Interface handelt es sich um ein Interface für eine Data Access Object Klasse, die die Datenbankzugriffe in sich kapselt. Die Methoden dieses Interfaces werden von dieser DAO Klasse implementiert und sind nach außen sichtbar. Sie werden aufgerufen, von den RestController-Klassen, denn von dort werden die Server-Anfragen, die von Clients gestellt werden, an die Persistence-Klassen weitergeleitet.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public interface GoDao
\end{lstlisting}
\subsubsection{Subinterfaces}{GoDaoImp\small{\refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDaoImp}}, GroupDaoImp\small{\refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDaoImp}}}
\subsubsection{Klassen, die dieses Interface implementieren}{GoDaoImp\small{\refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDaoImp}}, GroupDaoImp\small{\refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDaoImp}}}

\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{changeStatus(String, long, Status)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDao.changeStatus(java.lang.String, long, edu.kit.pse17.go_app.PersistenceLayer.Status)}{{\bf  changeStatus}\\}
\begin{lstlisting}[frame=none]
void changeStatus(java.lang.String userId,long goId,edu.kit.pse17.go_app.PersistenceLayer.Status status)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Mit dieser Methode wird der Teilnahmestatus eines GO-Teilnehnmers geändert. Der Status kann entweder "ABGELEHNT", "BESTÄTIGT", oder "UNTERWEGS" lauten. Vor dem Aufruf der Methode muss sichergestellt werden, dass es sich bei dem Benutzer um ein Mitglied der Gruppe handelt und die Statusänderung die vorgenommen werden soll legal ist.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{userId} -- Die ID des Benutzers, dessen Teilnahmestatus geändert werden soll. Dabei handelt es sich um eine gültige Id, ansonsten kann die Methode nicht erfolgreich ausgeführt werden.}
   \item{
\texttt{goId} -- Die des GOs, für den der Teilnahmestatus geändert werden soll. Dabei handelt es sich um eine gültige Id, ansonsten kann die Methode nicht erfolgreich ausgeführt werden.}
   \item{
\texttt{status} -- Der neue Status des Benutzers.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDao}Interface GroupDao}{
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDao}{}\vskip .1in 
Bei diesem Interface handelt es sich um ein Interface für eine Data Access Object Klasse, die die Datenbankzugriffe in sich kapselt. Die Methoden dieses Interfaces werden von dieser DAO Klasse implementiert und sind nach außen sichtbar. Sie werden aufgerufen, von den RestController-Klassen, denn von dort werden die Server-Anfragen, die von Clients gestellt werden, an die Persistence-Klassen weitergeleitet.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public interface GroupDao
\end{lstlisting}

\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{addAdmin(String, String)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDao.addAdmin(java.lang.String, java.lang.String)}{{\bf  addAdmin}\\}
\begin{lstlisting}[frame=none]
void addAdmin(java.lang.String userId,java.lang.String groupId) throws EntityNotFoundException\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode fügt einen Administrator bei einer Gruppe hinzu. Anfrage zu dieser Methode sollte nur von anderen Administratoren dieser Gruppe kommen. Es muss vor dem Aufruf der Methode sichergestellt werden, dass es sich bei dem Benutzer um ein vollwertiges Gruppenmitglied handelt und dieser nicht bereits ein Administrator ist.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{userId} -- Die ID des Benutzers, der als Administrator hinzugefügt werden soll. Dabei handelt es sich um eine gültige Id, ansonsten kann die Methode nicht erfolgreich ausgeführt werden.}
   \item{
\texttt{groupId} -- die ID der Gruppe, zu der der Administrator hinzugefügt werden soll. Dabei handelt es sich um eine gültige Id, ansonsten kann die Methode nicht erfolgreich ausgeführt werden.}
  \end{itemize}
}%end item
\item{{\bf  Throws}
  \begin{itemize}
   \item{\vskip -.6ex \texttt{EntityNotFoundException} -- existiert keine Entity mit dem spezifizierten Schlüssel, wird eine EntityNotFoundException geworfen, die von der aufrufenden Klasse behandelt werden muss.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{addGroupMember(String, long)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDao.addGroupMember(java.lang.String, long)}{{\bf  addGroupMember}\\}
\begin{lstlisting}[frame=none]
void addGroupMember(java.lang.String userId,long groupId) throws EntityNotFoundException\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Fügt der Gruppe mit der Id groupId den Benutzer mit der Id userId hinzu. Vor dem Aufruf dieser Methode, muss der Aufrufer sicherstellen, dass der Benutzer nicht bereits ein Mitglied in der Gruppe ist und, dass der Benutzer zuvor eine Mitgliedschaftsanfrage zu der Gruppe bekommen hat bzw. es sich um dem Ersteller einer neuen Gruppe handelt.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{groupId} -- Die ID der Gruppe, zu der der Benutzer hinzugefügt werden soll. Dabei handelt es sich um eine gültige Id, ansonsten kann die Methode nicht erfolgreich ausgeführt werden.}
   \item{
\texttt{userId} -- Die ID des Benutzers, der der Gruppe hinzugefügt werden soll. Dabei handelt es sich um eine gültige Id, ansonsten kann die Methode nicht erfolgreich ausgeführt werden.}
  \end{itemize}
}%end item
\item{{\bf  Throws}
  \begin{itemize}
   \item{\vskip -.6ex \texttt{EntityNotFoundException} -- existiert keine Entity mit dem spezifizierten Schlüssel, wird eine EntityNotFoundException geworfen, die von der aufrufenden Klasse behandelt werden muss.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{addGroupRequest(String, long)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDao.addGroupRequest(java.lang.String, long)}{{\bf  addGroupRequest}\\}
\begin{lstlisting}[frame=none]
void addGroupRequest(java.lang.String userId,long groupId) throws EntityNotFoundException\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Mit dieser Methode lässt sich eine neue Gruppenanfrage in der Datenbank speichern. Sie muss also aufgerufen werden, wenn ein Administrator einen Benutzer zur Gruppe einlädt. Vor dem Aufruf der Methode muss sichergestellt werden, dass der Empfänger der Anfrage kein Gruppenmitglied ist und auch noch keine Anfrage erhalten hat.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{userId} -- Die ID des Benutzers, der zu der Gruppe eingeladen wird. Dabei handelt es sich um eine gültige Id, ansonsten kann die Methode nicht erfolgreich ausgeführt werden.}
   \item{
\texttt{groupId} -- die ID der Gruppe, zu der der Benutzer eingeladen wird. Dabei handelt es sich um eine gültige Id, ansonsten kann die Methode nicht erfolgreich ausgeführt werden.}
  \end{itemize}
}%end item
\item{{\bf  Throws}
  \begin{itemize}
   \item{\vskip -.6ex \texttt{EntityNotFoundException} -- existiert keine Entity mit dem spezifizierten Schlüssel, wird eine EntityNotFoundException geworfen, die von der aufrufenden Klasse behandelt werden muss.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{removeGroupMember(String, long)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDao.removeGroupMember(java.lang.String, long)}{{\bf  removeGroupMember}\\}
\begin{lstlisting}[frame=none]
void removeGroupMember(java.lang.String userId,long groupId) throws EntityNotFoundException\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode entfernt ein Gruppenmitglied aus einer Gruppe. Sie wird aufgerufen, wenn entweder ein Gruppenmitglied aus einer Gruppe austritt oder ein Administrator ein gruppenmitglied entfernt. Vor dem Aufruf der Methode muss sichergestellt werden, dass es sich bei dem Benutzer um ein Mitglied der Gruppe handelt. Diese Methode kann nicht dazu verwendet werden, eine Gruppenanfrage zu löschen. Sämtliche GOs, die dem entfernten Gruppenmitglied gehören werden automatisch gelöscht bei Aufruf der Methode, um die Konsistenz des Datenbestands zu erhalten.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{groupId} -- die ID der Gruppe, aus der der Benutzer entfernt werden soll. Dabei handelt es sich um eine gültige Id, ansonsten kann die Methode nicht erfolgreich ausgeführt werden.}
   \item{
\texttt{userId} -- Die ID des Benutzers, der aus der Gruppe entfernt werden soll. Dabei handelt es sich um eine gültige Id, ansonsten kann die Methode nicht erfolgreich ausgeführt werden.}
  \end{itemize}
}%end item
\item{{\bf  Throws}
  \begin{itemize}
   \item{\vskip -.6ex \texttt{EntityNotFoundException} -- existiert keine Entity mit dem spezifizierten Schlüssel, wird eine EntityNotFoundException geworfen, die von der aufrufenden Klasse behandelt werden muss.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{removeGroupRequest(String, long)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDao.removeGroupRequest(java.lang.String, long)}{{\bf  removeGroupRequest}\\}
\begin{lstlisting}[frame=none]
void removeGroupRequest(java.lang.String userId,long groupId) throws EntityNotFoundException\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode entfernt eine Gruppenmitgliedschaftsanfrage aus der Datenbank. Sie wird aufgerufen, wenn ein Benutzer eine Gruppenmitgliedschaftsanfrage beantwortet hat.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{groupId} -- die ID der Gruppe, zu der der Benutzer eingeladen war. Dabei handelt es sich um eine gültige Id, ansonsten kann die Methode nicht erfolgreich ausgeführt werden.}
   \item{
\texttt{userId} -- Die ID des Benutzers, der zu der Gruppe eingeladen war. Dabei handelt es sich um eine gültige Id, ansonsten kann die Methode nicht erfolgreich ausgeführt werden.}
  \end{itemize}
}%end item
\item{{\bf  Throws}
  \begin{itemize}
   \item{\vskip -.6ex \texttt{EntityNotFoundException} -- existiert keine Entity mit dem spezifizierten Schlüssel, wird eine EntityNotFoundException geworfen, die von der aufrufenden Klasse behandelt werden muss.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDao}Interface UserDao}{
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDao}{}\vskip .1in 
Bei diesem Interface handelt es sich um ein Interface für eine Data Access Object Klasse, die die Datenbankzugriffe in sich kapselt. Die Methoden dieses Interfaces werden von dieser DAO Klasse implementiert und sind nach außen sichtbar. Sie werden aufgerufen, von den RestController-Klassen, denn von dort werden die Server-Anfragen, die von Clients gestellt werden, an die Persistence-Klassen weitergeleitet.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public interface UserDao
\end{lstlisting}
\subsubsection{All known subinterfaces}{UserDaoImp\small{\refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp}}}
\subsubsection{Klassen, die das Interface implementieren}{UserDaoImp\small{\refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp}}}

\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{addUser(UserEntity)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDao.addUser(edu.kit.pse17.go_app.PersistenceLayer.UserEntity)}{{\bf  addUser}\\}
\begin{lstlisting}[frame=none]
void addUser(edu.kit.pse17.go_app.PersistenceLayer.UserEntity user)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Die Methode fügt eine neue UserEntity in die Datenbank ein.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{user} -- Die Entity, die in die Datenbank eingefügt werden soll. Dieses Objekt muss eine in der Datenbank noch nicht vorhandene ID enthalten, sonst schlägt die Ausführung fehl.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{deleteUser(String)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDao.deleteUser(java.lang.String)}{{\bf  deleteUser}\\}
\begin{lstlisting}[frame=none]
void deleteUser(java.lang.String userId)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode entfernt eine Entity aus der Datenbank. Zusätzlich werden alle mit diesem Benutzer assoziierten Objekte ebenfalls entfernt. Dazu gehören: - GOs, bei denen der Benutzer der GO-Verantwortliche war - Gruppen, bei denen der Benutzer der einzige Administrator war - Gruppenmitgliedschaften des Benutzers - unbeantwortete Gruppenanfragen, die an den Benutzer gestellt wurden
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{userId} -- Die userId des Benutzers, dessen Account gelöscht werden soll. Es wird garantiert, dass es sich beim Aufruf der Methode, um eine gültige ID handelt.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{getGroups(String)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDao.getGroups(java.lang.String)}{{\bf  getGroups}\\}
\begin{lstlisting}[frame=none]
java.util.List getGroups(java.lang.String userId)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode gibt eine Liste mit allen Gruppen zurück, in denen der Benutzer Mitglied ist. Dies schließt Gruppen nicht mit ein, zu denen der Benutzer eingeladen wurde, er die Gruppenanfrage aber noch nicht beantwortet hat.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{userId} -- Die ID des Benutzers, dessen Gruppen zurückgegeben werden sollen. Es wird garantiert, dass es sich beim Aufruf der Methode um eine gültige userid handelt.}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
Eine Liste mit GroupEntities. Die Länge der Liste liegt zwischen 0 und 300. Bei allen Listenelementen handelt es sich um vollständige, gültige GroupEntity Objekte. 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getRequests(String)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDao.getRequests(java.lang.String)}{{\bf  getRequests}\\}
\begin{lstlisting}[frame=none]
java.util.List getRequests(java.lang.String userId)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode gibt eine Liste von Gruppen zurück, zu denen der Benutzer eine Gruppenanfrage erhalten hat, die er noch nicht beantwortet hat.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{userId} -- Die ID des Benutzers, dessen Gruppenanfragen zurückgegeben werden sollen. Es wird garantiert, dass es sich beim Aufruf der Methode um eine gültige userId handelt.}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
Eine Liste mit GroupEntities. Die Länge der Liste liegt zwischen 0 und 300. Bei allen Listenelementen handelt es sich um vollständige, gültige GroupEntity Objekte. 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getUserByEmail(String)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDao.getUserByEmail(java.lang.String)}{{\bf  getUserByEmail}\\}
\begin{lstlisting}[frame=none]
edu.kit.pse17.go_app.PersistenceLayer.UserEntity getUserByEmail(java.lang.String mail)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode sucht ein User-Objekt anhand einer E-Mailadresse und gibt, falls die Suche erfolgreich ist, dieses Objekt zurück.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{mail} -- Die E-Mailadresse, anhand derer der Benutzer gesucht werden soll. Der String muss keinem besonderen Muster entsprechen, damit diese Methode fehlerfrei ausgeführt werden kann.}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
Die Methode gibt das gefundene UserEntity Objekt zurück. Gibt es keinen Benutzer mit der übergebenen E-mailadresse, gibt die Methode null zurück. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDaoImp}Klasse GoDaoImp}{
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDaoImp}{}\vskip .1in 
Diese Klasse implementiert die Interfaces GoDao, AbstractDao und Observable. Sie übernimmt die konkreten Datenbankzugriffe auf die Tabelle "gos". Dazu werden alle Methoden aus den DAO Interfaces entsprechend implementiert. Aufgerufen werden die Methoden dieser Klasse von den RestController-Klassen, wenn ein Client dem Server eine
Anfrage zur Manipulation seiner Daten geschickt hat. Die Klasse gehört außerdem zu einer Implementierung des Beobachter-Entwurfsmusters und übernimmt dabei die Rolle des konkreten Subjekts. Die Klasse hat eine Liste von Beobachtern, die benachrichtigt werden, wenn sich in der Datenbank eine Änderung ergibt. Es ist die Verantwortung der Beobachter zu entscheiden, ob die  Änderung eine Folgeaktion auslöst oder nicht.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GoDaoImp
 extends java.lang.Object implements AbstractDao, GoDao, edu.kit.pse17.go_app.ServiceLayer.Observable\end{lstlisting}
\subsubsection{Konstruktoren Auflistung}{
\begin{verse}
\hyperlink{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDaoImp()}{{\bf GoDaoImp()}} \\
\end{verse}
}

\subsubsection{Attribute}{
\begin{verse}
{{\bf private SessionFactory sessionFactory}} Eine Sessionfactory, die Sessions bereitstellt. Die Sessions werden benötigt, damit die Klasse direkt mit der Datenbank
      kommunizieren kann und dort die Änderungen vornehmen. Das Attribut ist mit '@Autowired' annotiert, damit es automatisch
     mit einem gültigen Objekt instanziiert wird.
     
      Auf dieses Feld darf nur innerhalb dieser Klasse zugegriffen werden. Nach der Instanzizerung ist diese Objekt unveränderbar und
      bleibt bestehen, bis die Instanz dieser Klasse wieder zerstört wird.\\[0.5em]
{{\bf private List<Observer> observer}} Eine Liste mit Observern, die benachrichtigt werden, sobald eine Änderung an der Datenbank vorgenommen wird, die auch die Daten anderer Benutzer betrifft.
\end{verse}
}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GoDaoImp()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDaoImp()}{{\bf  GoDaoImp}\\}
\begin{lstlisting}[frame=none]
public GoDaoImp()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{changeStatus(String, long, Status)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDaoImp.changeStatus(java.lang.String, long, edu.kit.pse17.go_app.PersistenceLayer.Status)}{{\bf  changeStatus}\\}
\begin{lstlisting}[frame=none]
public void changeStatus(java.lang.String userId,long goId,edu.kit.pse17.go_app.PersistenceLayer.Status status)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{userId} -- Die ID des Benutzers, dessen Teilnahmestatus geändert werden soll. Dabei handelt es sich um eine gültige Id, ansonsten kann die Methode nicht erfolgreich ausgeführt werden.}
   \item{
\texttt{goId} -- Die des GOs, für den der Teilnahmestatus geändert werden soll. Dabei handelt es sich um eine gültige Id, ansonsten kann die Methode nicht erfolgreich ausgeführt werden.}
   \item{
\texttt{status} -- Der neue Status des Benutzers.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{delete(Long)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDaoImp.delete(java.lang.Long)}{{\bf  delete}\\}
\begin{lstlisting}[frame=none]
public void delete(java.lang.Long key) throws EntityNotFoundException\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{key} -- Der Primärschlüssel der Entity, die aus der Datenbanktabelle gelöscht werden soll. Der Datentyp wird durch das Generic PK bei der Implementierung der Klasse spezifiziert.}
  \end{itemize}
}%end item
\item{{\bf  Throws}
  \begin{itemize}
   \item{\vskip -.6ex \texttt{EntityNotFoundException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{get(Long)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDaoImp.get(java.lang.Long)}{{\bf  get}\\}
\begin{lstlisting}[frame=none]
public edu.kit.pse17.go_app.PersistenceLayer.GoEntity get(java.lang.Long key)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{key} -- Der Primärschlüssel der Entity, die aus der Datenbank geholt werden soll. Der Datentyp wird von dem Generic PK bestimmt, mit dem das Interface implementiert wird.}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
 
}%end item
\end{itemize}
}%end item
\item{ 
\index{notify(String, Observable, GoEntity)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDaoImp.notify(java.lang.String, edu.kit.pse17.go_app.ServiceLayer.Observable, edu.kit.pse17.go_app.PersistenceLayer.GoEntity)}{{\bf  notify}\\}
\begin{lstlisting}[frame=none]
public void notify(java.lang.String impCode,edu.kit.pse17.go_app.ServiceLayer.Observable observable,edu.kit.pse17.go_app.PersistenceLayer.GoEntity goEntity)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{impCode} -- Ein Code, der angibt, welche Observer-Implementierung benachrichtigt werden soll. dabei handelt es sich immer um ein öffentliches statisches Attribut in der Observer-Klasse. Handelt es sich um keinen gültigen Implementierungs-Code, wird kein Observer auf das notify() reagieren.}
   \item{
\texttt{observable} -- Eine Instanz des Observables, das die notify()-Methode aufgerufen hat. Durch diese Referenz weiß der Observer, von wo er eine Benachrichtigung bekommen hat.}
   \item{
\texttt{goEntity} -- Das Go an dem Änderungen vorgenommen wurden}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{persist(GoEntity)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDaoImp.persist(edu.kit.pse17.go_app.PersistenceLayer.GoEntity)}{{\bf  persist}\\}
\begin{lstlisting}[frame=none]
public void persist(edu.kit.pse17.go_app.PersistenceLayer.GoEntity entity)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{entity} -- Das Entity-Objekt, das in der Datenbank gespeichert werden soll. Es wird garantiert, dass das Objekt, welches der Methode}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{register(Observer)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDaoImp.register(edu.kit.pse17.go_app.ServiceLayer.Observer)}{{\bf  register}\\}
\begin{lstlisting}[frame=none]
public void register(edu.kit.pse17.go_app.ServiceLayer.Observer observer)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{observer} -- der Observer, der registriert werden soll. Dabei spielt es keine Rolle, um welche Implementierung eines}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{unregister(Observer)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDaoImp.unregister(edu.kit.pse17.go_app.ServiceLayer.Observer)}{{\bf  unregister}\\}
\begin{lstlisting}[frame=none]
public void unregister(edu.kit.pse17.go_app.ServiceLayer.Observer observer)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{observer} -- Der Observer der aus der Liste entfernt werden soll. es muss vor dem Aufruf dieser Methode sichergestellt werden, dass}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{update(GoEntity)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDaoImp.update(edu.kit.pse17.go_app.PersistenceLayer.GoEntity)}{{\bf  update}\\}
\begin{lstlisting}[frame=none]
public void update(edu.kit.pse17.go_app.PersistenceLayer.GoEntity goEntity) throws EntityNotFoundException\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{goEntity} -- }
  \end{itemize}
}%end item
\item{{\bf  Throws}
  \begin{itemize}
   \item{\vskip -.6ex \texttt{EntityNotFoundException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDaoImp}Klasse GroupDaoImp}{
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDaoImp}{}\vskip .1in 
Diese Klasse implementiert die Interfaces GroupDao, AbstractDao und Observable. Sie übernimmt die konkreten Datenbankzugriffe auf die Tabelle "groups". Dazu werden alle Methoden aus den DAO Interfaces entsprechend implementiert. Aufgerufen werden die Methoden dieser Klasse von den RestController-Klassen, wenn ein Client dem Server eine
Anfrage zur Manipulation seiner Daten geschickt hat. Die Klasse gehört außerdem zu einer Implementierung des Beobachter-Entwurfsmusters und übernimmt dabei die Rolle des konkreten Subjekts. Die Klasse hat eine Liste von Beobachtern, die benachrichtigt werden, wenn sich in der Datenbank eine Änderung ergibt. Es ist die Verantwortung der Beobachter zu entscheiden, ob die  Änderung eine Folgeaktion auslöst oder nicht.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GroupDaoImp
 extends java.lang.Object implements AbstractDao, GoDao, edu.kit.pse17.go_app.ServiceLayer.Observable\end{lstlisting}


\subsubsection{Attribute}{
\begin{verse}
{{\bf private SessionFactory sessionFactory}} Eine Sessionfactory, die Sessions bereitstellt. Die Sessions werden benötigt, damit die Klasse direkt mit der Datenbank
      kommunizieren kann und dort die Änderungen vornehmen. Das Attribut ist mit "@Autowired" annotiert, damit es automatisch
     mit einem gültigen Objekt instanziiert wird.
     
      Auf dieses Feld darf nur innerhalb dieser Klasse zugegriffen werden. Nach der Instanzizerung ist diese Objekt unveränderbar und
      bleibt bestehen, bis die Instanz dieser Klasse wieder zerstört wird.\\[0.5em]
{{\bf private List<Observer> observer}} Eine Liste mit Observern, die benachrichtigt werden, sobald eine Änderung an der Datenbank vorgenommen wird, die auch die Daten anderer Benutzer betrifft.
\end{verse}
}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GroupDaoImp()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDaoImp()}{{\bf  GroupDaoImp}\\}
\begin{lstlisting}[frame=none]
public GroupDaoImp()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{changeStatus(String, long, Status)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDaoImp.changeStatus(java.lang.String, long, edu.kit.pse17.go_app.PersistenceLayer.Status)}{{\bf  changeStatus}\\}
\begin{lstlisting}[frame=none]
public void changeStatus(java.lang.String userId,long goId,edu.kit.pse17.go_app.PersistenceLayer.Status status)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{userId} -- Die ID des Benutzers, dessen Teilnahmestatus geändert werden soll. Dabei handelt es sich um eine gültige Id, ansonsten kann die Methode nicht erfolgreich ausgeführt werden.}
   \item{
\texttt{goId} -- Die des GOs, für den der Teilnahmestatus geändert werden soll. Dabei handelt es sich um eine gültige Id, ansonsten kann die Methode nicht erfolgreich ausgeführt werden.}
   \item{
\texttt{status} -- Der neue Status des Benutzers.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{delete(Long)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDaoImp.delete(java.lang.Long)}{{\bf  delete}\\}
\begin{lstlisting}[frame=none]
public void delete(java.lang.Long key) throws EntityNotFoundException\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{key} -- Der Primärschlüssel der Entity, die aus der Datenbanktabelle gelöscht werden soll. Der Datentyp wird durch das Generic PK bei der Implementierung der Klasse spezifiziert.}
  \end{itemize}
}%end item
\item{{\bf  Throws}
  \begin{itemize}
   \item{\vskip -.6ex \texttt{EntityNotFoundException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{get(Long)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDaoImp.get(java.lang.Long)}{{\bf  get}\\}
\begin{lstlisting}[frame=none]
public edu.kit.pse17.go_app.PersistenceLayer.GroupEntity get(java.lang.Long key)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{key} -- Der Primärschlüssel der Entity, die aus der Datenbank geholt werden soll. Der Datentyp wird von dem Generic PK bestimmt, mit dem das Interface implementiert wird.}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
 
}%end item
\end{itemize}
}%end item
\item{ 
\index{notify(String, Observable, GroupEntity)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDaoImp.notify(java.lang.String, edu.kit.pse17.go_app.ServiceLayer.Observable, edu.kit.pse17.go_app.PersistenceLayer.GroupEntity)}{{\bf  notify}\\}
\begin{lstlisting}[frame=none]
public void notify(java.lang.String impCode,edu.kit.pse17.go_app.ServiceLayer.Observable observable,edu.kit.pse17.go_app.PersistenceLayer.GroupEntity groupEntity)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{impCode} -- Ein Code, der angibt, welche Observer-Implementierung benachrichtigt werden soll. dabei handelt es sich immer um ein öffentliches statisches Attribut in der Observer-Klasse. Handelt es sich um keinen gültigen Implementierungs-Code, wird kein Observer auf das notify() reagieren.}
   \item{
\texttt{observable} -- Eine Instanz des Observables, das die notify()-Methode aufgerufen hat. Durch diese Referenz weiß der Observer, von wo er eine Benachrichtigung bekommen hat.}
   \item{
\texttt{groupEntity} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{persist(GroupEntity)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDaoImp.persist(edu.kit.pse17.go_app.PersistenceLayer.GroupEntity)}{{\bf  persist}\\}
\begin{lstlisting}[frame=none]
public void persist(edu.kit.pse17.go_app.PersistenceLayer.GroupEntity entity)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{entity} -- Das Entity-Objekt, das in der Datenbank gespeichert werden soll. Es wird garantiert, dass das Objekt, welches der Methode}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{register(Observer)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDaoImp.register(edu.kit.pse17.go_app.ServiceLayer.Observer)}{{\bf  register}\\}
\begin{lstlisting}[frame=none]
public void register(edu.kit.pse17.go_app.ServiceLayer.Observer observer)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{observer} -- der Observer, der registriert werden soll. Dabei spielt es keine Rolle, um welche Implementierung eines}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{unregister(Observer)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDaoImp.unregister(edu.kit.pse17.go_app.ServiceLayer.Observer)}{{\bf  unregister}\\}
\begin{lstlisting}[frame=none]
public void unregister(edu.kit.pse17.go_app.ServiceLayer.Observer observer)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{observer} -- Der Observer der aus der Liste entfernt werden soll. es muss vor dem Aufruf dieser Methode sichergestellt werden, dass}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{update(GroupEntity)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDaoImp.update(edu.kit.pse17.go_app.PersistenceLayer.GroupEntity)}{{\bf  update}\\}
\begin{lstlisting}[frame=none]
public void update(edu.kit.pse17.go_app.PersistenceLayer.GroupEntity groupEntity) throws EntityNotFoundException\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{groupEntity} -- }
  \end{itemize}
}%end item
\item{{\bf  Throws}
  \begin{itemize}
   \item{\vskip -.6ex \texttt{EntityNotFoundException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp}Klasse UserDaoImp}{
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp}{}\vskip .1in 
Diese Klasse implementiert die Interfaces UserDao, AbstractDao und Observable. Sie übernimmt die konkreten Datenbankzugriffe auf die Tabelle "users". Dazu werden alle Methoden aus den DAO Interfaces entsprechend implementiert. Aufgerufen werden die Methoden dieser Klasse von den RestController-Klassen, wenn ein Client dem Server eine
Anfrage zur Manipulation seiner Daten geschickt hat. Die Klasse gehört außerdem zu einer Implementierung des Beobachter-Entwurfsmusters und übernimmt dabei die Rolle des konkreten Subjekts. Die Klasse hat eine Liste von Beobachtern, die benachrichtigt werden, wenn sich in der Datenbank eine Änderung ergibt. Es ist die Verantwortung der Beobachter zu entscheiden, ob die  Änderung eine Folgeaktion auslöst oder nicht.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class UserDaoImp
 extends java.lang.Object implements UserDao, AbstractDao, edu.kit.pse17.go_app.ServiceLayer.Observable\end{lstlisting}

\subsubsection{Attribute}{
\begin{verse}
{{\bf private SessionFactory sessionFactory}} Eine Sessionfactory, die Sessions bereitstellt. Die Sessions werden benötigt, damit die Klasse direkt mit der Datenbank
      kommunizieren kann und dort die Änderungen vornehmen. Das Attribut ist mit "@Autowired" annotiert, damit es automatisch
     mit einem gültigen Objekt instanziiert wird.
     
      Auf dieses Feld darf nur innerhalb dieser Klasse zugegriffen werden. Nach der Instanzizerung ist diese Objekt unveränderbar und
      bleibt bestehen, bis die Instanz dieser Klasse wieder zerstört wird.\\[0.5em]
{{\bf private List<Observer> observer}} Eine Liste mit Observern, die benachrichtigt werden, sobald eine Änderung an der Datenbank vorgenommen wird, die auch die Daten anderer Benutzer betrifft.
\end{verse}
}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{UserDaoImp()}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp()}{{\bf  UserDaoImp}\\}
\begin{lstlisting}[frame=none]
public UserDaoImp()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{addUser(UserEntity)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp.addUser(edu.kit.pse17.go_app.PersistenceLayer.UserEntity)}{{\bf  addUser}\\}
\begin{lstlisting}[frame=none]
public void addUser(edu.kit.pse17.go_app.PersistenceLayer.UserEntity user)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{user} -- Die Entity, die in die Datenbank eingefügt werden soll. Dieses Objekt muss eine in der Datenbank noch nicht}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{delete(String)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp.delete(java.lang.String)}{{\bf  delete}\\}
\begin{lstlisting}[frame=none]
public void delete(java.lang.String key) throws EntityNotFoundException\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{key} -- Der Primärschlüssel der Entity, die aus der Datenbanktabelle gelöscht werden soll. Der Datentyp wird durch das Generic PK bei der Implementierung der Klasse spezifiziert.}
  \end{itemize}
}%end item
\item{{\bf  Throws}
  \begin{itemize}
   \item{\vskip -.6ex \texttt{EntityNotFoundException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{deleteUser(String)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp.deleteUser(java.lang.String)}{{\bf  deleteUser}\\}
\begin{lstlisting}[frame=none]
public void deleteUser(java.lang.String userId)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{userId} -- Die userId des Benutzers, dessen Account gelöscht werden soll. Es wird garantiert, dass es sich beim Aufruf}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{get(String)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp.get(java.lang.String)}{{\bf  get}\\}
\begin{lstlisting}[frame=none]
public edu.kit.pse17.go_app.PersistenceLayer.UserEntity get(java.lang.String key)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{key} -- Der Primärschlüssel der Entity, die aus der Datenbank geholt werden soll. Der Datentyp wird von dem Generic PK bestimmt, mit dem das Interface implementiert wird.}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getGroups(String)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp.getGroups(java.lang.String)}{{\bf  getGroups}\\}
\begin{lstlisting}[frame=none]
public java.util.List getGroups(java.lang.String userId)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{userId} -- Die ID des Benutzers, dessen Gruppen zurückgegeben werden sollen. Es wird garantiert, dass es sich beim Aufruf der Methode um eine gültige userid handelt.}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getRequests(String)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp.getRequests(java.lang.String)}{{\bf  getRequests}\\}
\begin{lstlisting}[frame=none]
public java.util.List getRequests(java.lang.String userId)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{userId} -- Die ID des Benutzers, dessen Gruppenanfragen zurückgegeben werden sollen. Es wird garantiert, dass es sich beim Aufruf der Methode um eine gültige userId handelt.}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getUserByEmail(String)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp.getUserByEmail(java.lang.String)}{{\bf  getUserByEmail}\\}
\begin{lstlisting}[frame=none]
public edu.kit.pse17.go_app.PersistenceLayer.UserEntity getUserByEmail(java.lang.String mail)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{mail} -- Die E-Mailadresse, anhand derer der Benutzer gesucht werden soll. Der String muss keinem besonderen Muster entsprechen, damit diese Methode fehlerfrei ausgeführt werden kann.}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
 
}%end item
\end{itemize}
}%end item
\item{ 
\index{notify(String, Observable, UserEntity)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp.notify(java.lang.String, edu.kit.pse17.go_app.ServiceLayer.Observable, edu.kit.pse17.go_app.PersistenceLayer.UserEntity)}{{\bf  notify}\\}
\begin{lstlisting}[frame=none]
public void notify(java.lang.String impCode,edu.kit.pse17.go_app.ServiceLayer.Observable observable,edu.kit.pse17.go_app.PersistenceLayer.UserEntity userEntity)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{impCode} -- Ein Code, der angibt, welche Observer-Implementierung benachrichtigt werden soll. dabei handelt es sich immer um ein öffentliches statisches Attribut in der Observer-Klasse. Handelt es sich um keinen gültigen Implementierungs-Code, wird kein Observer auf das notify() reagieren.}
   \item{
\texttt{observable} -- Eine Instanz des Observables, das die notify()-Methode aufgerufen hat. Durch diese Referenz weiß der Observer, von wo er eine Benachrichtigung bekommen hat.}
   \item{
\texttt{userEntity} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{persist(UserEntity)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp.persist(edu.kit.pse17.go_app.PersistenceLayer.UserEntity)}{{\bf  persist}\\}
\begin{lstlisting}[frame=none]
public void persist(edu.kit.pse17.go_app.PersistenceLayer.UserEntity entity)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{entity} -- Das Entity-Objekt, das in der Datenbank gespeichert werden soll. Es wird garantiert, dass das Objekt, welches der Methode}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{register(Observer)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp.register(edu.kit.pse17.go_app.ServiceLayer.Observer)}{{\bf  register}\\}
\begin{lstlisting}[frame=none]
public void register(edu.kit.pse17.go_app.ServiceLayer.Observer observer)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{observer} -- der Observer, der registriert werden soll. Dabei spielt es keine Rolle, um welche Implementierung eines}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{unregister(Observer)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp.unregister(edu.kit.pse17.go_app.ServiceLayer.Observer)}{{\bf  unregister}\\}
\begin{lstlisting}[frame=none]
public void unregister(edu.kit.pse17.go_app.ServiceLayer.Observer observer)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{observer} -- Der Observer der aus der Liste entfernt werden soll. es muss vor dem Aufruf dieser Methode sichergestellt werden, dass}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{update(UserEntity)}
\hypertarget{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp.update(edu.kit.pse17.go_app.PersistenceLayer.UserEntity)}{{\bf  update}\\}
\begin{lstlisting}[frame=none]
public void update(edu.kit.pse17.go_app.PersistenceLayer.UserEntity userEntity) throws EntityNotFoundException\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{userEntity} -- Die Entity des Users, der geändert werden soll. Dabei muss es sich um eine vorhandene Entity handeln, ansonsten schlägt die Ausführung der Methode fehl.}
  \end{itemize}
}%end item
\item{{\bf  Throws}
  \begin{itemize}
   \item{\vskip -.6ex \texttt{EntityNotFoundException} -- }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
}
\section{Package ClientCommunication.Downstream}{
\label{edu.kit.pse17.go_app.ClientCommunication.Downstream}\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Downstream}{}
\hskip -.05in
\hbox to \hsize{\textit{ Package Contents\hfil Page}}
\vskip .13in
\hbox{{\bf  Classes}}
\entityintro{EventArg}{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg}{Dieses Enum enthält String-Konstanten, die vom FcmClient in die Nachrichten an Clients eingefügt werden, damit der Client anhand der Nachricht feststellen kann, welches Ereignis eingetreten ist.}
\entityintro{FcmClient}{edu.kit.pse17.go_app.ClientCommunication.Downstream.FcmClient}{Client-Klasse, die ein HTTP POST-Request an den FCM-Server schickt, wo die Nachricht wiederum an das User-Endgerät weitergeleitet wird.}
\vskip .1in
\vskip .1in
\subsection{\label{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg}Enum EventArg}{
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg}{}\vskip .1in 
Dieses Enum enthält String-Konstanten, die vom FcmClient in die Nachrichten an Clients eingefügt werden, damit der Client anhand der Nachricht feststellen kann, welches Ereignis eingetreten ist.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public final class EventArg
 extends java.lang.Enum\end{lstlisting}

\subsubsection{Felder}{
\begin{itemize}
\item{
\index{GROUP\_REMOVED\_EVENT}
\label{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg.GROUP_REMOVED_EVENT}\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg.GROUP_REMOVED_EVENT}{\texttt{public static final EventArg\ {\bf  GROUP\_REMOVED\_EVENT}}
}
\begin{itemize}
\item{\vskip -.9ex 
Event wird ausgelöst, falls eine Gruppenentität gelöscht wird. Das Event wird nur an Clients gesendet, die Mitglied in der Gruppe waren bzw. eine Anfrage für diese Gruppe erhalten haben.}
\end{itemize}
}
\item{
\index{MEMBER\_REMOVED\_EVENT}
\label{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg.MEMBER_REMOVED_EVENT}\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg.MEMBER_REMOVED_EVENT}{\texttt{public static final EventArg\ {\bf  MEMBER\_REMOVED\_EVENT}}
}
\begin{itemize}
\item{\vskip -.9ex 
Event wird ausgelöst, falls ein Mitglied aus einer Gruppe gelöscht wird. Dies ist auch der Fall, wenn ein Benutzer seinen Benutzeraccount gelöscht hat. Das Event wird an alle Mitglieder der Gruppe gesendet und an Benutzer, die eine Anfrage für die Gruppe erhalten haben.}
\end{itemize}
}
\item{
\index{GO\_REMOVED\_EVENT}
\label{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg.GO_REMOVED_EVENT}\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg.GO_REMOVED_EVENT}{\texttt{public static final EventArg\ {\bf  GO\_REMOVED\_EVENT}}
}
\begin{itemize}
\item{\vskip -.9ex 
Event wird ausgelöst, falls eine Go-Entität gelöscht wird. Die Benachrichtigung muss an alle Benutzer geschickt werden, die Mitglied in der Gruppe des GOs sind bzw. eine Gruppenanfrage für diese Gruppe haben.}
\end{itemize}
}
\item{
\index{MEMBER\_ADDED\_EVENT}
\label{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg.MEMBER_ADDED_EVENT}\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg.MEMBER_ADDED_EVENT}{\texttt{public static final EventArg\ {\bf  MEMBER\_ADDED\_EVENT}}
}
\begin{itemize}
\item{\vskip -.9ex 
Event wird ausgelöst, falls ein neues Mitglied zu einer Gruppe hinzugefügt wurde (also ein Benutzer ein Gruppenanfrage bestätigt hat). Die Benachrichtigung muss an alle Benutzer geschickt werden, die Mitglied in der Gruppe sind bzw. eine Gruppenanfrage für diese Gruppe haben.}
\end{itemize}
}
\item{
\index{GROUP\_REQUEST\_RECEIVED\_EVENT}
\label{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg.GROUP_REQUEST_RECEIVED_EVENT}\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg.GROUP_REQUEST_RECEIVED_EVENT}{\texttt{public static final EventArg\ {\bf  GROUP\_REQUEST\_RECEIVED\_EVENT}}
}
\begin{itemize}
\item{\vskip -.9ex 
Event wird ausgelöst, wenn ein Benutzer eine Anfrage für eine Gruppe bekommen hat. Die Benachrichtigung wird an diesen Benutzer und an alle Mitglieder der Gruppe gesendet bzw. Benutzer, die eine Gruppenanfrage für diese Gruppe haben.}
\end{itemize}
}
\item{
\index{GO\_ADDED\_EVENT}
\label{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg.GO_ADDED_EVENT}\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg.GO_ADDED_EVENT}{\texttt{public static final EventArg\ {\bf  GO\_ADDED\_EVENT}}
}
\begin{itemize}
\item{\vskip -.9ex 
Event wird ausgelöst, wenn ein neues GO in einer Gruppe erstellt wurde. Die Benachrichtigung muss an alle Benutzer geschickt werden, die Mitglied in der Gruppe sind bzw. eine Gruppenanfrage für diese Gruppe haben.}
\end{itemize}
}
\item{
\index{GO\_EDITED\_COMMAND}
\label{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg.GO_EDITED_COMMAND}\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg.GO_EDITED_COMMAND}{\texttt{public static final EventArg\ {\bf  GO\_EDITED\_COMMAND}}
}
\begin{itemize}
\item{\vskip -.9ex 
Event wird ausgelöst, wenn die Daten in einem GO verändert werden. Die Benachrichtigung muss an alle Benutzer geschickt werden, die Mitglied in der Gruppe sind bzw. eine Gruppenanfrage für diese Gruppe haben.}
\end{itemize}
}
\item{
\index{GROUP\_EDITED\_COMMAND}
\label{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg.GROUP_EDITED_COMMAND}\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg.GROUP_EDITED_COMMAND}{\texttt{public static final EventArg\ {\bf  GROUP\_EDITED\_COMMAND}}
}
\begin{itemize}
\item{\vskip -.9ex 
Event wird ausgelöst, wenn die Daten in einer Gruppe verändert werden. Die Benachrichtigung muss an alle Benutzer geschickt werden, die Mitglied in der Gruppe sind bzw. eine Gruppenanfrage für diese Gruppe haben.}
\end{itemize}
}
\item{
\index{ADMIN\_ADDED\_EVENT}
\label{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg.ADMIN_ADDED_EVENT}\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg.ADMIN_ADDED_EVENT}{\texttt{public static final EventArg\ {\bf  ADMIN\_ADDED\_EVENT}}
}
\begin{itemize}
\item{\vskip -.9ex 
Event wird ausgelöst, wenn ein Administrator zu einer Gruppe hinzugefügt wurde. Die Benachrichtigung muss an alle Benutzer geschickt werden, die Mitglied in der Gruppe sind bzw. eine Gruppenanfrage für diese Gruppe haben.}
\end{itemize}
}
\item{
\index{STATUS\_CHANGED\_COMMAND}
\label{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg.STATUS_CHANGED_COMMAND}\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg.STATUS_CHANGED_COMMAND}{\texttt{public static final EventArg\ {\bf  STATUS\_CHANGED\_COMMAND}}
}
\begin{itemize}
\item{\vskip -.9ex 
Event wird ausgelöst, wenn ein GO-Teilnehmer seinen Teilnehmerstatus verändert hat. Die Benachrichtigung muss an alle Benutzer geschickt werden, die Mitglied in der Gruppe des GOs sind bzw. eine Gruppenanfrage für diese Gruppe haben.}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{valueOf(String)}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg.valueOf(java.lang.String)}{{\bf  valueOf}\\}
\begin{lstlisting}[frame=none]
public static EventArg valueOf(java.lang.String name)\end{lstlisting} %end signature
}%end item
\item{ 
\index{values()}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Downstream.EventArg.values()}{{\bf  values}\\}
\begin{lstlisting}[frame=none]
public static EventArg[] values()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{von Enum geerbte Methoden}{
\texttt{java.lang.Enum} {\small 
\refdefined{java.lang.Enum}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{protected final Object {\bf  clone}() throws CloneNotSupportedException
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public final int {\bf  compareTo}(\texttt{Enum} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public final boolean {\bf  equals}(\texttt{Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{protected final void {\bf  finalize}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public final Class {\bf  getDeclaringClass}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public final int {\bf  hashCode}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public final String {\bf  name}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public final int {\bf  ordinal}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public String {\bf  toString}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public static Enum {\bf  valueOf}(\texttt{Class} {\bf  arg0},
\texttt{String} {\bf  arg1})
}%end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.ClientCommunication.Downstream.FcmClient}Klasse FcmClient}{
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Downstream.FcmClient}{}\vskip .1in 
Client-Klasse, die ein HTTP POST-Request an den FCM-Server schickt, wo die Nachricht wiederum an das User-Endgerät weitergeleitet wird. Dadurch kann der Server eine Nachricht an einen Client schicken, ohne dass dieser zuvor den Server angesprochen haben muss. Die Methoden der Klasse werden aufgerufen von den Observer-Klassen der Anwendung. Dabei werden die Nachrichten, die an die Clients gesendet werden müssen, sowie die Adressdaten bereits in den aufrufenden Methoden bestimmt. Diese Klasse muss sich nur um das eigentliche Senden der HTTP-Requests kümmern, der Inhalt der Nachricht spielt dabei keine Rolle.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class FcmClient
 extends java.lang.Object\end{lstlisting}

\subsubsection{Attribute}{
\begin{verse}
{{\bf private static final String BASE\_URL}} Base URL des FCM-Servers an den die Requests geschickt werden müssen. Dieser Wert darf sich nicht ändern.\\[0.5em]
{{\bf private HttpClinet httpClient}} Ein Http-Client, der für das Senden der HTTP-Requests zuständig ist. Die Konfiguration des HttpClients wird bei der Erstellung des FcmClient-Objekts vorgenommen. Die Konfiguration wird von dem Firebase Cloud Messaging Service vorgegeben.\\[0.5em]
\end{verse}
}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{FcmClient()}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Downstream.FcmClient()}{{\bf  FcmClient}\\}
\begin{lstlisting}[frame=none]
public FcmClient()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Die Klasse bietet einen Konstruktor an, der keine Argumente entgegen nimmt. In dem Konstruktor wird die Konfiguration des HttpClients standardmäßig implementiert, sodass er Anfragen an die von FCM definierte URL schicken kann.
}
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{send(JsonObject, String, List)}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Downstream.FcmClient.send(JsonObject, java.lang.String, java.util.List)}{{\bf  send}\\}
\begin{lstlisting}[frame=none]
public void send(JsonObject data,java.lang.String command,java.util.List receiver)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Die Methode einen POST-Request an den FCM-Server, der diese an das User-Endgerät weiterleitet. Dafür wird der HttpClient der FcmClient-Instanz benutzt. Diese Methode wird von den Observer-Klassen aufgerufen, um die Änderungen, die dort behandelt wurden mithilfe dieser Klasse an die Clients zu schicken. Es wird vorausgesetzt, dass die Daten und vor allem die InstanceIDs, die dieser Methode übergeben werden, gültig sind.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{data} -- Dieses Objekt enthält die Daten, die an den Client geschickt werden sollen}
   \item{
\texttt{command} -- Ein String, der anzeigt, um was für eine Nachricht es sich handelt, also zu welchem Serverereignis sie gehört. Dieser String bestimmt, an welche Command-Klasse auf dem Client die Nachricht weitergeleitet wird.}
   \item{
\texttt{receiver} -- Eine Liste mit den InstaceIds der Clients,an die die Nachricht geschickt werden soll. dabei muss es sich um gültige InstanceIds handeln, sonst kann die Methode nicht fehlerfrei ausgeführt werden.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
}
\section{Package ClientCommunication.Upstream}{
\label{edu.kit.pse17.go_app.ClientCommunication.Upstream}\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream}{}

\subsection{\label{edu.kit.pse17.go_app.ClientCommunication.Upstream.GoRestController}Klasse GoRestController}{
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.GoRestController}{}\vskip .1in 
Die Klasse GORestController gehört zum Upstream ClientCommunication Modul und bildet einen Teil der REST API, die der Tomcat Server den Clients zur Kommunikation anbietet. Die Aufgabe dieser Klasse ist die Abwicklung von REST-Requests, die User-spezifische Anfragen beinhalten. Dazu gehört: - das Empfangen und Senden von HTTP-Requests - das Parsen der empfangenen / zu sendenden Daten von bzw. nach JSON - das Weiterleiten der Anfragen zur Bearbeitung an die richtige Stelle im Programm (das UserDAO) Das REST API wird umgesetzt von dem Java Framework Spring, anhand der Annotationen der Methoden in dieser Klasse. Die Klasse selbst ist annotiert mit "@RestController", um zu signalisieren, dass es sich um eine Klasse handelt, deren Methoden REST Resourcen beschreiben. Die Methoden dieser Klasse sind auf die URL \{Base\_URL\}/gos gemappt. Die Methoden der Klasse werden aufgerufen, von den Methoden des Interfaces "TomcatRestApi", das von den Clients des Systems verwendet wird. Bei einem Methodenaufruf in dieser Klasse, wird die Anfrage an die DAOs der MySQL Datenbank der Anwendung weitergeleitet. Von dort werden die richtigen Daten geholt (falls der Client bestimmte Daten in der Antwort erwartet). Danach werden die Daten von dieser Klasse in JSON-Objekte umgewandelt (mithilfe der Gson Library) und dem Client in der Antwort zugesendet. Nähere Erläuterungen zum JSON-Schema und der Konvertierung finden sich im Entwurfsdokument.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GoRestController
 extends java.lang.Object\end{lstlisting}

\subsubsection{Attribute}{
\begin{verse}
{{\bf private GoDao goDao}} Ein Objekt einer Klasse, die das Interface GoDao implementiert. Dieses Objekt besitzt Methoden, um auf die Datenbank des Systems zuzugreifen und Daten zu manipulieren. Es wird benötigt, um die Anfragen, die durch die REST Calls an den Server gestellt werden, umzusetzen.
\end{verse}
}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GoRestController()}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.GoRestController()}{{\bf  GoRestController}\\}
\begin{lstlisting}[frame=none]
public GoRestController()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{changeStatus(long, String, Status)}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.GoRestController.changeStatus(long, java.lang.String, edu.kit.pse17.go_app.PersistenceLayer.Status)}{{\bf  changeStatus}\\}
\begin{lstlisting}[frame=none]
public void changeStatus(long goId,java.lang.String userId,edu.kit.pse17.go_app.PersistenceLayer.Status status)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode wird von einem Client aufgerufen, um seinen Teilnehmerstatus in einem Go zu ändern. IN der Methode werden die Anfrage-Daten aus dem Request Body ausgewertet und an das goDao weitergegeben, um die entsprechenden Änderungen in der Datenbank vorzunehmen. Es ist garantiert, dass der Benutzer ein Mitglied des GOs ist und das er die geforderte Statusänderung vornehmen darf. Der Aufruf dieser Methode entspricht einem HTTP PUT-Request an den Server an die URL \{Base\_URL\}/gos/status.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{goId} -- Die ID des GOs, in dem der Benutzer seinen Teilnahmestatus ändern will. es muss sich dabei um eine gültige Go-ID sein, ansonsten schlägt die Anfrage fehl. Die ID muss sich zu einem long casten lassen.}
   \item{
\texttt{userId} -- Die ID des Users, der seinen Teilnahmestatus ändern will. Diese ID muss eine gültige, auf dem System registrierte User ID sein.}
   \item{
\texttt{status} -- Der neue Status des Clients. Dieser hat entweder den Wert "Abgelehnt", "Bestätigt" oder "Losgegangen". }
\end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{createGo(String, String, Date, Date, double, double, int, long, String)}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.GoRestController.createGo(java.lang.String, java.lang.String, java.util.Date, java.util.Date, double, double, int, long, java.lang.String)}{{\bf  createGo}\\}
\begin{lstlisting}[frame=none]
public long createGo(java.lang.String name,java.lang.String description,java.util.Date start,java.util.Date end,double lat,double lon,int threshold,long groupId,java.lang.String userId)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode wird von einem Client aufgerufen, wenn eine neue Gruppe erstellt werden soll. Die Methode liest die Argumente aus dem Request Body der HTTP Anfrage aus und übergibt diese an das goDao zur Erzeugung des GOs in der Datenbank. Zusätzlich zur Erzeugung des GOs wird der Ersteller als Verantwortlicher des GOs gespeichert und für jedes Gruppenmitglied der Teilnahmestatus 'Abgelehnt' gespeichert. es ist garantiert, dass der Client, der die Methode aufruft eine Mitglied in der Gruppe ist, in der das GO erstellt werden soll. Der Aufruf dieser Methode entspricht einem HTTP POST-Request an den Server an die URL \{Base\_URL\}/gos.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{name} -- Der Name des GOs. Es handelt sich um einen String, der bis zu 50 Zeichen enthält.}
   \item{
\texttt{description} -- Eine Beschreibung für das GO. Diese Argument dar den wert null annehmen. Ist der Wert nicht null, darf der String bis zu 140 Zeichen enthalten.}
   \item{
\texttt{start} -- Ein Datum mit Uhrzeit an dem das GO beginnt. Dieses Datum darf nicht in der Vergangenheit liegen.}
   \item{
\texttt{end} -- Ein Datum mit Uhrzeit an dem das GO zu Ende ist. Dieses Datum darf nicht vor dem Startdatum liegen.}
   \item{
\texttt{lat} -- Der geographische Breitengrad des Zielorts des GOs. Der Wert muss als Breitengrad interpretierbar sein, muss also zwischen +90 und -90 liegen. Der Wert darf außerdem "null" sein, falls kein Zielort für das GO ausgewählt wurde.}
   \item{
\texttt{lon} -- Der geographische Längengrad des Zielorts des GOs. Der Wert muss als Breitengrad interpretierbar sein, muss also zwischen +180 und -180 liegen. Der Wert darf außerdem "null" sein, falls kein Zielort für das GO ausgewählt wurde.}
   \item{
\texttt{threshold} -- Ein Schwellwert für die Genauigkeit, mit der der Clustering-Algorithmus ausgeführt wird. Der Wert liegt zwischen 1 (sehr ungenau) und 10 (sehr genau). Wird der Wert in dem Request Body nicht spezifiziert wird default-mäßig ein Wert von 5 gespeichert.}
   \item{
\texttt{groupId} -- Die ID der Gruppe, in der das GO angelegt werden soll. Der Wert muss eine gültige Group-ID sein und sich zu einem Long casten lassen.}
   \item{
\texttt{userId} -- Die ID des Benutzers, der das GO erstellt. Der Wert muss eine gültige UserID sein. Dieser Benutzer wird als GO-Verantwortlicher gespeichert.}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
Die Methode gibt in der Antwort die im System eindeutige ID des Gos zurück. Diese wird im Header der HTTP-Response im Location-Feld an den Client zurückgesendet, also : \{Base\_URL\}/gos/\{goId\}\ und kann dort vom Client ausgelesen werden. Der Wert ist eine positive ganze Zahl, die im Wertebereich des primitiven Datentyps long liegt. 
}%end item
\end{itemize}
}%end item
\item{ 
\index{deleteGo(String)}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.GoRestController.deleteGo(java.lang.String)}{{\bf  deleteGo}\\}
\begin{lstlisting}[frame=none]
public void deleteGo(java.lang.String goId)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode wird von einem Client aufgerufen, wenn er ein GO löschen möchte. Durch einen Methodenaufruf bei dem goDao wird das GO entsprechend aus der Datenbank entfernt. Es ist garantiert, dass der Client, der die Gruppe aufruft dazu berechtigt ist, d.h. er der GO-Verantwortliche des GOs ist. Der Aufruf dieser Methode entspricht einem HTTP DELETE-Request an den Server an die URL \{Base\_URL\}/gos/\{goId\}.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{goId} -- Die ID des GOs, das gelöscht werden soll. Der Wert dieses Arguments ist Teil der URL der REST Resource und wird entsprechend von Spring extrahiert und der Methode bereitgestellt. Die ID muss gülti sein und zu einem Long-Datentyp gecastet werden können.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{editGo(String, String, String, Date, Date, long, long, int)}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.GoRestController.editGo(java.lang.String, java.lang.String, java.lang.String, java.util.Date, java.util.Date, long, long, int)}{{\bf  editGo}\\}
\begin{lstlisting}[frame=none]
public void editGo(java.lang.String goId,java.lang.String name,java.lang.String description,java.util.Date start,java.util.Date end,long lat,long lon,int threshold)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode wird von einem Benutzer aufgerufen, wenn er die Daten eines GOs ändern will. Zu den Daten, die mit dieser Methode geändert werden können, gehören: - der GO-Name - die GO-Beschreibung - Der Anfangs- und Endzeitpunkt - Der Zielort - Der Clustering-Schwellwert Es ist garantiert, dass dieser Aufruf nur von einem Go-Verantwortlichen des zu ändernden GOs kommt. Der Aufruf dieser Methode entspricht einem HTTP PUT-Request an den Server an die URL \{Base\_URL\}/gos/\{goId\}. Abgesehen von der Go ID, können sämtliche Argumente dieser Methode den Wert null annehmen. Dies signalisiert der Methode, das der Wert nicht geändert wurde und die bisherigen Daten beibehalten werden sollen.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{goId} -- Die ID des GOs, das gelöscht werden soll. Der Wert dieses Arguments ist Teil der URL der REST Resource und wird entsprechend von Spring extrahiert und der Methode bereitgestellt. Die ID muss gültig sein und zu einem Long-Datentyp gecastet werden können.}
   \item{
\texttt{name} -- Der Name des GOs. Es handelt sich um einen String, der bis zu 50 Zeichen enthält.}
   \item{
\texttt{description} -- Eine Beschreibung für das GO. Diese Argument dar den wert null annehmen. Ist der Wert nicht null, darf der String bis zu 140 Zeichen enthalten.}
   \item{
\texttt{start} -- Ein Datum mit Uhrzeit an dem das GO beginnt. Dieses Datum darf nicht in der Vergangenheit liegen.}
   \item{
\texttt{end} -- Ein Datum mit Uhrzeit an dem das GO zu Ende ist. Dieses Datum darf nicht vor dem Startdatum liegen.}
   \item{
\texttt{lat} -- Der geographische Breitengrad des Zielorts des GOs. Der Wert muss als Breitengrad interpretierbar sein, muss also zwischen +90 und -90 liegen. Der Wert darf außerdem "null" sein, falls kein Zielort für das GO ausgewählt wurde.}
   \item{
\texttt{lon} -- Der geographische Längengrad des Zielorts des GOs. Der Wert muss als Breitengrad interpretierbar sein, muss also zwischen +180 und -180 liegen. Der Wert darf außerdem "null" sein, falls kein Zielort für das GO ausgewählt wurde.}
   \item{
\texttt{threshold} -- Ein Schwellwert für die Genauigkeit, mit der der Clustering-Algorithmus ausgeführt wird. Der Wert liegt zwischen 1 (sehr ungenau) und 10 (sehr genau). Wird der Wert in dem Request Body nicht spezifiziert wird default-mäßig ein Wert von 5 gespeichert.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{getLocation(String)}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.GoRestController.getLocation(java.lang.String)}{{\bf  getLocation}\\}
\begin{lstlisting}[frame=none]
public java.util.List getLocation(java.lang.String goId)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Die Methode gibt eine Liste mit Cluster-Objekten zurück, die die aktuellen Positionen der Go-Mitglieder beschreiben. Diese Methode, wird von Clients periodisch aufgerufen, um während eines GOs die Standorte der anderen Mitglieder zu erfahren. Um den eigenen Standort mit den anderen Mitgliedern zu teilen, wird nicht diese Methode verwendet, sondern die Methode setLocation(). Im Gegensatz zu den meisten anderen Methoden der restController-Klassen, wird diese Anfrage nicht an eine DAO Objekt weitergeleitet. Da die Standort-Daten nicht langfristig gespeichert werden müssen, wird die Anfrage an ein locationService Objekt gegeben und dort behandelt. Es ist garantiert, dass der Benutzer, der diese Methode aufruft, dazu berechtigt ist, die Standorte der anderen Mitglieder zu erfahren. Der Aufruf dieser Methode entspricht einem HTTP GET-Request an den Server an die URL \{Base\_URL\}/gos/location/\{goId\}.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{goId} -- Die ID des GOs, dessen Location-Daten angefragt werden. Dabei muss es sich um eine gültige GO ID handeln, die sich zu einem Long casten lässt. Der Wert dieses Arguments ist Teil der URL der REST Resource und wird entsprechend von Spring extrahiert und der Methode bereitgestellt.}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
Eine Liste mit Clustern. Ein Cluster besteht dabei aus drei Feldern: Der Längen- und Breitengrad der Position des Clusters und der Größe, also der Anzahl an Personen, die sich in diesem Cluster befinden. Der Rückgabewert dieser Methode kann auch null sein, z.B. dann wenn für das Clustering zu wenig Personen an dem GO teilnehmen. Maximal besteht die Liste aus 50 Clustern, da die Anzahl der Gruppenmitglieder auf 50 beschränkt ist. 
}%end item
\end{itemize}
}%end item
\item{ 
\index{setLocation(String, long, long, String)}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.GoRestController.setLocation(java.lang.String, long, long, java.lang.String)}{{\bf  setLocation}\\}
\begin{lstlisting}[frame=none]
public void setLocation(java.lang.String userId,long lat,long lon,java.lang.String goId)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode wird von einem Client aufgerufen, um seinen Standort für das Clustering dem Server mitzuteilen. Der übermittelte Standort wird aus dem RequestBody ausgelesen und zur Weiterverarbeitung an den locationService weitergeleitet. Es wird garantiert, dass der Client, der diese Methode aufruft, ein aktiver Teilnehmer des entsprechenden GOs ist. Der Aufruf dieser Methode entspricht einem HTTP PUT-Request an den Server an die URL \{Base\_URL\}/gos/location/\{goId\}.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{userId} -- Die ID des Benutzers, der seinen Standort teilen will. Dabei muss es sich um eine gültige, im System registrierte UserID handeln.}
   \item{
\texttt{lat} -- Der geographische Breitengrad des Standorts des Benutzers. Der Wert muss als Breitengrad interpretierbar sein, muss also zwischen +90 und -90 liegen.}
   \item{
\texttt{lon} -- Der geographische Längengrad des Standorts des Benutzers. Der Wert muss als Längengrad interpretierbar sein, muss also zwischen +180 und -180 liegen.}
   \item{
\texttt{goId} -- Die ID des GOs, zu dessen Location-Daten der Standort des Benutzers gehört. Dabei muss es sich um eine gültige GO ID handeln, die sich zu einem Long casten lässt. Der Wert dieses Arguments ist Teil der URL der REST Resource und wird entsprechend von Spring extrahiert und der Methode bereitgestellt.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.ClientCommunication.Upstream.GroupRestController}Klasse GroupRestController}{
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.GroupRestController}{}\vskip .1in 
Die Klasse GroupRestController gehört zum Upstream ClientCommunication Modul und bildet einen Teil der REST API, die der Tomcat Server den Clients zur Kommunikation anbietet. Die Aufgabe dieser Klasse ist die Abwicklung von REST-Requests, die Gruppen-spezifische Anfragen beinhalten. Dazu gehört: - das Empfangen und Senden von HTTP-Requests - das Parsen der empfangenen / zu sendenden Daten von bzw. nach JSON - das Weiterleiten der Anfragen zur Bearbeitung an die richtige Stelle im Programm (das GroupDAO) Das REST API wird umgesetzt von dem Java Framework Spring, anhand der Annotationen der Methoden in dieser Klasse. Die Klasse selbst ist annotiert mit "@RestController", um zu signalisieren, dass es sich um eine Klasse handelt, deren Methoden Rest Resourcen beschreiben. Die Methoden dieser Klasse sind auf die URL \{Base\_URL\}/groups gemappt. Die Methoden der Klasse werden aufgerufen, von den Methoden des Interfaces "TomcatRestApi", das von den Clients des Systems verwendet wird. Bei einem Methodenaufruf in dieser Klasse, wird die Anfrage an die DAOs der MySQL Datenbank der Anwendung weitergeleitet. Von dort werden die richtigen Daten geholt (falls der Client bestimmte Daten in der Antwort erwartet). Danach werden die Daten von dieser Klasse in JSON-Objekte umgewandelt (mithilfe der Gson Library) und dem Client in der Antwort zugesendet. Nähere Erläuterungen zum JSON-Schema und der Konvertierung finden sich im Entwurfsdokument.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GroupRestController
 extends java.lang.Object\end{lstlisting}

\subsubsection{Attribute}{
\begin{verse}
{{\bf private GroupDao groupDao}} Ein Objekt einer Klasse, die das Interface GroupDao implementiert. Dieses Objekt besitzt Methoden, um auf die Datenbank des Systems zuzugreifen und Daten zu manipulieren. Es wird benötigt, um die Anfragen, die durch die REST Calls an den Server gestellt werden, umzusetzen.
\end{verse}
}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GroupRestController()}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.GroupRestController()}{{\bf  GroupRestController}\\}
\begin{lstlisting}[frame=none]
public GroupRestController()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{acceptRequest(Long, String)}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.GroupRestController.acceptRequest(java.lang.Long, java.lang.String)}{{\bf  acceptRequest}\\}
\begin{lstlisting}[frame=none]
public void acceptRequest(java.lang.Long groupId,java.lang.String userId)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode wird dann aufgerufen, wenn ein Benutzer eine bestehende Gruppenmitgliedschaftsanfrage bestätigt und somit zu einem vollwertigen Mitglied der Gruppe wird. Bei einem Aufruf, müssen zwei Methoden des GroupDaos aufgerufen werden: Zunächst muss die Mitgliedschaftsanfrage, die soeben beantwortet wurde, gelöscht werden, danach muss der Benutzer als Mitglied in die Gruppe eingefügt werden. Der Aufruf dieser Methode entspricht einem HTTP PUT-Request an den Server an die URL \{Base\_URL\}/groups/members/\{groupId\}/\{userId\}.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{groupId} -- Die ID der Gruppe, zu der der Benutzer hinzugefügt werden soll. Der Wert dieses Arguments ist Teil der URL der REST Resource und wird entsprechend von Spring extrahiert und der Methode bereitgestellt. Die ID muss zu einem Long-Datentyp gecastet werden können.}
   \item{
\texttt{userId} -- Die ID des Benutzers, der der Gruppe hinzugefügt werden soll. Der Wert dieses Arguments ist Teil der URL der REST Resource und wird entsprechend von Spring extrahiert und der Methode bereitgestellt.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{addAdmin(String, String)}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.GroupRestController.addAdmin(java.lang.String, java.lang.String)}{{\bf  addAdmin}\\}
\begin{lstlisting}[frame=none]
public void addAdmin(java.lang.String groupId,java.lang.String userId)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode wird aufgerufen, wenn ein Administrator einer Gruppe ein anderes Gruppenmitglied zu Administrator ernennen will. In der Methode wird eine Methode des groupDaos aufgerufen, die einen Datenbankzugriff ausführt und den entsprechenden Benutzer zu den Administratoren der Gruppe hinzufügt. Es ist garantiert, dass der aufrufende Client ein Administrator der Gruppe ist und der neue Administrator bereits ein Gruppenmitglied ist. Der Aufruf dieser Methode entspricht einem HTTP POST-Request an den Server an die URL \{Base\_URL\}/groups/admins/\{groupId\}/\{userId\}.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{groupId} -- Die ID der Gruppe, in der der neue Administrator hinzugefügt werden soll. Der Wert dieses Arguments ist Teil der URL der REST Resource und wird entsprechend von Spring extrahiert und der Methode bereitgestellt. Die ID muss zu einem Long-Datentyp gecastet werden können.}
   \item{
\texttt{userId} -- Die ID des Benutzer, der zum Administrator ernannt wird. Der Wert dieses Arguments ist Teil der URL der REST Resource und wird entsprechend von Spring extrahiert und der Methode bereitgestellt.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{createGroup(String, String, String)}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.GroupRestController.createGroup(java.lang.String, java.lang.String, java.lang.String)}{{\bf  createGroup}\\}
\begin{lstlisting}[frame=none]
public long createGroup(java.lang.String name,java.lang.String description,java.lang.String userId)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode wird von einem Client aufgerufen, wenn eine neue Gruppe erstellt werden soll. Die Methode liest die Argumente aus dem Request Body der HTTP Anfrage aus und übergibt diese an das groupDao zur Erzeugung der Gruppe in der Datenbank. Zusätzlich zur Erzeugung der Gruppe wird der Ersteller als Gruppenmitglied und Administrator zur Gruppe hinzugefügt. Der Aufruf dieser Methode entspricht einem HTTP POST-Request an den Server an die URL \{Base\_URL\}/groups.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{name} -- Der Name, den die Gruppe haben soll. Der String darf bis zu 50 Zeichen lang sein.}
   \item{
\texttt{description} -- Eine Gruppenbeschreibung. Dieser Wert ist möglicherweise nicht im Body der HTTP Nachricht enthalten. Das bedeutet der Benutzer hat keine Beschreibung eingegeben. Die Variable wird daraufhin auf null gesetzt. ist der Wert nicht null, darf der String maximal 140 Zeichen enthalten.}
   \item{
\texttt{userId} -- Die ID des Benutzers, der die Gruppe erstellt hat.}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
Die global eindeutige ID, die der Gruppe zugewiesen wurde. Diese wird im Header der HTTP-Response im Location-Feld an den Client zurückgesendet, also : \{Base\_URL\}/gos/\{goId\}\ und kann dort vom Client ausgelesen werden. Der Wert ist eine positive ganze Zahl, die im Wertebereich des primitiven Datentyps long liegt. 
}%end item
\end{itemize}
}%end item
\item{ 
\index{deleteGroup(Long)}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.GroupRestController.deleteGroup(java.lang.Long)}{{\bf  deleteGroup}\\}
\begin{lstlisting}[frame=none]
public void deleteGroup(java.lang.Long groupId)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode wird von einem Client aufgerufen, wenn er eine Gruppe löschen möchte. Durch einen Methodenaufruf bei dem groupDao wird die Gruppe entsprechend aus der Datenbank entfernt. Durch Konsistenzkriterien in der Datenbank werden zusätzlich alle GOs, die es in der Gruppe gab ebenfalls entfernt. Es ist garantiert, dass der Client, der die Gruppe aufruft dazu berechtigt ist, d.h. er ein Administrator der Gruppe ist. Der Aufruf dieser Methode entspricht einem HTTP DELETE-Request an den Server an die URL \{Base\_URL\}/groups/\{groupId\}.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{groupId} -- Die ID der Gruppe, die gelöscht werden soll. Der Wert dieses Arguments ist Teil der URL der REST Resource und wird entsprechend von Spring extrahiert und der Methode bereitgestellt. Die ID muss zu einem Long-Datentyp gecastet werden können.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{denyRequest(String, String)}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.GroupRestController.denyRequest(java.lang.String, java.lang.String)}{{\bf  denyRequest}\\}
\begin{lstlisting}[frame=none]
public void denyRequest(java.lang.String groupId,java.lang.String userId)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode wird aufgerufen, wenn ein Benutzer eine Gruppenmitgliedschaftsanfrage ablehnt. Beim Aufruf wird das groupDAO dazu veranlasst, die Anfrage aus der Datenbank zu löschen. Der Aufruf dieser Methode entspricht einem HTTP POST-Request an den Server an die URL \{Base\_URL\}/groups/requests/\{groupId\}/\{userId\}.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{groupId} -- Die ID der Gruppe, zu die der Benutzer eingeladen war. Der Wert dieses Arguments ist Teil der URL der REST Resource und wird entsprechend von Spring extrahiert und der Methode bereitgestellt. Die ID muss zu einem Long-Datentyp gecastet werden können.}
   \item{
\texttt{userId} -- Die ID des Benutzers, der die Anfrage abgelehnt hat. Der Wert dieses Arguments ist Teil der URL der REST Resource und wird entsprechend von Spring extrahiert und der Methode bereitgestellt.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{editGroup(Long, String, String)}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.GroupRestController.editGroup(java.lang.Long, java.lang.String, java.lang.String)}{{\bf  editGroup}\\}
\begin{lstlisting}[frame=none]
public void editGroup(java.lang.Long groupId,java.lang.String name,java.lang.String description)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode wird von einem Benutzer aufgerufen, wenn er die Daten der Gruppe ändern will. Zu den Daten, die mit dieser Methode geändert werden können, gehören: - der Gruppenname - die Gruppenbeschreibung Es ist garantiert, dass dieser Aufruf nur von einem Administrator der zu ändernden Gruppe kommt. Der Aufruf dieser Methode entspricht einem HTTP PUT-Request an den Server an die URL \{Base\_URL\}/groups/\{groupId\}.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{groupId} -- Die ID der Gruppe, die geändert werden soll. Der Wert dieses Arguments ist Teil der URL der REST Resource und wird entsprechend von Spring extrahiert und der Methode bereitgestellt. Die ID muss zu einem Long-Datentyp gecastet werden können.}
   \item{
\texttt{description} -- Die neue Beschreibung, die die Gruppe erhalten soll. Dieser Wert kann null sein, falls die Beschreibung nicht geändert wird. Der Wert des Attributs ist im request Body der Anfrage gespeichert und wird von Spring ausgelesen und der Methode zur Verfügung gestellt.}
   \item{
\texttt{name} -- Der neue Name, den die Gruppe erhalten soll. Dieser Wert kann null sein, falls der Name nicht geändert wird. Der Wert des Attributs ist im request Body der Anfrage gespeichert und wird von Spring ausgelesen und der Methode zur Verfügung gestellt.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{inviteMember(Long, String)}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.GroupRestController.inviteMember(java.lang.Long, java.lang.String)}{{\bf  inviteMember}\\}
\begin{lstlisting}[frame=none]
public void inviteMember(java.lang.Long groupId,java.lang.String userId)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode wird von einem Client aufgerufen, der einen Benutzer zu einer Gruppe einladen will. Bei Aufruf dieser Methode wird mittels des groupDAOs die Information über den Group Request in der Datenbank gespeichert. Es ist garantiert, dass der Client, der diese Methode aufruft ein Administrator ist und der eingeladene Benutzer nicht bereits Mitglied der Gruppe ist. Diese Vorbedingungen müssen in der Methode nicht überprüft werden. Der Aufruf dieser Methode entspricht einem HTTP POST-Request an den Server an die URL \{Base\_URL\}/groups/requests/\{groupId\}/\{userId\}.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{groupId} -- Die ID der Gruppe, zu der der Benutzer eingeladen werden soll. Der Wert dieses Arguments ist Teil der URL der REST Resource und wird entsprechend von Spring extrahiert und der Methode bereitgestellt. Die ID muss zu einem Long-Datentyp gecastet werden können.}
   \item{
\texttt{userId} -- Die ID des Benutzers, der zu der Gruppe eingeladen werden soll. Der Wert dieses Arguments ist Teil der URL der REST Resource und wird entsprechend von Spring extrahiert und der Methode bereitgestellt.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{removeMember(String, String)}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.GroupRestController.removeMember(java.lang.String, java.lang.String)}{{\bf  removeMember}\\}
\begin{lstlisting}[frame=none]
public void removeMember(java.lang.String userId,java.lang.String groupId)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode kann von einem Client aufgerufen werden, wenn ein Gruppenmitglied aus einer Gruppe entfernt werden soll. Dies kann der Fall sein, wenn ein Benutzer freiwillig aus einer Gruppe austritt oder wenn er von einem Administrator aus der Gruppe entfernt wird. Bei einem Aufruf leitet die Methode die Anfrage an die entsprechende Methode des groupDAOs weiter. Dies entfernt den Benutzer aus der Gruppe. Durch Foreign Key Constraints in der Datenbank wird der Benutzer auch aus allen GOs der Gruppe entfernt. Darum muss sich diese Methode demnach nicht kümmern. Der Aufruf dieser Methode entspricht einem HTTP POST-Request an den Server an die URL \{Base\_URL\}/groups/members/\{groupId\}/\{userId\}.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{userId} -- Die ID des Benutzers, der aus der Gruppe entfernt werden soll. Der Wert dieses Arguments ist Teil der URL der REST Resource und wird entsprechend von Spring extrahiert und der Methode bereitgestellt.}
   \item{
\texttt{groupId} -- Die ID der Gruppe, aus der der Benutzer entfernt werden soll. Der Wert dieses Arguments ist Teil der URL der REST Resource und wird entsprechend von Spring extrahiert und der Methode bereitgestellt. Die ID muss zu einem Long-Datentyp gecastet werden können.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.ClientCommunication.Upstream.UserRestController}Klasse UserRestController}{
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.UserRestController}{}\vskip .1in 
Die Klasse UserRestController gehört zum Upstream ClientCommunication Modul und bildet einen Teil der REST API, die der Tomcat Server den Clients zur Kommunikation anbietet. Die Aufgabe dieser Klasse ist die Abwicklung von REST-Requests, die User-spezifische Anfragen beinhalten. Dazu gehört: - das Empfangen und Senden von HTTP-Requests - das Parsen der empfangenen / zu sendenden Daten von bzw. nach JSON - das Weiterleiten der Anfragen zur Bearbeitung an die richtige Stelle im Programm (das UserDAO) Das REST API wird umgesetzt von dem Java Framework Spring, anhand der Annotationen der Methoden in dieser Klasse. Die Klasse selbst ist annotiert mit "@RestController", um zu signalisieren, dass es sich um eine Klasse handelt, deren Methoden Rest Resourcen beschreiben. Die Methoden dieser Klasse sind auf die URL \{Base\_URL\}/user gemappt. Die Methoden der Klasse werden aufgerufen, von den Methoden des Interfaces "TomcatRestApi", das von den Clients des Systems verwendet wird. Bei einem Methodenaufruf in dieser Klasse, wird die Anfrage an die DAOs der MySQL Datenbank der Anwendung weitergeleitet. Von dort werden die richtigen Daten geholt (falls der Client bestimmte Daten in der Antwort erwartet). Danach werden die Daten von dieser Klasse in JSON-Objekte umgewandelt (mithilfe der Gson Library) und dem Client in der Antwort zugesendet. Nähere Erläuterungen zum JSON-Schema und der Konvertierung finden sich im Entwurfsdokument.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class UserRestController
 extends java.lang.Object\end{lstlisting}

\subsubsection{Attribute}{
\begin{verse}
{{\bf private UserDao userDao}} Ein Objekt einer Klasse, die das Interface UserDao implementiert. Dieses Objekt besitzt Methoden, um auf die Datenbank des Systems zuzugreifen und Daten zu manipulieren. Es wird benötigt, um die Anfragen, die durch die REST Calls an den Server gestellt werden, umzusetzen.
\end{verse}
}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{UserRestController()}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.UserRestController()}{{\bf  UserRestController}\\}
\begin{lstlisting}[frame=none]
public UserRestController()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{createUser(String, String)}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.UserRestController.createUser(java.lang.String, java.lang.String)}{{\bf  createUser}\\}
\begin{lstlisting}[frame=none]
public void createUser(java.lang.String email,java.lang.String userId)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode wird aufgerufen, wenn ein Benutzer sich zum ersten Mal in der App anmeldet. Die Methode veranlasst das userDAO einen neuen Eintrag in der Datenbank anzulegen. Dazu überträgt der Client die benötigten Daten im Request Body der HTTP-Anfrage, verpackt als JSON-Objekt. Der Aufruf dieser Methode entspricht einem HTTP POST-Request an die URL \{base\_URL\}/user/\{userId\}. Die Methode besitzt keinen Rückgabewert, lediglich einen Statuscode in der HTTP-Antwort, die an den Anfragenden gesendet wird. Der Statuscode gibt an, ob die Transaktion erfolgreich war.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{userId} -- Die ID des Benutzers, der sich registriert. Diese muss eindeutig sein. Die ID wird generiert von dem Firebase Authentication Service, der auch die Eindeutigkeit derselben sicherstellt. Diese wird von Spring aus der URL extrahiert und als Argument der Methode verwendet.}
   \item{
\texttt{email} -- Die E-Mailadresse des Benutzers, die mit dem Google-Account assoziiert ist, mit dem er sich angemeldet hat.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{deleteUser(String)}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.UserRestController.deleteUser(java.lang.String)}{{\bf  deleteUser}\\}
\begin{lstlisting}[frame=none]
public void deleteUser(java.lang.String userId)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode wird aufgerufen, wenn ein Benutzer seinen Benutzeraccount löschen möchte. In der Methode wird das UserDAO dazu aufgerufen, das Tupel aus der User-Relation zu entfernen. Durch Fremdschlüssel-Constraints in der Datenbank, werden alle dem User gehörenden Gruppen (in denen er Admin war) , GOs (in denen er Go-Verantwortlicher war), Gruppenmitgliedschaften sowie Gruppenanfragen an den User automatisch gelöscht. Der Aufruf dieser Methode entspricht einem HTTP DELETE-Request an die URL \{base\_URL\}/user/\{userId\}. Die Methode besitzt keinen Rückgabewert, lediglich einen Statuscode in der HTTP-Antwort, die an den Anfragenden gesendet wird. Der Statuscode gibt an, ob die Transaktion erfolgreich war.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{userId} -- die ID des Benutzers, dessen Konto entfernt werden soll. Diese wird von Spring aus der URL extrahiert und als Argument der Methode verwendet.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{getData(String)}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.UserRestController.getData(java.lang.String)}{{\bf  getData}\\}
\begin{lstlisting}[frame=none]
public java.util.List getData(java.lang.String userId)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode liefert dem Anfragenden eine Liste aller Gruppen, in der der Benutzer mit der User ID \{userId\}\ Mitglied ist, bzw. zu denen er eine Anfrage bekommen hat. Sie wird genau dann von einem Client aufgerufen, wenn ein Benutzer sich in der App anmeldet. Der Aufruf dieser Methode entspricht einem HTTP GET-Request an den Server an die URL \{Base\_URL\}/user/\{userId\}, die \{userId\}\ Da in den Gruppen die einzelnen GOs dieser Gruppe gespeichert sind, erhält der Anfragende mit dem Aufruf dieser Methode sämtliche Daten, die den Benutzer mit der User ID \{userID\}\ betreffen und für das Navigieren und Benutzen der App benötigt werden (angesehen von Änderungen der Daten, die zu einem späteren Zeitpunkt stattfinden).
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{userId} -- Die ID des Benutzers, dessen Daten zurückgegeben werden sollen. Diese wird von Spring aus der URL extrahiert und als Argument der Methode verwendet.}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
eine Liste aller Gruppen von Gruppenobjekten. Der Rückgabewert dieser Methode wird innerhalb der Methode in ein JSON-Objekt geparst und in der empfangenden Methode des Clients zu Java Objekten konvertiert. Die Konvertierung nach JSON und zurück ändert nicht den Inhalt der Daten. Die Liste kann leer sein, für den Fall dass ein Benutzer nicht Mitglied in irgendeiner Gruppe ist. In diesem Fall wird in dem JSON-Objekt ein leerer Data-Block übertragen. Die Länge der Liste ist auf 300 Gruppen beschränkt (dies ist die Gesamtanzahl an Gruppen, die von dem System unterstützt werden) 
}%end item
\end{itemize}
}%end item
\item{ 
\index{registerDevice(String)}
\hypertarget{edu.kit.pse17.go_app.ClientCommunication.Upstream.UserRestController.registerDevice(java.lang.String)}{{\bf  registerDevice}\\}
\begin{lstlisting}[frame=none]
public void registerDevice(java.lang.String instanceId)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode wird aufgerufen, um das Gerät, dass ein Benutzer aktuell benutzt auf dem Server mit seiner InstanceId zu registrieren. Die InstanceId wird vom Server benötigt, um das Gerät des Benutzers identifizieren zu können, um Kommunikationsströme zu initiieren. Da diese InstanceId sich von Gerät zu Gerät unterscheidet bzw. sich durch Konfigurationsänderungen ändern kann, sollte diese Methode zusätzlich zu getData() bei jeder Anmeldung von dem Client aufgerufen werden. Der Aufruf dieser Methode entspricht einem HTTP PUT-Request an die URL \{base\_URL\}/user/device/\{instanceId\}.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{instanceId} -- Die InstanceID des Geräts, an dem sich der User angemeldet hat. Diese wird von Spring aus der URL extrahiert und als Argument der Methode verwendet. Generiert wird die InstanceId von dem Service Firebase Cloud Messaging, der auch benutzt wird, um Downstream-Kommunikation zu realisieren.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
}
\section{Package edu.kit.pse17.go\_app}{
\label{edu.kit.pse17.go_app}\hypertarget{edu.kit.pse17.go_app}{}

\subsection{\label{edu.kit.pse17.go_app.Main}Klasse Main}{
\hypertarget{edu.kit.pse17.go_app.Main}{}\vskip .1in 
Created by tina on 29.06.17.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class Main
 extends java.lang.Object\end{lstlisting}

\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{Main()}
\hypertarget{edu.kit.pse17.go_app.Main()}{{\bf  Main}\\}
\begin{lstlisting}[frame=none]
public Main()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{main(String\lbrack \rbrack )}
\hypertarget{edu.kit.pse17.go_app.Main.main(java.lang.String[])}{{\bf  main}\\}
\begin{lstlisting}[frame=none]
public static void main(java.lang.String[] args)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
}
\section{Package ServiceLayer}{
\label{edu.kit.pse17.go_app.ServiceLayer}\hypertarget{edu.kit.pse17.go_app.ServiceLayer}{}

\subsection{\label{edu.kit.pse17.go_app.ServiceLayer.ClusterStrategy}Interface ClusterStrategy}{
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.ClusterStrategy}{}\vskip .1in 
Dieses Interface definiert die Schnittstelle, die eine Klasse, die einen Clustering-Algorithmus implementiert, anbieten. muss. Die Anzahl der Teilnehmer eines GOs liegt zwischen 3 und 50. Der implementierende Algorithmus muss mit dieser Anzahl an Benutzern umgehen können. Das Interface ist Teil eines Strategie-Entwurfsmusters und übernimmt die Rolle der allgemeinen Strategie.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public interface ClusterStrategy
\end{lstlisting}
\subsubsection{Subinterfaces}{GoClusterStrategy\small{\refdefined{edu.kit.pse17.go_app.ServiceLayer.GoClusterStrategy}}}
\subsubsection{Klassen, die das Interface implementieren}{GoClusterStrategy\small{\refdefined{edu.kit.pse17.go_app.ServiceLayer.GoClusterStrategy}}}

\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{calculateCluster(List)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.ClusterStrategy.calculateCluster(java.util.List)}{{\bf  calculateCluster}\\}
\begin{lstlisting}[frame=none]
java.util.List calculateCluster(java.util.List userLocationList)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode muss von jeder konkreten Algorithmus-Klasse implementiert werden. Ein Aufruf dieser Methode führt zu einer Ausführung des konkreten Algorithmus. Dabei ist es egal, wie der Algorithmus beim Clustering konkret vorgeht. In dem Entwurfsmuster Strategie übernimmt diese Methode die Rolle der "führeAus()" Methode in der abstrakten Strategie.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{userLocationList} -- Eine Liste mit den aktuellen Standorten der einzelnen GO-Teilnehmer. Die Länge der Liste beträgt dabei mindestens drei Objekte und maximal 50 Objekte.}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
eine Liste von Cluster-Objekten, die den aktuellen Standort der Gruppe beschreiben. (Die Länge der Liste liegt zwischen...)
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.ServiceLayer.Observable}Interface Observable}{
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.Observable}{}\vskip .1in 
Dieses Interface ist Teil einer Implementierung eines Beobachter-Entwurfsmusters. Es übernimmt die Rolle des abstrakten Subjekts. Es muss von allen Klassen, die beobachtet werden müssen implementiert werden. In dieser Anwendung sind dies die DAO Klassen. Diese werden beobachtet, um Änderungen am Datenbestand zu bemerken und diese Änderungen an betroffene Clients weiterleiten zu können. Das bedeutet bei jeder Änderung an dem Datenbestand muss anschließend die notify()-Methode aufgerufen werden, um den Beobachtern die Änderungen zu übergeben. Das Generic T gibt an, welcher Datentyp von den Änderungen betroffen ist und von den Beobachtern an die Clients weitergeleitet werden muss.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public interface Observable
\end{lstlisting}
\subsubsection{Subinterfaces}{GoDaoImp\small{\refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDaoImp}}, UserDaoImp\small{\refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp}}, GroupDaoImp\small{\refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDaoImp}}}
\subsubsection{Klassen, die das Interface implementieren}{GoDaoImp\small{\refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.GoDaoImp}}, UserDaoImp\small{\refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.UserDaoImp}}, GroupDaoImp\small{\refdefined{edu.kit.pse17.go_app.PersistenceLayer.daos.GroupDaoImp}}}

\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{notify(String, Observable, T)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.Observable.notify(java.lang.String, edu.kit.pse17.go_app.ServiceLayer.Observable, T)}{{\bf  notify}\\}
\begin{lstlisting}[frame=none]
void notify(java.lang.String impCode,Observable observable,java.lang.Object t)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Mit dieser Methode können Observer über eine Änderung benachrichtigt werden. es muss dabei nicht angegeben werden, welche Änderung vorgenommen wurde, dies wissen die Observer selbst. Die Methode löst nur dann eine Aktion bei einem der Observer aus, wenn zuvor ein zu der Änderung passender Observer registriert wurde.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{impCode} -- Ein Code, der angibt, welche Observer-Implementierung benachrichtigt werden soll. dabei handelt es sich immer um ein öffentliches statisches Attribut in der Observer-Klasse. Handelt es sich um keinen gültigen Implementierungs-Code, wird kein Observer auf das notify() reagieren.}
   \item{
\texttt{observable} -- Eine Instanz des Observables, das die notify()-Methode aufgerufen hat. Durch diese Referenz weiß der Observer, von wo er eine Benachrichtigung bekommen hat.}
   \item{
\texttt{t} -- Das Objekt das die Änderung enthält bzw. an dem die Änderung durchgeführt wurde.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{register(Observer)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.Observable.register(edu.kit.pse17.go_app.ServiceLayer.Observer)}{{\bf  register}\\}
\begin{lstlisting}[frame=none]
void register(Observer observer)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Mit dieser Methode kann man einen neuen Observer registrieren. Er wird zu einer Liste von Observern hinzugefügt, falls diese Liste noch nicht vorhanden ist, wird sie erstellt. Der Beobachter ist nach dem Hinzufügen zu der Liste funktionsfähig.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{observer} -- der Observer, der registriert werden soll. Dabei spielt es keine Rolle, um welche Implementierung eines Observers es sich handelt.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{unregister(Observer)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.Observable.unregister(edu.kit.pse17.go_app.ServiceLayer.Observer)}{{\bf  unregister}\\}
\begin{lstlisting}[frame=none]
void unregister(Observer observer)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Ein zuvor registrierter Observer kann wieder entfernt werden, indem diese Methode aufgerufen wird. Er wird aus der Liste entfernt.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{observer} -- Der Observer der aus der Liste entfernt werden soll. es muss vor dem Aufruf dieser Methode sichergestellt werden, dass es sich bei dem Objekt um einen vorher registrierten, noch existenten Observer handelt.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.ServiceLayer.Observer}Interface Observer}{
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.Observer}{}\vskip .1in 
Dieses Interface gehört zu einer Implementierung des Entwurfsmusters Beobachter. Es übernimmt dabei die Rolle des abstrakten Beobachters. Jede konkrete Beobachter-Klasse muss dieses Interface implementieren und über eine update-Methode verfügen. Die Aufgabe der Beobachter in dieser Anwendung ist das Beobachten der DAO-Klassen und bei Änderungen im Datenbestand, diese Änderungen an die Clients der betroffenen Benutzer weiterzuleiten. Dazu werden aus dem übergebenen Objekt die wichtigen Daten extrahiert und in ein JSON-Objekt umgewandelt. Dieses kann an das Downstream-ClientCommunication Modul übergeben werden, wo es an die betroffenen Clients geschickt wird. Die Implementierung des Entwurfsmusters benutzt ein push-Modell, d.h. die Änderungen werden den Beobachtern bei einem notify()-Aufruf gleich mit übergeben. Die Beobachter müssen sich diese Änderungen nicht selbst holen.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public interface Observer
\end{lstlisting}
\subsubsection{Subinterfaces}{EntitiyRemovedObserver\small{\refdefined{edu.kit.pse17.go_app.ServiceLayer.EntitiyRemovedObserver}}, EntityChangedObserver\small{\refdefined{edu.kit.pse17.go_app.ServiceLayer.EntityChangedObserver}}, EntityAddedObserver\small{\refdefined{edu.kit.pse17.go_app.ServiceLayer.EntityAddedObserver}}}
\subsubsection{Klassen, die das Interface implementieren}{EntitiyRemovedObserver\small{\refdefined{edu.kit.pse17.go_app.ServiceLayer.EntitiyRemovedObserver}}, EntityChangedObserver\small{\refdefined{edu.kit.pse17.go_app.ServiceLayer.EntityChangedObserver}}, EntityAddedObserver\small{\refdefined{edu.kit.pse17.go_app.ServiceLayer.EntityAddedObserver}}}

\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{update(String, Observable, Object)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.Observer.update(java.lang.String, edu.kit.pse17.go_app.ServiceLayer.Observable, java.lang.Object)}{{\bf  update}\\}
\begin{lstlisting}[frame=none]
void update(java.lang.String arg,Observable observable,java.lang.Object o)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Die update()-Methode, mit der die Beobachter die beobachteten Änderungen an die Clients weitergeben. Wie dieses Update genau aussieht, wird von der konkreten Implementierung des Beobachters bestimmt.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{arg} -- Ein Argument, das die aufgetretene Änderung beschreibt. Ein Beobachter reagiert nur dann auf die Änderung, wenn dieses Argument mit dem statischen Feld OBSERVER\_CODE, das jeder Beobachter besitzt übereinstimmt.}
   \item{
\texttt{observable} -- Eine Instanz des Observable-Objekts, dass den Beobachter benachrichtigt hat. Dadurch kann der Beobachter zurückverfolgen von wo in der Anwendung er benachrichtigt wurde.}
   \item{
\texttt{o} -- Ein Objekt, das die Änderungen, um die der Beobachter sich kümmern muss enthält. Da es sich um den Datentyp "Object" handelt, ist der Beobachter sehr flexibel, welche Änderungen ihm übergeben werden können. Dies erleichtert auch das Überladen der Methode, wodurch ein Beobachter mehrere ähnliche Ereignisse beobachten kann.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.ServiceLayer.Cluster}Klasse Cluster}{
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.Cluster}{}\vskip .1in 
Bei dieser Klasse handelt es sich um eine Datenhaltungsklasse, die dem Clustering-Algoeithmus das hantieren mit den Standorten erleichtert. Ein Objekt dieser Klasse beschreibt dabei ein Cluster, bestehend aus mehreren GO-Teilnehmern, die sich nahe genug beieinander befinden, um von dem benutzten Clustering-Algorithmus als Cluster erkannt worden zu sein.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class Cluster
 extends java.lang.Object\end{lstlisting}

\subsubsection{Attribute}{
\begin{verse}
{{\bf private int size}} Anzahl an Personen, die sich in dem Cluster befinden. Der Wert liegt zwischen 1 und 60 Teilnehmern.\\[0.5em]
{{\bf private int lat}} Der geographische Breitengrad des Standorts des Clusters. Der Wert muss als Breitengrad interpretierbar sein,
     muss also zwischen +90 und -90 liegen.\\[0.5em]
{{\bf private int long}}  Der geographische Längengrad des Standorts des Clusters. Der Wert muss als Längengrad interpretierbar sein,
     muss also zwischen +180 und -180 liegen.
\end{verse}
}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{Cluster(int, long, long)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.Cluster(int, long, long)}{{\bf  Cluster}\\}
\begin{lstlisting}[frame=none]
public Cluster(int size,long lat,long lon)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getLat()}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.Cluster.getLat()}{{\bf  getLat}\\}
\begin{lstlisting}[frame=none]
public long getLat()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getLon()}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.Cluster.getLon()}{{\bf  getLon}\\}
\begin{lstlisting}[frame=none]
public long getLon()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getSize()}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.Cluster.getSize()}{{\bf  getSize}\\}
\begin{lstlisting}[frame=none]
public int getSize()\end{lstlisting} %end signature
}%end item
\item{ 
\index{setLat(long)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.Cluster.setLat(long)}{{\bf  setLat}\\}
\begin{lstlisting}[frame=none]
public void setLat(long lat)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setLon(long)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.Cluster.setLon(long)}{{\bf  setLon}\\}
\begin{lstlisting}[frame=none]
public void setLon(long lon)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setSize(int)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.Cluster.setSize(int)}{{\bf  setSize}\\}
\begin{lstlisting}[frame=none]
public void setSize(int size)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.ServiceLayer.EntitiyRemovedObserver}Klasse EntitiyRemovedObserver}{
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.EntitiyRemovedObserver}{}\vskip .1in 
Bei dieser Klasse handelt es sich um eine Implementierung des Observer-Interfaces. Dementsprechend ist diese Klasse Teil des Observer- Entwurfsmusters und übernimmt die Rolle des konkreten Observers. Die Aufgabe dieser Klasse ist das Beobachten der DAO-Klassen und auf Entfernen von Entitäten zu reagieren. Dies schließt folgende Ereignisse mit ein: - Entfernen eines GOs - Entfernen eines Gruppenmitglieds / einer Gruppenanfrage - Entfernen einer Gruppe Um auf diese verschiedenen Änderungen reagieren zu können, muss bei der Implementierung die update()-Methode überladen werden oder innerhalb der Methode anhand der übergebenen Änderung entschieden werden, welche weitere Vorgehensweise gewählt werden muss.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class EntitiyRemovedObserver
 extends java.lang.Object implements Observer\end{lstlisting}

\subsubsection{statische Felder}{
\begin{itemize}
\item{
\index{OBSERVER\_CODE}
\label{edu.kit.pse17.go_app.ServiceLayer.EntitiyRemovedObserver.OBSERVER_CODE}\hypertarget{edu.kit.pse17.go_app.ServiceLayer.EntitiyRemovedObserver.OBSERVER_CODE}{\texttt{public static final java.lang.String\ {\bf  OBSERVER\_CODE}}
}
\begin{itemize}
\item{\vskip -.9ex 
Der Code anhand dessen der Observer erkennt, dass er auf ein notify() reagieren soll. Bei jeglichen Änderungen wird jeder Observer benachrichtigt, wer regieren muss wird anhand dieses Codes entschieden. Er wird als erstes Argument der update()-Methode verwendet.}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Attribute}
\begin{verse}
{{\bf private FcmClient fcmClient}} Eine Instanz eines FcmClients, der dafür verwendet wird, Nachrichten an die Clients zu schicken. Das Attribut wird bei der Erzeugung eines Observer
    Objekts automatisch instanziiert (durch Benutzung des einzigen, argumentlosen Konstruktors der FcmClient-Klasse). Danach kann das von außen Attribut nicht mehr verändert werden.
\end{verse}
}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{EntitiyRemovedObserver()}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.EntitiyRemovedObserver()}{{\bf  EntitiyRemovedObserver}\\}
\begin{lstlisting}[frame=none]
public EntitiyRemovedObserver()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{update(String, Observable, GoEntity)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.EntitiyRemovedObserver.update(java.lang.String, edu.kit.pse17.go_app.ServiceLayer.Observable, edu.kit.pse17.go_app.PersistenceLayer.GoEntity)}{{\bf  update}\\}
\begin{lstlisting}[frame=none]
public void update(java.lang.String arg,Observable observable,edu.kit.pse17.go_app.PersistenceLayer.GoEntity go)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Überladung der update()-Methode des Observers. Diese Methode kümmert sich um das Entfernen eines GOs. Die Daten des GOs werden in dieser Methode zu einem passenden JSON-Objekt umgewandelt und an den FcmClient weitergegeben, um von dort an die entsprechenden Clients geschickt zu werden. Wer diese Clients sind wird ebenfalls in dieser Methode bestimmt und kann anhand der übergebenen Go-Entity ermittelt werden.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{arg} -- in Argument, das die aufgetretene Änderung beschreibt. Ein Beobachter reagiert nur dann auf die Änderung, wenn dieses Argument mit dem statischen Feld OBSERVER\_CODE, das jeder Beobachter besitzt übereinstimmt.}
   \item{
\texttt{observable} -- Eine Instanz des Observable-Objekts, dass den Beobachter benachrichtigt hat. Dadurch kann der Beobachter zurückverfolgen von wo in der Anwendung er benachrichtigt wurde.}
   \item{
\texttt{go} -- Das GO, das aus der Datenbank entfernt wurde.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{update(String, Observable, GroupEntity)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.EntitiyRemovedObserver.update(java.lang.String, edu.kit.pse17.go_app.ServiceLayer.Observable, edu.kit.pse17.go_app.PersistenceLayer.GroupEntity)}{{\bf  update}\\}
\begin{lstlisting}[frame=none]
public void update(java.lang.String arg,Observable observable,edu.kit.pse17.go_app.PersistenceLayer.GroupEntity group)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Überladung der update()-Methode des Observers. Diese Methode kümmert sich um das Entfernen einer Gruppe. Die Daten der Gruppe werden in dieser Methode zu einem passenden JSON-Objekt umgewandelt und an den FcmClient weitergegeben, um von dort an die entsprechenden Clients geschickt zu werden. Wer diese Clients sind wird ebenfalls in dieser Methode bestimmt und kann anhand der übergebenen Go-Entity ermittelt werden.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{arg} -- Ein Argument, das die aufgetretene Änderung beschreibt. Ein Beobachter reagiert nur dann auf die Änderung, wenn dieses Argument mit dem statischen Feld OBSERVER\_CODE, das jeder Beobachter besitzt übereinstimmt.}
   \item{
\texttt{observable} -- Eine Instanz des Observable-Objekts, dass den Beobachter benachrichtigt hat. Dadurch kann der Beobachter zurückverfolgen von wo in der Anwendung er benachrichtigt wurde.}
   \item{
\texttt{group} -- Die Gruppe, die aus der Datenbank entfernt wurde.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{update(String, Observable, List)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.EntitiyRemovedObserver.update(java.lang.String, edu.kit.pse17.go_app.ServiceLayer.Observable, java.util.List)}{{\bf  update}\\}
\begin{lstlisting}[frame=none]
public void update(java.lang.String arg,Observable observable,java.util.List changes)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Überladung der update()-Methode des Observers. Diese Methode kümmert sich um das Entfernen eines Gruppenmitglieds. Die Daten der Änderung werden in dieser Methode zu einem passenden JSON-Objekt umgewandelt und an den FcmClient weitergegeben, um von dort an die entsprechenden Clients geschickt zu werden. Wer diese Clients sind wird ebenfalls in dieser Methode bestimmt und kann anhand der übergebenen übergebenen Daten ermittelt werden.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{arg} -- in Argument, das die aufgetretene Änderung beschreibt. Ein Beobachter reagiert nur dann auf die Änderung, wenn dieses Argument mit dem statischen Feld OBSERVER\_CODE, das jeder Beobachter besitzt übereinstimmt.}
   \item{
\texttt{observable} -- Eine Instanz des Observable-Objekts, dass den Beobachter benachrichtigt hat. Dadurch kann der Beobachter zurückverfolgen von wo in der Anwendung er benachrichtigt wurde.}
   \item{
\texttt{changes} -- Eine Liste mit Objekten, die die Änderungen beschreiben. Dabei muss die Liste folgenden Aufbau haben: 1. GroupEntity -- Gruppe, aus der der Benutzer entfernt werden soll 2. UserEntity -- Benutzer, der aus der Gruppe entfernt werden soll}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{update(String, Observable, Object)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.EntitiyRemovedObserver.update(java.lang.String, edu.kit.pse17.go_app.ServiceLayer.Observable, java.lang.Object)}{{\bf  update}\\}
\begin{lstlisting}[frame=none]
public void update(java.lang.String arg,Observable observable,java.lang.Object o)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Implementierung der update()-Methode. Wird überladen, um die unterschiedlichen Ereignisse, auf die dieser Observer reagieren kann zu unterscheiden.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{arg} -- Ein Argument, das die aufgetretene Änderung beschreibt. Ein Beobachter reagiert nur dann auf die Änderung, wenn dieses Argument mit dem statischen Feld OBSERVER\_CODE, das jeder Beobachter besitzt übereinstimmt.}
   \item{
\texttt{observable} -- Eine Instanz des Observable-Objekts, dass den Beobachter benachrichtigt hat. Dadurch kann der Beobachter zurückverfolgen von wo in der Anwendung er benachrichtigt wurde.}
   \item{
\texttt{o} -- Ein Objekt, das die Änderungen, um die der Beobachter sich kümmern muss enthält. Da es sich um den Datentyp "Object" handelt, ist der Beobachter sehr flexibel, welche Änderungen ihm übergeben werden können. Dies erleichtert auch das Überladen der Methode, wodurch ein Beobachter mehrere}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.ServiceLayer.EntityAddedObserver}Klasse EntityAddedObserver}{
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.EntityAddedObserver}{}\vskip .1in 
Bei dieser Klasse handelt es sich um eine Implementierung des Observer-Interfaces. Dementsprechend ist diese Klasse Teil des Observer- Entwurfsmusters und übernimmt die Rolle des konkreten Observers. Die Aufgabe dieser Klasse ist das Beobachten der DAO-Klassen und auf das Erstellen neuer Entitäten zu reagieren. Dies schließt folgende Ereignisse mit ein: - Hinzufügen eines GOs - Hinzufügen einer Gruppenanfrage - Hinzufügen eines Gruppenmitglieds Um auf diese verschiedenen Änderungen reagieren zu können, muss bei der Implementierung die update()-Methode überladen werden oder innerhalb der Methode anhand der übergebenen Änderung entschieden werden, welche weitere Vorgehensweise gewählt werden muss.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class EntityAddedObserver
 extends java.lang.Object implements Observer\end{lstlisting}

\subsubsection{statische Felder}{
\begin{itemize}
\item{
\index{OBSERVER\_CODE}
\label{edu.kit.pse17.go_app.ServiceLayer.EntityAddedObserver.OBSERVER_CODE}\hypertarget{edu.kit.pse17.go_app.ServiceLayer.EntityAddedObserver.OBSERVER_CODE}{\texttt{public static final java.lang.String\ {\bf  OBSERVER\_CODE}}
}
\begin{itemize}
\item{\vskip -.9ex 
Der Code anhand dem der Observer erkennt, dass er auf ein notify() reagieren soll. Bei jeglichen Änderungen wird jeder Observer benachrichtigt, wer regieren muss wird anhand dieses Codes entschieden. Er wird als erstes Argument der update()-Methode verwendet.}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Attribute}
\begin{verse}
{{\bf private FcmClient fcmClient}} Eine Instanz eines FcmClients, der dafür verwendet wird, Nachrichten an die Clients zu schicken. Das Attribut wird bei der Erzeugung eines Observer
    Objekts automatisch instanziiert (durch Benutzung des einzigen, argumentlosen Konstruktors der FcmClient-Klasse). Danach kann das von außen Attribut nicht mehr verändert werden.
\end{verse}
}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{EntityAddedObserver()}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.EntityAddedObserver()}{{\bf  EntityAddedObserver}\\}
\begin{lstlisting}[frame=none]
public EntityAddedObserver()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{update(String, Observable, GoEntity)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.EntityAddedObserver.update(java.lang.String, edu.kit.pse17.go_app.ServiceLayer.Observable, edu.kit.pse17.go_app.PersistenceLayer.GoEntity)}{{\bf  update}\\}
\begin{lstlisting}[frame=none]
public void update(java.lang.String arg,Observable observable,edu.kit.pse17.go_app.PersistenceLayer.GoEntity go)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Überladung der Update-Methode des Observers. Diese Implementierung der Methode wird aufgerufen, wenn ein neues GO in einer Gruppe erstellt wurde. Die Methode wandelt das GO daraufhin in ein passendes JSON-Objekt um, um es an den FcmClient weiterzugeben, der es wiederum an die passenden Clients schickt. Wer diese Clients sind wird ebenfalls in dieser Methode bestimmt und kann anhand der übergebenen Go-Entity ermittelt werden.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{arg} -- Ein Argument, das die aufgetretene Änderung beschreibt. Ein Beobachter reagiert nur dann auf die Änderung, wenn dieses Argument mit dem statischen Feld OBSERVER\_CODE, das jeder Beobachter besitzt übereinstimmt.}
   \item{
\texttt{observable} -- Eine Instanz des Observable-Objekts, dass den Beobachter benachrichtigt hat. Dadurch kann der Beobachter zurückverfolgen von wo in der Anwendung er benachrichtigt wurde.}
   \item{
\texttt{go} -- Das Go, das neu erstellt wurde. Es enthält alle Daten die wichtig sind für das GO und die an die Clients weitergegeben werden müssen.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{update(String, Observable, GroupEntity)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.EntityAddedObserver.update(java.lang.String, edu.kit.pse17.go_app.ServiceLayer.Observable, edu.kit.pse17.go_app.PersistenceLayer.GroupEntity)}{{\bf  update}\\}
\begin{lstlisting}[frame=none]
public void update(java.lang.String arg,Observable observable,edu.kit.pse17.go_app.PersistenceLayer.GroupEntity group)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Überladung der Update-Methode des Observers. Diese Implementierung der Methode wird aufgerufen, wenn eine neue Gruppenanfrage in einer Gruppe erstellt wurde. Die Methode wandelt die Anfrage daraufhin in ein passendes JSON-Objekt um, um es an den FcmClient weiterzugeben, der es wiederum an die passenden Clients schickt. Wer diese Clients sind wird ebenfalls in dieser Methode bestimmt und kann anhand der übergebenen Go-Entity ermittelt werden.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{arg} -- Ein Argument, das die aufgetretene Änderung beschreibt. Ein Beobachter reagiert nur dann auf die Änderung, wenn dieses Argument mit dem statischen Feld OBSERVER\_CODE, das jeder Beobachter besitzt übereinstimmt.}
   \item{
\texttt{observable} -- Eine Instanz des Observable-Objekts, dass den Beobachter benachrichtigt hat. Dadurch kann der Beobachter zurückverfolgen von wo in der Anwendung er benachrichtigt wurde.}
   \item{
\texttt{group} -- Die Gruppe in der die Anfrage neu erstellt wurde. Sie enthält alle Daten die wichtig sind für das GO und die an die Clients weitergegeben werden müssen. Da die Gruppenanfragen in einer Liste gespeichert werden, wird immer das letzte Listenelement als die neu hinzugefügte Anfrage betrachtet. Darauf muss geachtet werden, wenn in der DAO-Klasse eine neue Anfrage angelegt wird.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{update(String, Observable, Object)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.EntityAddedObserver.update(java.lang.String, edu.kit.pse17.go_app.ServiceLayer.Observable, java.lang.Object)}{{\bf  update}\\}
\begin{lstlisting}[frame=none]
public void update(java.lang.String arg,Observable observable,java.lang.Object o)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Implementierung der update()-Methode. Wird überladen, um die unterschiedlichen Ereignisse, auf die dieser Observer reagieren kann zu unterscheiden.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{arg} -- Ein Argument, das die aufgetretene Änderung beschreibt. Ein Beobachter reagiert nur dann auf die Änderung, wenn dieses Argument mit dem statischen Feld OBSERVER\_CODE, das jeder Beobachter besitzt übereinstimmt.}
   \item{
\texttt{observable} -- Eine Instanz des Observable-Objekts, dass den Beobachter benachrichtigt hat. Dadurch kann der Beobachter zurückverfolgen von wo in der Anwendung er benachrichtigt wurde.}
   \item{
\texttt{o} -- Ein Objekt, das die Änderungen, um die der Beobachter sich kümmern muss enthält. Da es sich um den Datentyp "Object" handelt, ist der Beobachter sehr flexibel, welche Änderungen ihm übergeben werden können. Dies erleichtert auch das Überladen der Methode, wodurch ein Beobachter mehrere}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{update(String, Observable, UserEntity)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.EntityAddedObserver.update(java.lang.String, edu.kit.pse17.go_app.ServiceLayer.Observable, edu.kit.pse17.go_app.PersistenceLayer.UserEntity)}{{\bf  update}\\}
\begin{lstlisting}[frame=none]
public void update(java.lang.String arg,Observable observable,edu.kit.pse17.go_app.PersistenceLayer.UserEntity user)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Überladung der Update-Methode des Observers. Diese Implementierung der Methode wird aufgerufen, wenn ein neuer Benutzer zu einer Gruppe hinzugefügt wurde. Die Methode wandelt die Änderung daraufhin in ein passendes JSON-Objekt um, um es an den FcmClient weiterzugeben, der es wiederum an die passenden Clients schickt. Wer diese Clients sind wird ebenfalls in dieser Methode bestimmt und kann anhand der übergebenen User-Entity ermittelt werden.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{arg} -- Ein Argument, das die aufgetretene Änderung beschreibt. Ein Beobachter reagiert nur dann auf die Änderung, wenn dieses Argument mit dem statischen Feld OBSERVER\_CODE, das jeder Beobachter besitzt übereinstimmt.}
   \item{
\texttt{observable} -- Eine Instanz des Observable-Objekts, dass den Beobachter benachrichtigt hat. Dadurch kann der Beobachter zurückverfolgen von wo in der Anwendung er benachrichtigt wurde.}
   \item{
\texttt{user} -- Der Benutzer, der der Gruppe hinzugefügt wurde. Die Entität enthält alle Daten die wichtig sind für die Änderung und die an die Clients weitergegeben werden müssen. Da die Gruppenmitgliedschaften in einer Liste gespeichert werden, wird immer das letzte Listenelement als die neu hinzugefügte Gruppe betrachtet. Darauf muss geachtet werden, wenn in der DAO-Klasse eine neue Anfrage angelegt wird.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.ServiceLayer.EntityChangedObserver}Klasse EntityChangedObserver}{
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.EntityChangedObserver}{}\vskip .1in 
Bei dieser Klasse handelt es sich um eine Implementierung des Oberver-Interfaces. Dementsprechend ist diese Klasse Teil des Observer- Entwurfsmusters und übernimmt die Rolle des konkreten Observers. Die Aufgabe dieser Klasse ist das Beobachten der DAO-Klassen und auf Änderungen einer bestehenden Entität zu reagieren. Dies schließt folgende Ereignisse mit ein: - Änderung von GO-Daten - Änderung von Gruppendaten - Änderung des Teilnahmestatus - Änderung der Administratoren einer Gruppe Um auf diese verschiedenen Änderungen reagieren zu können, muss bei der Implementierung die update()-Methode überladen werden oder innerhalb der Methode anhand der übergebenen Änderung entschieden werden, welche weitere Vorgehensweise gewählt werden muss.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class EntityChangedObserver
 extends java.lang.Object implements Observer\end{lstlisting}

\subsubsection{statische Felder}{
\begin{itemize}
\item{
\index{OBSERVER\_CODE}
\label{edu.kit.pse17.go_app.ServiceLayer.EntityChangedObserver.OBSERVER_CODE}\hypertarget{edu.kit.pse17.go_app.ServiceLayer.EntityChangedObserver.OBSERVER_CODE}{\texttt{public static final java.lang.String\ {\bf  OBSERVER\_CODE}}
}
\begin{itemize}
\item{\vskip -.9ex 
Der Code anhand dem der Observer erkennt, dass er auf ein notify() reagieren soll. Bei jeglichen Änderungen wird jeder Observer benachrichtigt, wer regieren muss wird anhand dieses Codes entschieden. Er wird als erstes Argument der update()-Methode verwendet.}
\end{itemize}
}
\end{itemize}
}
\subsubsection{Attribute}
\begin{verse}
{{\bf private FcmClient fcmClient}} Eine Instanz eines FcmClients, der dafür verwendet wird, Nachrichten an die Clients zu schicken. Das Attribut wird bei der Erzeugung eines Observer
    Objekts automatisch instanziiert (durch Benutzung des einzigen, argumentlosen Konstruktors der FcmClient-Klasse). Danach kann das von außen Attribut nicht mehr verändert werden.
\end{verse}
}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{EntityChangedObserver()}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.EntityChangedObserver()}{{\bf  EntityChangedObserver}\\}
\begin{lstlisting}[frame=none]
public EntityChangedObserver()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{update(String, Observable, GoEntity)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.EntityChangedObserver.update(java.lang.String, edu.kit.pse17.go_app.ServiceLayer.Observable, edu.kit.pse17.go_app.PersistenceLayer.GoEntity)}{{\bf  update}\\}
\begin{lstlisting}[frame=none]
public void update(java.lang.String arg,Observable observable,edu.kit.pse17.go_app.PersistenceLayer.GoEntity go)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Überladung der Methode update() des Observers. In dieser Methode werden Datenänderungen an einem GO behandelt. Das geänderte Go wird in ein JSON-Objekt umgewandelt und an den FcmClient weitergegeben, um es an die entsprechenden Clients weiterzuleiten. Wer diese Clients sind wird ebenfalls in dieser Methode bestimmt und kann anhand der übergebenen Go-Entity ermittelt werden.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{arg} -- Ein Argument, das die aufgetretene Änderung beschreibt. Ein Beobachter reagiert nur dann auf die Änderung, wenn dieses Argument mit dem statischen Feld OBSERVER\_CODE, das jeder Beobachter besitzt übereinstimmt.}
   \item{
\texttt{observable} -- Eine Instanz des Observable-Objekts, dass den Beobachter benachrichtigt hat. Dadurch kann der Beobachter zurückverfolgen von wo in der Anwendung er benachrichtigt wurde.}
   \item{
\texttt{go} -- Das Go, dessen Daten verändert wurden.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{update(String, Observable, GroupEntity)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.EntityChangedObserver.update(java.lang.String, edu.kit.pse17.go_app.ServiceLayer.Observable, edu.kit.pse17.go_app.PersistenceLayer.GroupEntity)}{{\bf  update}\\}
\begin{lstlisting}[frame=none]
public void update(java.lang.String arg,Observable observable,edu.kit.pse17.go_app.PersistenceLayer.GroupEntity group)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Überladung der Methode update() des Observers. In dieser Methode werden Datenänderungen an einer Gruppe behandelt. Die geänderte gruppe wird in ein JSON-Objekt umgewandelt und an den FcmClient weitergegeben, um es an die entsprechenden Clients weiterzuleiten. Wer diese Clients sind wird ebenfalls in dieser Methode bestimmt und kann anhand der übergebenen Group-Entity ermittelt werden.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{arg} -- Ein Argument, das die aufgetretene Änderung beschreibt. Ein Beobachter reagiert nur dann auf die Änderung, wenn dieses Argument mit dem statischen Feld OBSERVER\_CODE, das jeder Beobachter besitzt übereinstimmt.}
   \item{
\texttt{observable} -- Eine Instanz des Observable-Objekts, dass den Beobachter benachrichtigt hat. Dadurch kann der Beobachter zurückverfolgen von wo in der Anwendung er benachrichtigt wurde.}
   \item{
\texttt{group} -- Die Gruppe, deren Daten verändert wurden.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{update(String, Observable, List)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.EntityChangedObserver.update(java.lang.String, edu.kit.pse17.go_app.ServiceLayer.Observable, java.util.List)}{{\bf  update}\\}
\begin{lstlisting}[frame=none]
public void update(java.lang.String arg,Observable observable,java.util.List changes)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Überladung der Methode update() des Observers. In dieser Methode wird das Ereignis eines neu hinzugefügten Admins behandelt und an die entsprechenden Clients weitergeleitet. Wer diese Clients sind wird ebenfalls in dieser Methode bestimmt und kann anhand der übergebenen Group-Entity ermittelt werden.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{arg} -- Ein Argument, das die aufgetretene Änderung beschreibt. Ein Beobachter reagiert nur dann auf die Änderung, wenn dieses Argument mit dem statischen Feld OBSERVER\_CODE, das jeder Beobachter besitzt übereinstimmt.}
   \item{
\texttt{observable} -- Eine Instanz des Observable-Objekts, dass den Beobachter benachrichtigt hat. Dadurch kann der Beobachter zurückverfolgen von wo in der Anwendung er benachrichtigt wurde.}
   \item{
\texttt{changes} -- Eine Liste von Objekten, die die Änderung beschreiben. Dabei muss die Liste folgende Struktur haben: 1. String -- "ADMIN" 2. GroupEntity -- Gruppe, um die es sich handelt 3. UserEntity -- Benutzer, der zum Administrator gemacht wurde.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{update(String, Observable, Object)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.EntityChangedObserver.update(java.lang.String, edu.kit.pse17.go_app.ServiceLayer.Observable, java.lang.Object)}{{\bf  update}\\}
\begin{lstlisting}[frame=none]
public void update(java.lang.String arg,Observable observable,java.lang.Object o)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Implementierung der update()-Methode. Wird überladen, um die unterschiedlichen Ereignisse, auf die dieser Observer reagieren kann zu unterscheiden.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{arg} -- Ein Argument, das die aufgetretene Änderung beschreibt. Ein Beobachter reagiert nur dann auf die Änderung, wenn dieses Argument mit dem statischen Feld OBSERVER\_CODE, das jeder Beobachter besitzt übereinstimmt.}
   \item{
\texttt{observable} -- Eine Instanz des Observable-Objekts, dass den Beobachter benachrichtigt hat. Dadurch kann der Beobachter zurückverfolgen von wo in der Anwendung er benachrichtigt wurde.}
   \item{
\texttt{o} -- Ein Objekt, das die Änderungen, um die der Beobachter sich kümmern muss enthält. Da es sich um den Datentyp "Object" handelt, ist der Beobachter sehr flexibel, welche Änderungen ihm übergeben werden können. Dies erleichtert auch das Überladen der Methode, wodurch ein Beobachter mehrere}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.ServiceLayer.GoClusterStrategy}Klasse GoClusterStrategy}{
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.GoClusterStrategy}{}\vskip .1in 
In dieser Klasse wird der in er Anwendung verwendete Clustering-Algorithmus implementiert. Die Ausführung des Algorithmus wird von der Klasse LocationService aufgerufen. Diese Klasse ist Teil einer Implementierung des Entwurfsmusters "Strategie" und übernimmt dabei die Rolle der konkreten Strategie. Das Interface der abstrakten Strategie, in diesem Fall "ClusterStrategy" wird implementiert. Die "führeAus()"-Methode der Strategie ist die Methode "calculateCluster()"\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class GoClusterStrategy
 extends java.lang.Object implements ClusterStrategy\end{lstlisting}

\subsubsection{Attribute}
\begin{verse}
{{\bf private int threshold}} Ein Schwellwert für die Genauigkeit, mit der der Clustering-Algorithmus ausgeführt wird. Der Wert liegt zwischen 1 (sehr ungenau) und 10 (sehr
     genau). Dieser Wert kann nach der Instanziierung des GoClusterStrategy-Objekts
    nicht mehr verändert werden. Wird der Wert nicht wenigstens einmal spezifiziert wird default-mäßig
     ein Wert von 5 benutzt.
\end{verse}
}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{GoClusterStrategy(int)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.GoClusterStrategy(int)}{{\bf  GoClusterStrategy}\\}
\begin{lstlisting}[frame=none]
public GoClusterStrategy(int threshold)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{calculateCluster(List)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.GoClusterStrategy.calculateCluster(java.util.List)}{{\bf  calculateCluster}\\}
\begin{lstlisting}[frame=none]
public java.util.List calculateCluster(java.util.List userLocationList)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Methode des Interfaces, die hier implementiert wird. Der Aufruf dieser Methode stößt die Ausführung des Algorithmus an und sie liefert die Ergebnisse des Clustering-Vorgangs an den Aufrufer zurück.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{userLocationList} -- Eine Liste mit den aktuellen Standorten der einzelnen GO-Teilnehmer. Die Länge der Liste beträgt dabei mindestens drei Objekte und maximal 50 Objekte.}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
eine Liste von Cluster-Objekten, die den aktuellen Standort der Gruppe beschreiben. Die Länge der Liste liegt zwischen 1 und 50. 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getThreshold()}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.GoClusterStrategy.getThreshold()}{{\bf  getThreshold}\\}
\begin{lstlisting}[frame=none]
public int getThreshold()\end{lstlisting} %end signature
}%end item
\item{ 
\index{setThreshold(int)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.GoClusterStrategy.setThreshold(int)}{{\bf  setThreshold}\\}
\begin{lstlisting}[frame=none]
public void setThreshold(int threshold)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.ServiceLayer.LocationService}Klasse LocationService}{
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.LocationService}{}\vskip .1in 
Diese Klasse bietet eine Schnittstelle für den GOrestController, an die Anfragen, die den User- bzw. Gruppenstandort betreffen, weitergeleitet werden können. Die Aufgabe dieser Klassen ist das Verwalten und Bearbeiten dieser Anfragen. Um die Anfragen bearbeiten zu können, bedient sich die die Klasse dem Clustering Algorithmus, der implementiert ist mit der Schnittstelle, wie sie in dem Interface ClusterStrategy beschrieben ist. Alle Programmteile, die Funktionalitäten aus dieser Klasse benötigen, stellen ihre Anfragen an statische Methoden. Erst innerhalb der Klasse wird die anfrage dem richtigen LocationService-Objekt zugeordnet. Dies erlaubt eine klare Trennung der Teile des GOs, die in der Datenbank verwaltet werden und denen, die in dieser Klasse verwaltet werden. Diese Klasse ist Teil einer Implementierung des Entwurfsmusters "Strategie". Sie übernimmt die Rolle des Aufrufers, d.h. sie ruft eine Implementierung einer abstrakten Strategie (hier: eine Implementierung von ClusterStrategie) auf, ohne dass des dabei eine Rolle spielt, wie genau die Implementierung aussieht.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class LocationService
 extends java.lang.Object\end{lstlisting}

\subsubsection{Attribute}
\begin{verse}
{{\bf private static List<LocationService> activeServices}} Diese Map enthält für jedes gerade aktive GO ein LocationService Objekt, welches die alle dieses GO betreffende
     Anfragen übernimmt.
      Der Schlüssel der Map ist die ID des GOs zu dem das LocationService-Objekt gehört. Die maximale Länge der Map beträgt 3000 Wertepaare.
      Ein neues Objekt wird in die Liste eingefügt, wenn die getLocationService()-Methode aufgerufen wird, und dabei kein passender Service gefunden wird. Die
      Erstellung der LocationService-Objekte findet ausschließlich in dieser Klasse statt.\\[0.5em]
      
{{\bf private final ClusterStrategy strat}} Ein Clustering-Strategie, die den Algorithmus, der für das Clustering benutzt wird festlegt.
     Das Attribut ist final, da es, nachdem es einmal festgelegt wurde nicht mehr verändert werden sollte. Ein GO sollte stattdessen immer den gleichen
     Algorithmus benutzen.\\[0.5em]
     
{{\bf private List<UserLocation> activeUsers}}Eine Liste mit den UserLocations aller Benutzer, die momentan ihren Standort mit den anderen teilen.
     Die Länge der Liste liegt zwischen 0 und 50 UserLocation-Objekten.\\[0.5em]
     
{{\bf private List<Cluster> groupLocation}} Eine Liste mit den aktuellen Clustern der Standorte des GOs. Diese Liste repräsentiert die Ergebnisse des Clustering für den Input
      "activeUsers". Die Länge der Liste liegt zwischen 0 und 50 Cluster-Objekten.\\[0.5em]
{{\bf private private int newLocationCounter}} Eine Zählvariable, um sich zu merken, wie viele neue Locations übermittelt wurden, seit das letzte Mal die groupLocation
     des GOs berechnet wurde. Die Berechnung findet nur statt, wenn diese Variable einen Wert größer als 5 hat. Danach wird der Zähler wieder auf 0 gesetzt.
     Sämtliche Manipulationen an diesem Attribut finden innerhalb dieser Klasse statt. Nach außen hin sit diese Variable nicht sichtbar und insbesondere nicht veränderbar.\\[0.5em]
     
{{\bf private private int userCounter}} Eine Zählvariable, um sich zu merken, wie viele verschiedene Benutzer bereits ihren Standort geteilt haben. Ist diese Zahl kleienr als 3, so wird keine groupLocation berechnet. Dies dient der Anonymisierung der einzelnen Benutzer, was bei einer Anzahl von UserLocations kleiner als 3 nicht mehr garantiert werden kann.
\end{verse}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{LocationService()}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.LocationService()}{{\bf  LocationService}\\}
\begin{lstlisting}[frame=none]
public LocationService()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Der einzige Konstruktor dieser Klasse nimmt keine Argumente entgegen. Sämtliche Attribute werden nur innerhalb dieser Klasse gesetzt und verändert. Die default-Werte der Attribute sind: - activeUsers: leere Liste - groupLocation: leere Liste - strat: Objekt einer Klasse, die ClusterStrategy implementiert. Als threshold-Wert wird dem Konstruktor 5 übergeben. - newLocationCounter: 0 - userCounter: 0
}
\end{itemize}
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getGroupLocation(long)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.LocationService.getGroupLocation(long)}{{\bf  getGroupLocation}\\}
\begin{lstlisting}[frame=none]
public static java.util.List getGroupLocation(long goId)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Gibt die aktuelle GroupLocation des spezifizierten GOs an den Aufrufer zurück. Aufgerufen wird diese Methode von einem GoRestController, der von einem Client eine Anfrage nach der groupLocation eines GOs bekommen hat. Bei einem Methodenaufruf wird das entsprechende GO aus der Map activeGos anhand der goId herausgesucht. Es ist dabei garantiert, dass das GO in der Map zu finden ist. Aus dem locationService-Objekts des GOs wird zuerst der Wert des newLocationCounters betrachtet. Ist dieser größer oder gleich 5, wird die ClusterStrategy aufgerufen und die groupLocation neu berechnet. Anschließend wird der newLocationCounter zurückgesetzt und die groupLocation wird zurückgegeben.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{goId} -- Die ID des GOs, dessen groupLocation gesucht wird. Dabei handelt es sich um eine gültige GO-ID, die ein Schlüssel in der Map active GOs ist.}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
Eine Liste mit Cluster-Objekten. Diese stellt den aktuellen Standort der GO-Teilnehmer dar. Dabei ist die Länge der Liste zwischen 0 und 50. Ist die Liste leer, heißt das, dass noch nicht genügend Teilnehmer ihren Standort übermittelt haben, um eine groupLocation ausrechnen zu können, ohne die Anonymisierungs-Vorschriften der Anwendung zu verletzen. 
}%end item
\end{itemize}
}%end item
\item{ 
\index{setUserLocation(long, String, long, long)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.LocationService.setUserLocation(long, java.lang.String, long, long)}{{\bf  setUserLocation}\\}
\begin{lstlisting}[frame=none]
public static void setUserLocation(long goId,java.lang.String userId,long lat,long lon)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Diese Methode speichert eine UserLocation in der activeUsers Liste des entsprechenden GOs. Sie wird aufgerufen von der GoRestController Klasse, wenn diese eine setLocation-Anfrage von einem Benutzer bekommt. Bei einem Methodenaufruf wird aus der Liste der activeGos das richtige locationService Objekt ausgewählt und dort die userLocation in der activeUsers Liste aktualisiert. Sollte dieses Objekt in der Liste nicht existierten, wird es erzeugt und der Liste hinzugefügt. In diesem Fall wird die Variable userCounter um eines erhöht, da ein neuer Benutzer angefangen hat, seinen Standort zu teilen. Bei jedem Aufruf dieser Methode wird außerdem der Wert von newLocationCounter um 1 erhöht. Sollte das GO in der Map activeGos nicht zu finden sein, wird ein neues LocationService-Objekt erzeugt und der Map hinzugefügt.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{goId} -- Die ID des GOs zu dem die Location gehört. Es muss eine gültige ID eines GOs sein. Sie wird verwendet, um den richtigen locationService aus einer statischen Map zu finden.}
   \item{
\texttt{userId} -- Die ID des Benutzers, zu dem der Standort gehört. Es muss sich um eine gültige Benutzer-ID handeln.}
   \item{
\texttt{lat} -- Der geographische Breitengrad des Standorts des Benutzers. Der Wert muss als Breitengrad interpretierbar sein, muss also zwischen +90 und -90 liegen.}
   \item{
\texttt{lon} -- Der geographische Längengrad des Standorts des Benutzers. Der Wert muss als Längengrad interpretierbar sein, muss also zwischen +180 und -180 liegen.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\subsection{\label{edu.kit.pse17.go_app.ServiceLayer.UserLocation}Klasse UserLocation}{
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.UserLocation}{}\vskip .1in 
Bei dieser Klasse handelt es sich um eine Datenhaltungsklasse, die dem Clustering-Algorithmus das hantieren mit den Standorten erleichtert. Ein Objekt dieser Klasse beschreibt dabei einen Benutzerstandort.\vskip .1in 
\subsubsection{Deklaration}{
\begin{lstlisting}[frame=none]
public class UserLocation
 extends java.lang.Object\end{lstlisting}

\subsubsection{Attribute}
\begin{verse}
{{\bf private String userId}} Die ID des Benutzers, um dessen Standort es sich handelt. Es handelt sich um eine gültige Benutzer-ID, die von anderen Klassen der anwendung erkannt werden kann.\\[0.5em]
{{\bf private long lat}} Der geographische Breitengrad des Standorts des Benutzers. Der Wert muss als Breitengrad interpretierbar sein,
      muss also zwischen +90 und -90 liegen.\\[0.5em]
{{\bf private long lon}} Der geographische Längengrad des Standorts des Benutzers. Der Wert muss als Längengrad interpretierbar sein,
     muss also zwischen +180 und -180 liegen.
\end{verse}
\subsubsection{Konstruktoren}{
\vskip -2em
\begin{itemize}
\item{ 
\index{UserLocation(String, long, long)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.UserLocation(java.lang.String, long, long)}{{\bf  UserLocation}\\}
\begin{lstlisting}[frame=none]
public UserLocation(java.lang.String userId,long lat,long lon)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsubsection{Methoden}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getLat()}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.UserLocation.getLat()}{{\bf  getLat}\\}
\begin{lstlisting}[frame=none]
public long getLat()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getLon()}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.UserLocation.getLon()}{{\bf  getLon}\\}
\begin{lstlisting}[frame=none]
public long getLon()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getUserId()}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.UserLocation.getUserId()}{{\bf  getUserId}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getUserId()\end{lstlisting} %end signature
}%end item
\item{ 
\index{setLat(long)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.UserLocation.setLat(long)}{{\bf  setLat}\\}
\begin{lstlisting}[frame=none]
public void setLat(long lat)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setLon(long)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.UserLocation.setLon(long)}{{\bf  setLon}\\}
\begin{lstlisting}[frame=none]
public void setLon(long lon)\end{lstlisting} %end signature
}%end item
\item{ 
\index{setUserId(String)}
\hypertarget{edu.kit.pse17.go_app.ServiceLayer.UserLocation.setUserId(java.lang.String)}{{\bf  setUserId}\\}
\begin{lstlisting}[frame=none]
public void setUserId(java.lang.String userId)\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
}
% ------- textdoclet_include/finish.tex

\newpage

%\section{verwendetes Datenbankschema}
%Das System persistiert Daten in einer zentralen MySQL-Datenbank auf dem Tomcat-Server und zusätzlich auf einer lokalen SQLite-Datenbank auf den Clients. Beide Datenbanken verwenden das gleiche Schema.\\

\section{Client-Server-Schnittstelle}
Dieser Abschnitt erläutert die Schnittstelle zwischen dem Client und dem Server. Diese Schnittstelle besteht aus zwei Teilen:

Zum Einen bietet der Server eine REST API an, über die der Client die Dienste des Servers in Anspruch nehmen kann. Zum Anderen gibt es eine Schnittstelle, die über Firebase Cloud Messaging realisiert ist, damit der Server Nachrichten an bestimmte Clients schicken kann.

\subsection{REST API des Servers}
Folgende Grafik zeigt, welche Methoden unter welchen URL des Servers zu erreichen sind:
\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{restapi.png}
	\caption{Übersicht über die Rest Api des Servers}
\end{figure}
Aufrufe der Request-Methoden DELETE und GET enthalten keinen Content-Body. Sämtliche Informationen, die der Server braucht, um richtig auf die anfrage antworten zu können, sind in der URL kodiert.
Bei den Methoden POST und PUT, sowie bei Antworten des Servers, die einen Content-Body erfordern, ist sind die Daten in einem JSON-Objekt gekapselt. Dieses Objekt wird von dem Framework Gson aus der entsprechenden Entity-Klasse erzeugt. die Anwendung muss den genauen Aufbau des JSON Objekts nicht kennen. Die Verantwortung für die Verwaltung derselben wird hier vollständig an Gson übergeben.

Bei sämtlichen Requests kann der Client anhand des HTTP-Statuscodes der Server-Response erkennen, ob die Anfrage erfolgreich ausgeführt werden konnte.

\subsection{FCM Schnittstelle}
Die Schnittstelle zwischen Server und Client, die zum Senden von Downstream-Nachrichten verwendet werden kann, wird über Firebase Cloud Messaging realisiert. Der Server sendet einen HTTP Post Request an den Firebase Server. Dabei besteht der Content-Body dieser HTTP-Anfrage aus einem JSON-Objekt indem der Empfänger und die zu übermittelnden Daten spezifiziert sind.

Folgende Grafik \footnote{Quelle: https://firebase.google.com/docs/cloud-messaging/send-message} zeigt den Aufbau eines HTTP-Requests, wie er an den FCM Server gesendet werden muss für eine erfolgreiche Weiterleitung der Nachricht:

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{http_format.png}
	\caption{Beispiel für ein HTTP-Request an den FCM Server}
\end{figure}

Das in grün markierte JSON-Objekt kann dabei je nach Anwendungsfall ein anderes Data-Field enthalten. Das "to"-Feld enthält die instanceId des Empfängers der Nachricht.\\[0.5em]

\textbf{Inhalt des 'data'-Felds für die verschiedenen Anwendungsfälle der App:}
Zunächst enthalten sämtliche Nachrichten unter dem Tag "tag" einen String der signalisiert, was der Anlass zum Senden der Nachricht war. Bei diesen Strings handelt es sich um Elemente des Enums EventArg.
\begin{itemize}
	\item \textit{Go Added}\\
	Ein aus einer GO-Entität erzeugtes JSON-Objekt unter dem Tag 'go'. Dieses wird automatisch durch das Framework Gson erzeugt.
	\item \textit{Go Edited}\\
	Ein aus einer GO-Entität erzeugtes JSON-Objekt unter dem Tag 'go'. Dieses wird automatisch durch das Framework Gson erzeugt. Es werden allerdings die Listen der Go-Teilnehmer aus dem Objekt entfernt,
	da Änderungen derselben von diesem Anwendungsfall nicht betroffen sind und die Daten somit nicht übertragen werden müssen.
	\item \textit{Go Removed}\\
	Die ID des entfernten Gos unter dem Tag 'id'
	\item \textit{Group Edited}\\
	Ein aus einer Group-Entität erzeugtes JSON-Objekt unter dem Tag 'group'. Dieses wird automatisch durch das Framework Gson erzeugt. Es werden allerdings die Listen der Gruppenmitglieder und Administratoren aus dem Objekt entfernt, da Änderungen derselben von diesem Anwendungsfall nicht betroffen sind und die Daten somit nicht übertragen werden müssen.
	\item \textit{Group Removed}\\
	Die ID der entfernten Gruppe unter dem Tag 'id'
	\item \textit{Group Request Received}\\
	Ein aus einer Group-Entität erzeugtes JSON-Objekt unter dem Tag 'group'. Dieses wird automatisch durch das Framework Gson erzeugt
	\item \textit{Member Added}\\
	Die ID der Gruppe zu der der Benutzer hinzugefügt werden soll unter dem Tag 'id'. Unter dem Tag 'user' ist ein JSON-Objekt gespeichert, das aus einer User-Entität erzeugt wurde. Dies geschieht automatisch durch das Framework Gson.
	\item \textit{Member Removed}\\
	Die ID des Benutzers, der aus der Gruppe entfernt werden soll unter dem Tag 'user\_id' und die ID der Gruppe, aus der der Benutzer entfernt werden soll unter dem Tag 'group\_id'.
	\item \textit{Admin Added}\\
	Die ID des Benutzers, der als Adminsitrator hinzugefügt werden soll unter dem Tag 'user\_id' und die ID der Gruppe, in der dies geschehen soll unter dem Tag 'group\_id'. Es ist nicht nötig das vollständige User-Objekt zu senden, da dies bereits auf den Clients in dem entsprechenden Gruppen-Objekt gespeichert ist.
	\item \textit{Status Changed}\\
	Die ID des Benutzers, der seinen Status geändert hat unter dem Tag 'user\_id', die ID des GOs in der die Statusänderung stattgefunden hat unter dem Tag 'go\_id' und eine Zahl, die den neuen Status repräsentiert, unter dem Tag 'status'. Es gilt '0': ABELEHNT, '1': BESTÄTIGT, '2': UNTERWEGS.
\end{itemize}

Bei den Clients kommt die gesendete Nachricht als remoteMessage-Objekt an. Durch die getData()-Methode kann auf den Content-Body, also das JSON-Objekt, das den eigentlichen Inhalte der Nachricht entält zugegriffen werden.

\newpage

\section{Klassendiagramme}

\subsection{Server}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{../Klassendiagramme/server.jpg}
	\caption{Klassendiagramm der Serveranwendung}
\end{figure}

Bemerkung: Die Argumente der Funktionen wurden im Klassendiagramm zur besseren Übersichtlichkeit ausgelassen. Sie können den Klassenbeschreibungen entnommen werden.

\section{Client}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{../Klassendiagramme/client.jpg}
	\caption{Klassendiagramm der Serveranwendung}
\end{figure}

\section{Sequenzdiagramme}

\subsection{Hinzufügen eines Gruppenmitglieds}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{../Sequenzdiagramme/addGroupMember.jpg}
	\caption{Sequenzdiagramm - Hinzufügen eines Gruppenmitglieds Teil 1}
\end{figure}

Das obige Sequenzdiagramm zeigt, was während der Ausführung des Programms passiert, wenn ein Benutzer die Funktion "inviteMember" ausführt. Das User Interface stellt dem Benutzer ein Textfeld zur Eingabe der E-Mailadresse und einen Button zum Bestätigen zur Verfügung. Bei Klick dieses Buttons extrahiert die Activity-Klasse die eingegebene Mail-Adresse aus dem Textfeld und übergibt diese an das ViewModel über den Methodenaufruf "inviteMember". Das ViewModel überprüft zunächst ob es bereits einen Benutzer in Gruppe gibt, der diese E-Mailadresse besitzt. Falls nicht, wird die Gruppeneinladung an die Grouprepository weitergeleitet und von dort über die Klasse TomcatrestApi an den Server gesendet.

Empfängt der Server eine Anfrage, einen User zu einer Gruppe hinzuzufügen, wird diese Anfrage zunächst an das UserDao weitergegeben. Dort wird zuerst die Methode getUserByMail() aufgerufen, um den richtigen Benutzer aus der Datenbank zu finden. Danach wird die addGroupmember-methode des GroupDaos aufgerufen. In dieser Methode wird die neue Gruppenanfrage in der Datenbank gespeichert und es werden die Observer benachrichtigt, dass sich Daten geändert haben.

Der AddEntityObserver erkennt, dass es sich um eine Änderung handelt, die seinen Verantwortungsbereich betrifft. Er bekommt beim Aufruf der update()-Methode die Gruppe mit der zusätzlichen Gruppenanfrage übergeben. Der Observer extrahiert alle Gruppenmitglieder aus dem Gruppenobjekt und ruft die send()-Methode des FcmClients auf, um das geänderte Gruppenobjekt an alle Gruppenmitglieder zu senden. Danach wird die send()-Methode ein zweites Mal aufgerufen, um dem neuen Gruppenmitglied die neue Gruppenanfrage zu übermitteln.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{../Sequenzdiagramme/addMember2.jpg}
	\caption{Sequenzdiagramm - Hinzufügen eines Gruppenmitglieds Teil 2}
\end{figure}

Das zweite Sequenzdiagramm zeigt, was passiert, wenn an einen Benutzer eine Gruppenmitgliedschaftsanfrage gesendet wird. Die Nachricht, die von dem Server, über dem Firebase Cloud Messaging Server, an den Client gesendet wird, löst einen Aufruf der Methode onMessageReceived() in der Klasse MessageReceiver aus. Diese Klasse extrahiert das JSON-Feld COMMAND\_CODE aus dem empfangenen JSON-Objekt und findet so heraus, an welches ServerCommand-Objekt die Anfrage weitergeleitet werden muss.

Nach Weiterleitung der Anfrage an den GroupRequestReceivedCommand wird dort das Datenfeld aus der JSON-Nachricht extrahiert. dort ist die Gruppe gespeichert, zu der er Benutzer eingeladen wurde. Diese Gruppe wird in dem öffentlichen "CurrentData" Field des GroupRepository gespeichert. Danach schickt das GroupRequestReceivedCommand-Objekt einen Broadcast an alle ViewModels. Das GroupViewModel erkennt, dass der Broadcast eine Änderung der Gruppen des Benutzers betrifft. Daher wird dort die onBroadcastReceived()-Methode aufgerufen. Daraufhin holt sich das ViewModel die aktualisierten Daten von der GoupRepository ab, durch einen Aufruf der getCurrentData()-Methode. Da das UI die LiveData der ViewModels beobachtet, wird automatisch bei einer Aktualisierung des ViewModels auch das UI aktualisiert und zeigt die neuen Daten an.

\subsection{Entfernen einer Gruppe}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{../Sequenzdiagramme/deleteGroup_sequenz.jpg}
	\caption{Sequenzdiagramm - Entfernen einer Gruppe}
\end{figure}

Das obige Sequenzdiagramm zeigt den Programmablauf, nachdem ein Benutzer die "Gruppe löschen"-Funktion ausgelöst hat. Das UI gibt den Button Press an das GroupViewModel weiter. Dort wird die Gruppe zunächst in den lokalen Daten gelöscht. Dabei muss sichergestellt werden, dass die Daten nach dem Löschen konsistent sind, also z.B. auch alle GOs der Gruppe gelöscht wurden.

Danach wird die Anfrage über die GroupRepository und das Rest API an den Server übergeben, wo sie durch den Methodenaufruf deleteGroup() in der GroupRestController-Klasse ankommt. Von dort aus wird die Anfrage an das GroupDao gegeben, welches die Gruppe in der Datenbank löscht. Auch hier muss auf die Konsistenz der Daten geachtet werden. Danach werden die Observer des GroupDaos benachrichtigt, dass eine Änderung stattgefunden hat. Da die Änderung nur den EntityRemovedObserver betrifft, wird bei diesem Objekt die Methode update() aufgerufen. Mit dem Methodenaufruf wird auch die gelöschte Gruppe übergeben.

Der Observer baut ein Message-Objekt aus der erhaltenen Gruppe und extrahiert eine Liste aller Gruppenmitglieder aus dem Gruppenobjekt. Diese Daten werden weitergegeben an dem FcmClient über die Methode send(). Dadurch werden die Nachrichten über die Löschung der Gruppe an die Gruppenmitglieder geschickt, damit diese ihre lokalen Daten anpassen können.
% ------- textdoclet_include/finish.tex end

\subsection{Teilnahmestatus ändern}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{../Sequenzdiagramme/Change_status.jpg}
	\caption{Sequenzdiagramm - Teilnahmestatus des Benutzers innerhalb eines GOs ändern}
\end{figure}

Das obige Sequenzdiagramm zeigt, was während der Ausführung des Programms passiert, wenn ein Benutzer seinen Teilnahmestatus innerhalb eines GOs ändert. Das User Interface stellt dem Benutzer ein Button in der GO-Detail-Ansicht zur Verfügung. Beim Anklicken des Buttons wird dem Benutzer ein Feld mit der Wahlmöglichkeit eines Status gezeigt. Activity-Klasse extrahiert den neuen Status und übergibt diesen an das GoViewModel über den Methodenaufruf 'changeStatus()' mit userId, goId und status als Arguments enthalten. Das ViewModel überprüft zunächst ob es ein gültiger Status für diesen Benutzer ist. Falls ja, wird die Anfrage an das GoRepository weitergeleitet und von dort über die Klasse TomcatRestApi (RestAPI) an den Server gesendet.

Die Anfrage kommt durch den Methodenaufruf 'changeStatus()' in der GoRestController-Klasse an und wird dann an das GoEntityDAO weitergegeben, wobei die Methode 'changeStatus()' des GoEntityDAOs aufgerufen wird.  Der neue Status des Benutzers beim aktuellen GO wird in der Datenbank ('UserGoStatus' Entity Bean) gespeichert und es werden die Observer benachrichtigt, dass sich die Daten geändert haben.

Der EntityChangedObserver merkt sich diese Änderung des betroffenen GOs, das er beim Aufruf der 'update()'-Methode bekommt. Der Observer baut ein Message-Objekt aus dem erhaltenen GO und extrahiert eine Liste aller GO-Teilnehmer. Diese Daten werden weitergegeben an dem FcmClient über die Methode 'send()'. Die Nachricht, die von dem Server, über dem Firebase Cloud Messaging Server, an den Client gesendet wird, löst einen Aufruf der Methode 'onMessageReceived()' in der Klasse MessageReceiver aus. Diese Klasse findet heraus, an welches ServerCommand-Objekt die Anfrage weitergeleitet werden muss.

Nach Weiterleitung der Anfrage an den StatusChangedCommand  werden die neuen Daten (das GO) im GoRepository gespeichert. Danach schickt das StatusChangedCommand-Objekt einen Broadcast an alle ViewModels. Das GoViewModel erkennt, dass der Broadcast eine Änderung des GOs des Benutzers betrifft. Daraufhin holt sich das ViewModel die aktualisierten Daten von der GoRepository ab, durch einen Aufruf der 'getUpdatedData()'-Methode. Da das UI die LiveData der ViewModels beobachtet, wird automatisch bei einer Aktualisierung des ViewModels auch das UI aktualisiert und zeigt die neuen Daten an.


\subsection{GPS-Standort ermitteln}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{../Sequenzdiagramme/Clustering.jpg}
	\caption{Sequenzdiagramm - Anonymisierte und gemittelte GPS-Standort (Cluster der Standorte) der Teilnehmer eines GOs ermitteln}
\end{figure}

Das obige Sequenzdiagramm zeigt, was während der Ausführung des Programms passiert, wenn der Startzeitpunkt eines bestimmten GOs eintritt. Zu dem Zeitpunkt wird der Teilnahmestatus aller Teilnehmer des GOs mit dem Status 'Bestätigt' auf 'Unterwegs' gesetzt. Dabei wird die Methode 'getCluster()' der Klasse GoViewModel mit Parametern userId, goId und Location (latitude und longitude) aller Teilnehmer des GOs mit dem Status 'Unterwegs' aufgerufen. Das ViewModel überprüft zunächst ob die Daten für diesen Benutzer gültig sind. Falls ja, wird die Anfrage an das GoRepository weitergeleitet und von dort über die Klasse TomcatRestApi (RestAPI) an den Server gesendet.

Die Anfrage kommt durch den Methodenaufruf 'getLocation()' in der GoRestController-Klasse an und wird dann an das LocationService weitergegeben. LocationService spielt dabei die Rolle von Context des Strategie-Entwurfsmusters. Die konkrete Strategie 'GoClusterStrategy' wird benutzt, um mithilfe der Methode 'calculate()' das Cluster aus den GPS-Standorten aller Teilnehmer des GOs zu berechnen und zurückzugeben.

Das berechnete Cluster wird weiter zurückgegeben, bis die neuen Daten (Cluster der Standorte) im GoRepository gespeichert werden. Danach wird ein Broadcast an alle ViewModels geschickt, dabei erkennt das GoViewModel, dass der Broadcast eine Änderung des GOs (also GPS-Standort aller Teilnehmer) betrifft. Daraufhin holt sich das ViewModel die aktualisierten Daten von der GoRepository durch einen Aufruf der 'getUpdatedData()'-Methode ab. Da das UI die LiveData der ViewModels beobachtet, wird automatisch bei einer Aktualisierung des ViewModels auch das UI aktualisiert und zeigt die neuen Daten an.

\subsection{Erstellen eines GOs}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{../Sequenzdiagramme/Create_Go.jpg}
	\caption{Sequenzdiagramm - Ein neues GO in der Gruppe erstellen}
\end{figure}

Das obige Sequenzdiagramm zeigt, was während der Ausführung des Programms passiert, wenn ein Benutzer ein neues GO in der Gruppe erstellt. Das User Interface stellt dem Benutzer ein Button in der Group-Detail-Ansicht zur Verfügung. Beim Anklicken des Buttons wird dem Benutzer ein Textfeld gezeigt, wobei der Benutzer folgende Details von GO angeben kann: Name des GOs, Beschreibung, Start- und Endezeitpunkt, Ziel des GOs und einen Schwellwert für Clustering. Activity-Klasse erstellt ein neues GO-Objekt mit diesen und noch mit IDs der Gruppe und des Benutzers als Parameter und übergibt dieses an das GoListViewModel über den Methodenaufruf 'createGo()'. Das ViewModel überprüft zunächst ob alle Daten gültig sind. Falls ja, wird die Anfrage an das GoRepository weitergeleitet und von dort über die Klasse TomcatRestApi (RestAPI) an den Server gesendet.

Die Anfrage kommt durch den Methodenaufruf 'createGo()' in der GoRestController-Klasse an und wird dann an das GoEntityDAO weitergegeben, wobei die Methode 'createGo()' des GoEntityDAOs aufgerufen wird. Das neue GO wird in der Datenbank ('GO' Entity Bean) gespeichert und es werden die Observer benachrichtigt, dass sich die Daten geändert haben.

Der EntityCreatedObserver erkennt das Erstellen des neuen GOs, das er beim Aufruf der 'update()'-Methode bekommt. Der Observer baut ein Message-Objekt aus dem neuen GO und extrahiert eine Liste aller Mitglieder der Gruppe, zu der das GO gehört. Diese Daten werden weitergegeben an dem FcmClient über die Methode 'send()'. Die Nachricht, die von dem Server, über dem Firebase Cloud Messaging Server, an den Client gesendet wird, löst einen Aufruf der Methode 'onMessageReceived()' in der Klasse MessageReceiver aus. Diese Klasse findet heraus, an welches ServerCommand-Objekt die Anfrage weitergeleitet werden muss.

Nach Weiterleitung der Anfrage an den GoAddedCommand  werden die neuen Daten (das erstellte GO) im GoRepository gespeichert. Danach schickt das GoAddedCommand-Objekt einen Broadcast an alle ViewModels. Das GoListViewModel erkennt, dass der Broadcast die Erstellung des neuen GOs für den Mitglied dieser Gruppe betrifft. Daraufhin holt sich das ViewModel die aktualisierten Daten von der GoRepository ab, durch einen Aufruf der 'getUpdatedData()'-Methode. Da das UI die LiveData der ViewModels beobachtet, wird automatisch bei einer Aktualisierung des ViewModels auch das UI aktualisiert. Dabei wird die aktuelle GroupDetailActivity gelöscht und eine neue GoDetailActivity (zum neuen GO) erstellt und gezeigt.

\end{document}
\grid
